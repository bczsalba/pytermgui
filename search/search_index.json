{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hey there!","text":"<p>Welcome to the PyTermGUI documentation!</p> <p>For a general overview of the framework, follow the navigation at the bottom. For a set of working examples, check out the walkthroughs section. For a complete look at the API, see our reference!</p> <p></p>"},{"location":"#so-what-is-a-terminal-user-interface-or-tui-anyways","title":"So what is a Terminal User Interface (or TUI) anyways?","text":"<p>A Terminal User Interface is, in general terms, a GUI in your terminal. Due to the terminal's attributes &amp; limitations it can only use plain text to display content, and has to arrange itself on the terminal's character grid.</p> <p>In effect, this means terminal applications are:</p> <ul> <li>More constrained, which can often lead to more interesting solutions around known problems</li> <li>More standardized (though not enough)</li> <li>Much faster to execute</li> <li>Way cooler lookin'</li> </ul>"},{"location":"#if-all-that-is-true-why-are-tuis-so-rare","title":"If all that is true, why are TUIs so rare?","text":"<p>Historically, you had 2 options when writing a TUI:</p> <ul> <li>Create your own framework with its own rendering pipeline</li> <li>Use curses or ncurses</li> </ul> <p>Neither of these are simple to do; drawing in the terminal requires knowledge of a bunch of scattered standards and precedents, which, for the most part, are only available through archaic documentation.</p> <p>Things have gotten a lot better in recent years. Projects like Jexer and notcurses have shown how capable terminals are, and projects like bubbletea and tui-rs have made simplified and modernized TUI creation.</p>"},{"location":"#how-do-we-help-the-situation","title":"How do we help the situation?","text":"<p>PTG provides abstractions for the low-level interactions with the terminal, and a modular widget system that is built ontop.</p> <p>Our goals are the following:</p> <ul> <li>Versatility</li> <li>Expressive, readable but compact code</li> <li>No pointless abstractions</li> <li>Minimal dependencies</li> </ul> <p>Because of the way the framework is built, you can implement the input-key-mouse-draw loop used internally by WindowManager in {insert linecount} lines!</p> <p>Widget layouts are explicit from the syntax of their creation. Widgets are rendered line-by-line, using the plain strings they return. There is built-in support for keyboard &amp; mouse inputs on all widgets, as well as the underlying low-level API that is used to make it all work.</p> <p>This means that you, the user, can create TUI applications with workflows that rival the web in simplicity, without having to deal with the massive fragmentation, framework war, and shudders CSS.</p>"},{"location":"exports/","title":"SVG & HTML exports","text":"<p>You may have noticed the screenshots used throughout this documentation. Fun fact: They are all generated using the module! Some code is run, and its result is then displayed in an SVG image.</p> <p>To do this, we use the Termage module, which in turn uses the Terminal.record method, and then calls Recorder.export_svg on the resulting terminal.</p> <p>To use the recording &amp; export API, simply enter a <code>Terminal.record</code> context, run some code &amp; save the recording output:</p> PythonOutput <pre><code>from pytermgui import ColorPicker, pretty, terminal, tim\n\ntim.alias(\"code\", \"@black #auto dim\")\n\nwith terminal.record() as recording:\n    tim.print(\"[italic]Everything[/] you print will be captured!\")\n    tim.print()\n    tim.print(\n        \"By default, only [code]PTG[/]'s prints functions are affected,\"\n        + \"\\nbut by overwriting [code]sys.stdout.write[/] you can capture any Python output.\"\n    )\n</code></pre> <p> docs/src/exports1.py Everything \u00a0you\u00a0print\u00a0will\u00a0be\u00a0captured! By\u00a0default,\u00a0only\u00a0 PTG 's\u00a0prints\u00a0functions\u00a0are\u00a0affected, but\u00a0by\u00a0overwriting\u00a0 sys.stdout.write \u00a0you\u00a0can\u00a0capture\u00a0any\u00a0Python\u00a0output. <p></p> <p>You can even hide the \"window\"'s title bar, and get a rectangular image with just your code's output by specifying <code>chrome=False</code> while exporting:</p> <p></p> <p> Everything \u00a0you\u00a0print\u00a0will\u00a0be\u00a0captured! By\u00a0default,\u00a0only\u00a0 PTG 's\u00a0prints\u00a0functions\u00a0are\u00a0affected, but\u00a0by\u00a0overwriting\u00a0 sys.stdout.write \u00a0you\u00a0can\u00a0capture\u00a0any\u00a0Python\u00a0output. </p> <p>Note</p> <p>You can also export as plain HTML! We can't easily show it here (without manually pasting it in) since Termage and its plugin only wrap the SVG API.</p> <p>For more information, check out the Termage module!</p>"},{"location":"future/","title":"The future of this library","text":"<p>I intend on growing this library as long as there are ways to improve it; life might get in the way at some points, but I want to keep using the project in my personal tooling, and I know many people count on it's reliability for their own.</p> <p>The current version of the module is pretty stable in terms of the API. There is only a handful of upcoming API changes, some of which will unfortunately have to roll over a major version. This page exists as a sort of heads-up note, so users know what to expect. I will try to keep this up to date whenever plans change, or tasks are complete.</p>"},{"location":"future/#800-the-second-widget-update","title":"8.0.0 - The (second) widget update","text":"<p>The next major release is, according to my plans, the last one for a long time. It will be a modernization of a lot of APIs, and it's main purpose is to bundle all the minor but compatibility breaking changes together into a single release.</p> <p>The end goal of this version is to make it so implementing the 7GUIs is simple, and can be done by most newcomers to the library.</p>"},{"location":"future/#planned-changes","title":"Planned changes","text":"<ul> <li>A new, more stable <code>Container.get_lines</code> implementation</li> <li>Better API for aligning widgets within containers</li> <li>A rethink of the sizing system -- likely implementing the layout system's dimensions, and possibly removing static sizes</li> <li>Better implementation of heights, one that is more consistent with widths</li> <li>Better buttons: checkboxes with labels, new base button class with more customization and nicer styling and rethink of toggle</li> <li>Better, more customizable layouts within containers: probably a better splitter, possibly allowing Containers to use layouts</li> </ul>"},{"location":"future/#810-a-better-yaml-styling-engine","title":"8.1.0 - A better YAML styling engine","text":"<p>The current YAML styling works, but doesn't support quite as much as I would like it to. CSS, as as hideous as it can be does some things well: being able to apply styles to specific elements individually, swapping style groups on the fly and integration with the scripting language, just to name a few.</p> <p>With this update, our YAML files should do more or less the same as CSS, but in a more thought-out manner, with clear and readable syntax.</p> <p>An example PTG YAML file could be the following:</p> styles.ptg<pre><code>aliases:\nmain-background: '@surface-1'\nmain-foreground: 'surface+1'\n\nconfig:\n*:\nbackground: 'main-background'\n\nWindow is_modal?:\nborders: 'DOUBLE'\nstyles.border__corner: 'error'\n\nButton .confirm:\nstyles.normal:\nbackground: '@success-2'\nforeground: 'success'\n\nstyles.hover:\nbackground: '@success'\nforeground: 'success+1'\n\nstyles.active:\nbackground: '@success+1'\nforeground: 'success+2'\n</code></pre> <pre><code>from pytermgui import Stylesheet\n\nstyles = Stylesheet.load(\"styles.ptg\", auto_reload=True)\n</code></pre>"},{"location":"future/#planned-changes_1","title":"Planned changes","text":"<ul> <li>Re-wiring <code>_IdManager</code> to act as the style managment overlord</li> <li>Likely re-writing the <code>file_loaders</code> module. I hope to keep the current API alive, with massive deprecation notices</li> <li>Moving some of the default widget configuration into a <code>default.yaml</code> file</li> </ul>"},{"location":"future/#8x0-a-better-composition","title":"8.X.0: A better composition","text":"<p>The current compositor isn't super smart. It does way too much writes to the terminal, and thus it makes things flickery and unstable on lower power emulators. A fix to this is already far in the works, and involves a resizable matrix of screen coordinates to their content. I want this update to happen seemlessly on the user's side, but this makes things a lot more difficult.</p>"},{"location":"future/#planned-changes_2","title":"Planned changes","text":"<ul> <li>Add a canvas class that handles emulating the terminal's display</li> <li>Change compositor to write to a canvas, and to only update the terminal with the canvas' contents</li> </ul>"},{"location":"inspect/","title":"Inspection","text":"<p>PyTermGUI provides a pretty nifty inspection utility, <code>inspect</code>! It's useful to figure out the signature of functions, inspect their general shape &amp; docstrings.</p> <p> docs/src/inspect1.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502\u00a0 pytermgui.widgets.containers.Container \u00a0\u2502 \u2502\u00a0 Located\u00a0in\u00a0 /Users/lapis/Code/Projects/pytermgui/pytermgui/widgets/containers.py \u00a0\u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 class Container (*widgets:\u00a0 Any ,\u00a0**attrs:\u00a0 Any )\u00a0-&gt;\u00a0 None : A\u00a0widget\u00a0that\u00a0displays\u00a0other\u00a0widgets,\u00a0stacked\u00a0vertically. def bind (self,\u00a0key:\u00a0 str ,\u00a0action:\u00a0 BoundCallback ,\u00a0description:\u00a0 Optional [ str ]\u00a0=\u00a0 None )\u00a0-&gt;\u00a0 None : Binds\u00a0an\u00a0action\u00a0to\u00a0a\u00a0keypress. def center (self,\u00a0where:\u00a0 CenteringPolicy \u00a0|\u00a0 None \u00a0=\u00a0 None ,\u00a0store:\u00a0 bool \u00a0=\u00a0 True )\u00a0-&gt;\u00a0 Container : Centers\u00a0this\u00a0object\u00a0to\u00a0the\u00a0given\u00a0axis. def contains (self,\u00a0pos:\u00a0 tuple [ int ,\u00a0 int ])\u00a0-&gt;\u00a0 bool : Determines\u00a0whether\u00a0widget\u00a0contains\u00a0`pos`. def copy (self)\u00a0-&gt;\u00a0 Widget : Creates\u00a0a\u00a0deep\u00a0copy\u00a0of\u00a0this\u00a0widget def debug (self)\u00a0-&gt;\u00a0 str : Returns\u00a0a\u00a0string\u00a0with\u00a0identifiable\u00a0information\u00a0on\u00a0this\u00a0widget. def execute_binding (self,\u00a0key:\u00a0 Any ,\u00a0ignore_any:\u00a0 bool \u00a0=\u00a0 False )\u00a0-&gt;\u00a0 bool : </p> <p>The easiest way to use it is by running <code>ptg -i</code> or <code>ptg --inspect</code> with a fully qualified name. This will create an Inspector object for the given name, and print it.</p> <p>You can also give the same function an expression to evaluate. This might be useful if you want to know the type &amp; methods of an object that is the result of some function or method.</p> <p>The more general way to access the API is by using the inspect function from within Python. You can give it any object, and it will give you as much information as it can found out from the signature &amp; source code. You can also play around with an interactive version of the tool by running <code>ptg --app inspect</code>, which will give you a nice UI to play around with.</p> <p> docs/src/inspect2.py \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551\u00a0 Inspector \u00a0\u2551 \u2551\u00a0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u00a0\u2551 \u2551\u00a0 \u2502\u00a0 pytermgui.widgets.boxes.Box \u00a0\u2502 \u00a0\u2551 \u2551\u00a0 \u2502\u00a0 Located\u00a0in\u00a0 /Users/lapis/Code/Projects/pytermgui/pytermgui/widgets/boxes.py \u00a0\u2502 \u00a0\u2551 \u2551\u00a0 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u00a0\u2551 \u2551\u00a0 class Box (lines:\u00a0 list [ str ],\u00a0content_char:\u00a0 str \u00a0=\u00a0x): \u00a0\u2551 \u2551\u00a0 Class\u00a0for\u00a0defining\u00a0border\u00a0&amp;\u00a0corner\u00a0styles \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 `lines`\u00a0should\u00a0be\u00a0`list[str]`\u00a0of\u00a0length\u00a03,\u00a0such\u00a0as: \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 ```python3 \u00a0\u2551 \u2551\u00a0 lines\u00a0=\u00a0[ \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\".---.\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\"|\u00a0x\u00a0|\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\"`---`\", \u00a0\u2551 \u2551\u00a0 ] \u00a0\u2551 \u2551\u00a0 ``` \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 The\u00a0length\u00a0of\u00a0individual\u00a0lines\u00a0is\u00a0arbitrary,\u00a0only\u00a0limitation\u00a0is \u00a0\u2551 \u2551\u00a0 that\u00a0the\u00a0top\u00a0&amp;\u00a0bottom\u00a0border\u00a0characters\u00a0should\u00a0occur\u00a0most\u00a0often\u00a0in \u00a0\u2551 \u2551\u00a0 their\u00a0respective\u00a0lines. \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 You\u00a0can\u00a0set\u00a0corners\u00a0to\u00a0be\u00a0of\u00a0any\u00a0length,\u00a0their\u00a0end\u00a0is\u00a0calculated\u00a0by \u00a0\u2551 \u2551\u00a0 finding\u00a0the\u00a0index\u00a0of\u00a0the\u00a0most\u00a0often\u00a0occuring\u00a0character,\u00a0which\u00a0is\u00a0assumed \u00a0\u2551 \u2551\u00a0 to\u00a0be\u00a0the\u00a0border\u00a0character. \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 Top\u00a0&amp;\u00a0bottom\u00a0borders\u00a0are\u00a0currently\u00a0limited\u00a0in\u00a0length\u00a0to\u00a01,\u00a0but\u00a0sides \u00a0\u2551 \u2551\u00a0 operate\u00a0similarly\u00a0to\u00a0corners.\u00a0They\u00a0are\u00a0separated\u00a0by\u00a0finding\u00a0the\u00a0index \u00a0\u2551 \u2551\u00a0 of\u00a0the\u00a0fill\u00a0char\u00a0from\u00a0the\u00a0start\u00a0or\u00a0end.\u00a0The\u00a0content\u00a0char\u00a0is\u00a0\"x\"\u00a0by \u00a0\u2551 \u2551\u00a0 default,\u00a0however\u00a0it\u00a0can\u00a0be\u00a0set\u00a0to\u00a0anything\u00a0else\u00a0by\u00a0giving\u00a0the\u00a0\"content_char\" \u00a0\u2551 \u2551\u00a0 construction\u00a0parameter. \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 As\u00a0such,\u00a0this: \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 ```python3 \u00a0\u2551 \u2551\u00a0 boxes.Box( \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0[ \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"corner1\u00a0________________\u00a0corner2\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"xleft\u00a0\u00a0\u00a0################\u00a0rightxx\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"corner3\u00a0----------------\u00a0corner4\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0], \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0content_char=\"#\", \u00a0\u2551 \u2551\u00a0 ) \u00a0\u2551 \u2551\u00a0 ``` \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 Will\u00a0result\u00a0in: \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 ```python3 \u00a0\u2551 \u2551\u00a0 Box( \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0borders=['xleft\u00a0\u00a0\u00a0',\u00a0'_',\u00a0'\u00a0rightxx',\u00a0'-'], \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0corners=['corner1\u00a0',\u00a0'\u00a0corner2',\u00a0'\u00a0corner4',\u00a0'corner3\u00a0'] \u00a0\u2551 \u2551\u00a0 ) \u00a0\u2551 \u2551\u00a0 ``` \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 def debug (self)\u00a0-&gt;\u00a0 str : \u00a0\u2551 \u2551\u00a0 Return\u00a0identifiable\u00a0information\u00a0about\u00a0object \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 def set_chars_of (self,\u00a0cls_or_obj:\u00a0 WidgetType )\u00a0-&gt;\u00a0 WidgetType : \u00a0\u2551 \u2551\u00a0 Set\u00a0border\u00a0&amp;\u00a0corner\u00a0chars\u00a0of\u00a0cls_or_obj\u00a0to\u00a0self\u00a0values \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u00a0\u2551 \u2551\u00a0 \u2502\u00a0 boxes.Box \u00a0\u2502 \u00a0\u2551 \u2551\u00a0 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u00a0\u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551\u00a0 Inspector \u00a0\u2551 \u2551\u00a0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u00a0\u2551 \u2551\u00a0 \u2502\u00a0 pytermgui.widgets.boxes.Box \u00a0\u2502 \u00a0\u2551 \u2551\u00a0 \u2502\u00a0 Located\u00a0in\u00a0 /Users/lapis/Code/Projects/pytermgui/pytermgui/widgets/boxes.py \u00a0\u2502 \u00a0\u2551 \u2551\u00a0 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u00a0\u2551 \u2551\u00a0 class Box (lines:\u00a0 list [ str ],\u00a0content_char:\u00a0 str \u00a0=\u00a0x): \u00a0\u2551 \u2551\u00a0 Class\u00a0for\u00a0defining\u00a0border\u00a0&amp;\u00a0corner\u00a0styles \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 `lines`\u00a0should\u00a0be\u00a0`list[str]`\u00a0of\u00a0length\u00a03,\u00a0such\u00a0as: \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 ```python3 \u00a0\u2551 \u2551\u00a0 lines\u00a0=\u00a0[ \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\".---.\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\"|\u00a0x\u00a0|\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\"`---`\", \u00a0\u2551 \u2551\u00a0 ] \u00a0\u2551 \u2551\u00a0 ``` \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 The\u00a0length\u00a0of\u00a0individual\u00a0lines\u00a0is\u00a0arbitrary,\u00a0only\u00a0limitation\u00a0is \u00a0\u2551 \u2551\u00a0 that\u00a0the\u00a0top\u00a0&amp;\u00a0bottom\u00a0border\u00a0characters\u00a0should\u00a0occur\u00a0most\u00a0often\u00a0in \u00a0\u2551 \u2551\u00a0 their\u00a0respective\u00a0lines. \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 You\u00a0can\u00a0set\u00a0corners\u00a0to\u00a0be\u00a0of\u00a0any\u00a0length,\u00a0their\u00a0end\u00a0is\u00a0calculated\u00a0by \u00a0\u2551 \u2551\u00a0 finding\u00a0the\u00a0index\u00a0of\u00a0the\u00a0most\u00a0often\u00a0occuring\u00a0character,\u00a0which\u00a0is\u00a0assumed \u00a0\u2551 \u2551\u00a0 to\u00a0be\u00a0the\u00a0border\u00a0character. \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 Top\u00a0&amp;\u00a0bottom\u00a0borders\u00a0are\u00a0currently\u00a0limited\u00a0in\u00a0length\u00a0to\u00a01,\u00a0but\u00a0sides \u00a0\u2551 \u2551\u00a0 operate\u00a0similarly\u00a0to\u00a0corners.\u00a0They\u00a0are\u00a0separated\u00a0by\u00a0finding\u00a0the\u00a0index \u00a0\u2551 \u2551\u00a0 of\u00a0the\u00a0fill\u00a0char\u00a0from\u00a0the\u00a0start\u00a0or\u00a0end.\u00a0The\u00a0content\u00a0char\u00a0is\u00a0\"x\"\u00a0by \u00a0\u2551 \u2551\u00a0 default,\u00a0however\u00a0it\u00a0can\u00a0be\u00a0set\u00a0to\u00a0anything\u00a0else\u00a0by\u00a0giving\u00a0the\u00a0\"content_char\" \u00a0\u2551 \u2551\u00a0 construction\u00a0parameter. \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 As\u00a0such,\u00a0this: \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 ```python3 \u00a0\u2551 \u2551\u00a0 boxes.Box( \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0[ \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"corner1\u00a0________________\u00a0corner2\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"xleft\u00a0\u00a0\u00a0################\u00a0rightxx\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"corner3\u00a0----------------\u00a0corner4\", \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0], \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0content_char=\"#\", \u00a0\u2551 \u2551\u00a0 ) \u00a0\u2551 \u2551\u00a0 ``` \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 Will\u00a0result\u00a0in: \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 ```python3 \u00a0\u2551 \u2551\u00a0 Box( \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0borders=['xleft\u00a0\u00a0\u00a0',\u00a0'_',\u00a0'\u00a0rightxx',\u00a0'-'], \u00a0\u2551 \u2551\u00a0 \u00a0\u00a0\u00a0\u00a0corners=['corner1\u00a0',\u00a0'\u00a0corner2',\u00a0'\u00a0corner4',\u00a0'corner3\u00a0'] \u00a0\u2551 \u2551\u00a0 ) \u00a0\u2551 \u2551\u00a0 ``` \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 def debug (self)\u00a0-&gt;\u00a0 str : \u00a0\u2551 \u2551\u00a0 Return\u00a0identifiable\u00a0information\u00a0about\u00a0object \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 def set_chars_of (self,\u00a0cls_or_obj:\u00a0 WidgetType )\u00a0-&gt;\u00a0 WidgetType : \u00a0\u2551 \u2551\u00a0 Set\u00a0border\u00a0&amp;\u00a0corner\u00a0chars\u00a0of\u00a0cls_or_obj\u00a0to\u00a0self\u00a0values \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u00a0\u2551 \u2551\u00a0 \u2502\u00a0 boxes.Box \u00a0\u2502 \u00a0\u2551 \u2551\u00a0 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u00a0\u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d </p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pytermgui<ul> <li>animations</li> <li>ansi_interface</li> <li>cell</li> <li>cmd</li> <li>colors</li> <li>context_managers</li> <li>enums</li> <li>exceptions</li> <li>exporters</li> <li>fancy_repr</li> <li>file_loaders</li> <li>helpers</li> <li>highlighters</li> <li>input</li> <li>inspector</li> <li>markup<ul> <li>aliases</li> <li>language</li> <li>macros</li> <li>parsing</li> <li>tokens</li> </ul> </li> <li>palettes</li> <li>prettifiers</li> <li>pretty</li> <li>regex</li> <li>serialization</li> <li>term</li> <li>widgets<ul> <li>base</li> <li>boxes</li> <li>button</li> <li>checkbox</li> <li>collapsible</li> <li>color_picker</li> <li>containers</li> <li>fancy_repr</li> <li>frames</li> <li>inline</li> <li>input_field</li> <li>keyboard_button</li> <li>pixel_matrix</li> <li>slider</li> <li>styles</li> <li>toggle</li> </ul> </li> <li>win32console</li> <li>window_manager<ul> <li>compositor</li> <li>layouts</li> <li>manager</li> <li>window</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/pytermgui/","title":"Index","text":"<p>Welcome to the API reference for PyTermGUI, a Python TUI framework with mouse support, modular widget system, customizable and rapid terminal markup language and more!</p>"},{"location":"reference/pytermgui/#pytermgui.auto","title":"<code>auto(data, **widget_args)</code>","text":"<p>Creates a widget from specific data structures.</p> <p>This conversion includes various widget classes, as well as some shorthands for more complex objects.  This method is called implicitly whenever a non-widget is attempted to be added to a Widget.</p> <p>You can read up on the syntacies for each builtin widget within the widget documentation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The structure to convert. See below for formats.</p> required <code>**widget_args</code> <code>Any</code> <p>Arguments passed straight to the widget constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[Widget | list[Splitter]]</code> <p>The widget or list of widgets created, or None if the passed structure could</p> <code>Optional[Widget | list[Splitter]]</code> <p>not be converted.</p> <p>Example:</p> <pre><code>from pytermgui import Container\nform = (\n    Container(id=\"form\")\n    + \"[157 bold]This is a title\"\n    + \"\"\n    + {\"[72 italic]Label1\": \"[210]Button1\"}\n    + {\"[72 italic]Label2\": \"[210]Button2\"}\n    + {\"[72 italic]Label3\": \"[210]Button3\"}\n    + \"\"\n    + [\"Submit\", lambda _, button, your_submit_handler(button.parent)]\n)\n</code></pre> Source code in <code>pytermgui/__init__.py</code> <pre><code>def auto(data: Any, **widget_args: Any) -&gt; Optional[Widget | list[Splitter]]:\n\"\"\"Creates a widget from specific data structures.\n\n    This conversion includes various widget classes, as well as some shorthands for\n    more complex objects.  This method is called implicitly whenever a non-widget is\n    attempted to be added to a Widget.\n\n    You can read up on the syntacies for each builtin widget within the widget\n    [documentation](/widgets/builtins).\n\n    Args:\n        data: The structure to convert. See below for formats.\n        **widget_args: Arguments passed straight to the widget constructor.\n\n    Returns:\n        The widget or list of widgets created, or None if the passed structure could\n        not be converted.\n\n    Example:\n\n    ```python3\n    from pytermgui import Container\n    form = (\n        Container(id=\"form\")\n        + \"[157 bold]This is a title\"\n        + \"\"\n        + {\"[72 italic]Label1\": \"[210]Button1\"}\n        + {\"[72 italic]Label2\": \"[210]Button2\"}\n        + {\"[72 italic]Label3\": \"[210]Button3\"}\n        + \"\"\n        + [\"Submit\", lambda _, button, your_submit_handler(button.parent)]\n    )\n    ```\n    \"\"\"\n    # In my opinion, returning immediately after construction is much more readable.\n    # pylint: disable=too-many-return-statements\n\n    # Nothing to do.\n    if isinstance(data, Widget):\n        # Set all **widget_args\n        for key, value in widget_args.items():\n            setattr(data, key, value)\n\n        return data\n\n    # Label\n    if isinstance(data, str):\n        return Label(data, **widget_args)\n\n    # Splitter\n    if isinstance(data, tuple):\n        return Splitter(*data, **widget_args)\n\n    # buttons\n    if isinstance(data, list):\n        label = data[0]\n        onclick = None\n        if len(data) &gt; 1:\n            onclick = data[1]\n\n        # Checkbox\n        if isinstance(label, bool):\n            return Checkbox(onclick, checked=label, **widget_args)\n\n        # Toggle\n        if isinstance(label, tuple):\n            assert len(label) == 2\n            return Toggle(label, onclick, **widget_args)\n\n        return Button(label, onclick, **widget_args)\n\n    # prompt splitter\n    if isinstance(data, dict):\n        rows: list[Splitter] = []\n\n        for key, value in data.items():\n            left = auto(key, parent_align=HorizontalAlignment.LEFT)\n            right = auto(value, parent_align=HorizontalAlignment.RIGHT)\n\n            rows.append(Splitter(left, right, **widget_args))\n\n        if len(rows) == 1:\n            return rows[0]\n\n        return rows\n\n    return None\n</code></pre>"},{"location":"reference/pytermgui/animations/","title":"animations","text":"<p>All animation-related classes &amp; functions.</p> <p>The biggest exports are <code>Animation</code> and its subclasses, as well as <code>Animator</code>. A global instance of <code>Animator</code> is also exported, under the <code>animator</code> name.</p> <p>These can be used both within a WindowManager context (where stepping is done automatically by the <code>pytermgui.window_manager.Compositor</code> on every frame, or manually, by calling <code>animator.step</code> with an elapsed time argument.</p> <p>You can register animations to the Animator using either its <code>schedule</code> method, with an already constructed <code>Animation</code> subclass, or either <code>Animator.animate_attr</code> or <code>Animator.animate_float</code> for an in-place construction of the animation instance.</p>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.animator","title":"<code>animator = Animator()</code>  <code>module-attribute</code>","text":"<p>The global Animator instance used by all of the library.</p>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation","title":"<code>Animation</code>  <code>dataclass</code>","text":"<p>The baseclass for all animations.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>@dataclass\nclass Animation:\n\"\"\"The baseclass for all animations.\"\"\"\n\n    duration: int\n    direction: Direction\n    loop: bool\n\n    on_step: Callable[[Animation], bool] | None\n    on_finish: Callable[[Animation], None] | None\n\n    state: float\n    _remaining: float\n\n    def __post_init__(self) -&gt; None:\n        self.state = 0.0 if self.direction is Direction.FORWARD else 1.0\n        self._remaining = self.duration\n        self._is_paused = False\n\n    def _update_state(self, elapsed: float) -&gt; bool:\n\"\"\"Updates the internal float state of the animation.\n\n        Args:\n            elapsed: The time elapsed since last update.\n\n        Returns:\n            True if the animation deems itself complete, False otherwise.\n        \"\"\"\n\n        if self._is_paused:\n            return False\n\n        self._remaining -= elapsed * 1000\n\n        self.state = (self.duration - self._remaining) / self.duration\n\n        if self.direction is Direction.BACKWARD:\n            self.state = 1 - self.state\n\n        self.state = min(self.state, 1.0)\n\n        if not 0.0 &lt;= self.state &lt; 1.0:\n            if not self.loop:\n                return True\n\n            self._remaining = self.duration\n            self.direction = Direction(self.direction.value * -1)\n\n        return False\n\n    def pause(self, setting: bool = True) -&gt; None:\n\"\"\"Pauses the animation.\"\"\"\n\n        self._is_paused = setting\n\n    def resume(self) -&gt; None:\n\"\"\"Resumes the animation.\"\"\"\n\n        self.pause(False)\n\n    def step(self, elapsed: float) -&gt; bool:\n\"\"\"Updates animation state.\n\n        This should call `_update_state`, passing in the elapsed value. That call\n        will update the `state` attribute, which can then be used to animate things.\n\n        Args:\n            elapsed: The time elapsed since last update.\n        \"\"\"\n\n        state_finished = self._update_state(elapsed)\n\n        step_finished = False\n        if self.on_step is not None:\n            step_finished = self.on_step(self)\n\n        return state_finished or step_finished\n\n    def finish(self) -&gt; None:\n\"\"\"Finishes and cleans up after the animation.\n\n        Called by `Animator` after `on_step` returns True. Should call `on_finish` if it\n        is not None.\n        \"\"\"\n\n        if self.on_finish is not None:\n            self.on_finish(self)\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation.finish","title":"<code>finish()</code>","text":"<p>Finishes and cleans up after the animation.</p> <p>Called by <code>Animator</code> after <code>on_step</code> returns True. Should call <code>on_finish</code> if it is not None.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def finish(self) -&gt; None:\n\"\"\"Finishes and cleans up after the animation.\n\n    Called by `Animator` after `on_step` returns True. Should call `on_finish` if it\n    is not None.\n    \"\"\"\n\n    if self.on_finish is not None:\n        self.on_finish(self)\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation.pause","title":"<code>pause(setting=True)</code>","text":"<p>Pauses the animation.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def pause(self, setting: bool = True) -&gt; None:\n\"\"\"Pauses the animation.\"\"\"\n\n    self._is_paused = setting\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation.resume","title":"<code>resume()</code>","text":"<p>Resumes the animation.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def resume(self) -&gt; None:\n\"\"\"Resumes the animation.\"\"\"\n\n    self.pause(False)\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animation.step","title":"<code>step(elapsed)</code>","text":"<p>Updates animation state.</p> <p>This should call <code>_update_state</code>, passing in the elapsed value. That call will update the <code>state</code> attribute, which can then be used to animate things.</p> <p>Parameters:</p> Name Type Description Default <code>elapsed</code> <code>float</code> <p>The time elapsed since last update.</p> required Source code in <code>pytermgui/animations.py</code> <pre><code>def step(self, elapsed: float) -&gt; bool:\n\"\"\"Updates animation state.\n\n    This should call `_update_state`, passing in the elapsed value. That call\n    will update the `state` attribute, which can then be used to animate things.\n\n    Args:\n        elapsed: The time elapsed since last update.\n    \"\"\"\n\n    state_finished = self._update_state(elapsed)\n\n    step_finished = False\n    if self.on_step is not None:\n        step_finished = self.on_step(self)\n\n    return state_finished or step_finished\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator","title":"<code>Animator</code>","text":"<p>The Animator class</p> <p>This class maintains a list of animations (self._animations), stepping each of them forward as long as they return False. When they return False, the animation is removed from the tracked animations.</p> <p>This stepping is done when <code>step</code> is called.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>class Animator:\n\"\"\"The Animator class\n\n    This class maintains a list of animations (self._animations), stepping\n    each of them forward as long as they return False. When they return\n    False, the animation is removed from the tracked animations.\n\n    This stepping is done when `step` is called.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initializes an animator.\"\"\"\n\n        self._animations: list[Animation] = []\n\n    def __contains__(self, item: object) -&gt; bool:\n\"\"\"Returns whether the item is inside _animations.\"\"\"\n\n        return item in self._animations\n\n    @property\n    def is_active(self) -&gt; bool:\n\"\"\"Determines whether there are any active animations.\"\"\"\n\n        return len(self._animations) &gt; 0\n\n    def step(self, elapsed: float) -&gt; None:\n\"\"\"Steps the animation forward by the given elapsed time.\"\"\"\n\n        for animation in self._animations.copy():\n            if animation.step(elapsed):\n                self._animations.remove(animation)\n                animation.finish()\n\n    def schedule(self, animation: Animation) -&gt; None:\n\"\"\"Starts an animation on the next step.\"\"\"\n\n        self._animations.append(animation)\n\n    def animate_attr(self, **animation_args: Any) -&gt; AttrAnimation:\n\"\"\"Creates and schedules an AttrAnimation.\n\n        All arguments are passed to the `AttrAnimation` constructor. `direction`, if\n        given as an integer, will be converted to a `Direction` before being passed.\n\n        Returns:\n            The created animation.\n        \"\"\"\n\n        if \"direction\" in animation_args:\n            animation_args[\"direction\"] = Direction(animation_args[\"direction\"])\n\n        anim = AttrAnimation(**animation_args)\n        self.schedule(anim)\n\n        return anim\n\n    def animate_float(self, **animation_args: Any) -&gt; FloatAnimation:\n\"\"\"Creates and schedules an Animation.\n\n        All arguments are passed to the `Animation` constructor. `direction`, if\n        given as an integer, will be converted to a `Direction` before being passed.\n\n        Returns:\n            The created animation.\n        \"\"\"\n\n        if \"direction\" in animation_args:\n            animation_args[\"direction\"] = Direction(animation_args[\"direction\"])\n\n        anim = FloatAnimation(**animation_args)\n        self.schedule(anim)\n\n        return anim\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.is_active","title":"<code>is_active: bool</code>  <code>property</code>","text":"<p>Determines whether there are any active animations.</p>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Returns whether the item is inside _animations.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def __contains__(self, item: object) -&gt; bool:\n\"\"\"Returns whether the item is inside _animations.\"\"\"\n\n    return item in self._animations\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.__init__","title":"<code>__init__()</code>","text":"<p>Initializes an animator.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initializes an animator.\"\"\"\n\n    self._animations: list[Animation] = []\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.animate_attr","title":"<code>animate_attr(**animation_args)</code>","text":"<p>Creates and schedules an AttrAnimation.</p> <p>All arguments are passed to the <code>AttrAnimation</code> constructor. <code>direction</code>, if given as an integer, will be converted to a <code>Direction</code> before being passed.</p> <p>Returns:</p> Type Description <code>AttrAnimation</code> <p>The created animation.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def animate_attr(self, **animation_args: Any) -&gt; AttrAnimation:\n\"\"\"Creates and schedules an AttrAnimation.\n\n    All arguments are passed to the `AttrAnimation` constructor. `direction`, if\n    given as an integer, will be converted to a `Direction` before being passed.\n\n    Returns:\n        The created animation.\n    \"\"\"\n\n    if \"direction\" in animation_args:\n        animation_args[\"direction\"] = Direction(animation_args[\"direction\"])\n\n    anim = AttrAnimation(**animation_args)\n    self.schedule(anim)\n\n    return anim\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.animate_float","title":"<code>animate_float(**animation_args)</code>","text":"<p>Creates and schedules an Animation.</p> <p>All arguments are passed to the <code>Animation</code> constructor. <code>direction</code>, if given as an integer, will be converted to a <code>Direction</code> before being passed.</p> <p>Returns:</p> Type Description <code>FloatAnimation</code> <p>The created animation.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def animate_float(self, **animation_args: Any) -&gt; FloatAnimation:\n\"\"\"Creates and schedules an Animation.\n\n    All arguments are passed to the `Animation` constructor. `direction`, if\n    given as an integer, will be converted to a `Direction` before being passed.\n\n    Returns:\n        The created animation.\n    \"\"\"\n\n    if \"direction\" in animation_args:\n        animation_args[\"direction\"] = Direction(animation_args[\"direction\"])\n\n    anim = FloatAnimation(**animation_args)\n    self.schedule(anim)\n\n    return anim\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.schedule","title":"<code>schedule(animation)</code>","text":"<p>Starts an animation on the next step.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def schedule(self, animation: Animation) -&gt; None:\n\"\"\"Starts an animation on the next step.\"\"\"\n\n    self._animations.append(animation)\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Animator.step","title":"<code>step(elapsed)</code>","text":"<p>Steps the animation forward by the given elapsed time.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def step(self, elapsed: float) -&gt; None:\n\"\"\"Steps the animation forward by the given elapsed time.\"\"\"\n\n    for animation in self._animations.copy():\n        if animation.step(elapsed):\n            self._animations.remove(animation)\n            animation.finish()\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.AttrAnimation","title":"<code>AttrAnimation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Animation</code></p> <p>Animates an attribute going from one value to another.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>@dataclass\nclass AttrAnimation(Animation):\n\"\"\"Animates an attribute going from one value to another.\"\"\"\n\n    target: object = None\n    attr: str = \"\"\n    value_type: type = int\n    end: int | float = 0\n    start: int | float | None = None\n\n    on_step: Callable[[Animation], bool] | None = None\n    on_finish: Callable[[Animation], None] | None = None\n\n    direction: Direction = Direction.FORWARD\n    loop: bool = False\n\n    state: float = field(init=False)\n    _remaining: int = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n\n        if self.start is None:\n            self.start = getattr(self.target, self.attr)\n\n        if self.end &lt; self.start:\n            self.start, self.end = self.end, self.start\n            self.direction = Direction.BACKWARD\n\n        self.end -= self.start\n\n        _add_flag(self.target, self.attr)\n\n    def step(self, elapsed: float) -&gt; bool:\n\"\"\"Steps forward in the attribute animation.\"\"\"\n\n        state_finished = self._update_state(elapsed)\n\n        step_finished = False\n\n        assert self.start is not None\n\n        updated = self.start + (self.end * self.state)\n        setattr(self.target, self.attr, self.value_type(updated))\n\n        if self.on_step is not None:\n            step_finished = self.on_step(self)\n\n        if step_finished or state_finished:\n            return True\n\n        return False\n\n    def finish(self) -&gt; None:\n\"\"\"Deletes `__ptg_animated__` flag, calls `on_finish`.\"\"\"\n\n        _remove_flag(self.target, self.attr)\n        super().finish()\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.AttrAnimation.finish","title":"<code>finish()</code>","text":"<p>Deletes <code>__ptg_animated__</code> flag, calls <code>on_finish</code>.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def finish(self) -&gt; None:\n\"\"\"Deletes `__ptg_animated__` flag, calls `on_finish`.\"\"\"\n\n    _remove_flag(self.target, self.attr)\n    super().finish()\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.AttrAnimation.step","title":"<code>step(elapsed)</code>","text":"<p>Steps forward in the attribute animation.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def step(self, elapsed: float) -&gt; bool:\n\"\"\"Steps forward in the attribute animation.\"\"\"\n\n    state_finished = self._update_state(elapsed)\n\n    step_finished = False\n\n    assert self.start is not None\n\n    updated = self.start + (self.end * self.state)\n    setattr(self.target, self.attr, self.value_type(updated))\n\n    if self.on_step is not None:\n        step_finished = self.on_step(self)\n\n    if step_finished or state_finished:\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.Direction","title":"<code>Direction</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Animation directions.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>class Direction(Enum):\n\"\"\"Animation directions.\"\"\"\n\n    FORWARD = 1\n    BACKWARD = -1\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.FloatAnimation","title":"<code>FloatAnimation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Animation</code></p> <p>Transitions a floating point number from 0.0 to 1.0.</p> <p>Note that this is just a wrapper over the base class, and provides no extra functionality.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>@dataclass\nclass FloatAnimation(Animation):\n\"\"\"Transitions a floating point number from 0.0 to 1.0.\n\n    Note that this is just a wrapper over the base class, and provides no extra\n    functionality.\n    \"\"\"\n\n    duration: int\n\n    on_step: Callable[[Animation], bool] | None = None\n    on_finish: Callable[[Animation], None] | None = None\n\n    direction: Direction = Direction.FORWARD\n    loop: bool = False\n\n    state: float = field(init=False)\n    _remaining: int = field(init=False)\n</code></pre>"},{"location":"reference/pytermgui/animations/#pytermgui.animations.is_animated","title":"<code>is_animated(target, attribute)</code>","text":"<p>Determines whether the given object.attribute is animated.</p> <p>This looks for <code>__ptg_animated__</code>, and whether it contains the given attribute.</p> Source code in <code>pytermgui/animations.py</code> <pre><code>def is_animated(target: object, attribute: str) -&gt; bool:\n\"\"\"Determines whether the given object.attribute is animated.\n\n    This looks for `__ptg_animated__`, and whether it contains the given attribute.\n    \"\"\"\n\n    if not hasattr(target, \"__ptg_animated__\"):\n        return False\n\n    animated = getattr(target, \"__ptg_animated__\")\n\n    return attribute in animated\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/","title":"ansi_interface","text":"<p>Various functions to interface with the terminal, using ANSI sequences.</p> <p>Credits:</p> <ul> <li>https://wiki.bash-hackers.org/scripting/terminalcodes</li> <li>https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797</li> </ul>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction","title":"<code>MouseAction</code>","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration of all the polled mouse actions</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>class MouseAction(Enum):\n\"\"\"An enumeration of all the polled mouse actions\"\"\"\n\n    LEFT_CLICK = \"left_click\"\n\"\"\"Start of a left button action sequence.\"\"\"\n\n    LEFT_DRAG = \"left_drag\"\n\"\"\"Mouse moved while left button was held down.\"\"\"\n\n    RIGHT_CLICK = \"right_click\"\n\"\"\"Start of a right button action sequence.\"\"\"\n\n    RIGHT_DRAG = \"right_drag\"\n\"\"\"Mouse moved while right button was held down.\"\"\"\n\n    SCROLL_UP = \"scroll_up\"\n\"\"\"Mouse wheel or touchpad scroll upwards.\"\"\"\n\n    SCROLL_DOWN = \"scroll_down\"\n\"\"\"Mouse wheel or touchpad scroll downwards.\"\"\"\n\n    SHIFT_SCROLL_UP = \"shift_scroll_up\"\n\"\"\"Mouse wheel or touchpad scroll upwards.\"\"\"\n\n    SHIFT_SCROLL_DOWN = \"shift_scroll_down\"\n\"\"\"Mouse wheel or touchpad scroll downwards.\"\"\"\n\n    HOVER = \"hover\"\n\"\"\"Mouse moved without clicking.\"\"\"\n\n    # TODO: Support left &amp; right mouse release separately, without breaking\n    #       current API.\n    RELEASE = \"release\"\n\"\"\"Mouse button released; end of any and all mouse action sequences.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.HOVER","title":"<code>HOVER = 'hover'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mouse moved without clicking.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.LEFT_CLICK","title":"<code>LEFT_CLICK = 'left_click'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Start of a left button action sequence.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.LEFT_DRAG","title":"<code>LEFT_DRAG = 'left_drag'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mouse moved while left button was held down.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.RELEASE","title":"<code>RELEASE = 'release'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mouse button released; end of any and all mouse action sequences.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.RIGHT_CLICK","title":"<code>RIGHT_CLICK = 'right_click'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Start of a right button action sequence.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.RIGHT_DRAG","title":"<code>RIGHT_DRAG = 'right_drag'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mouse moved while right button was held down.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.SCROLL_DOWN","title":"<code>SCROLL_DOWN = 'scroll_down'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mouse wheel or touchpad scroll downwards.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.SCROLL_UP","title":"<code>SCROLL_UP = 'scroll_up'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mouse wheel or touchpad scroll upwards.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.SHIFT_SCROLL_DOWN","title":"<code>SHIFT_SCROLL_DOWN = 'shift_scroll_down'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mouse wheel or touchpad scroll downwards.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseAction.SHIFT_SCROLL_UP","title":"<code>SHIFT_SCROLL_UP = 'shift_scroll_up'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mouse wheel or touchpad scroll upwards.</p>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent","title":"<code>MouseEvent</code>  <code>dataclass</code>","text":"<p>A class to represent events created by mouse actions.</p> <p>Its first argument is a <code>MouseAction</code> describing what happened, and its second argument is a <code>tuple[int, int]</code> describing where it happened.</p> <p>This class mostly exists for readability &amp; typing reasons. It also implements the iterable protocol, so you can use the unpacking syntax, such as:</p> <pre><code>action, position = MouseEvent(...)\n</code></pre> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>@dataclass\nclass MouseEvent:\n\"\"\"A class to represent events created by mouse actions.\n\n    Its first argument is a `MouseAction` describing what happened,\n    and its second argument is a `tuple[int, int]` describing where\n    it happened.\n\n    This class mostly exists for readability &amp; typing reasons. It also\n    implements the iterable protocol, so you can use the unpacking syntax,\n    such as:\n\n    ```python3\n    action, position = MouseEvent(...)\n    ```\n    \"\"\"\n\n    action: MouseAction\n    position: tuple[int, int]\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Initialize iteration counter\"\"\"\n\n        self._iter_index = 0\n\n    def __next__(self) -&gt; MouseAction | tuple[int, int]:\n\"\"\"Get next iteration item\"\"\"\n\n        data = fields(self)\n\n        if self._iter_index &gt;= len(data):\n            self._iter_index = 0\n            raise StopIteration\n\n        self._iter_index += 1\n        return getattr(self, data[self._iter_index - 1].name)\n\n    def __iter__(self) -&gt; MouseEvent:\n\"\"\"Start iteration\"\"\"\n\n        return self\n\n    def is_scroll(self) -&gt; bool:\n\"\"\"Returns True if event.action is one of the scrolling actions.\"\"\"\n\n        return self.action in {MouseAction.SCROLL_DOWN, MouseAction.SCROLL_UP}\n\n    def is_primary(self) -&gt; bool:\n\"\"\"Returns True if event.action is one of the primary (left-button) actions.\"\"\"\n\n        return self.action in {MouseAction.LEFT_CLICK, MouseAction.LEFT_DRAG}\n\n    def is_secondary(self) -&gt; bool:\n\"\"\"Returns True if event.action is one of the secondary (secondary-button) actions.\"\"\"\n\n        return self.action in {MouseAction.RIGHT_CLICK, MouseAction.RIGHT_DRAG}\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.__iter__","title":"<code>__iter__()</code>","text":"<p>Start iteration</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def __iter__(self) -&gt; MouseEvent:\n\"\"\"Start iteration\"\"\"\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.__next__","title":"<code>__next__()</code>","text":"<p>Get next iteration item</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def __next__(self) -&gt; MouseAction | tuple[int, int]:\n\"\"\"Get next iteration item\"\"\"\n\n    data = fields(self)\n\n    if self._iter_index &gt;= len(data):\n        self._iter_index = 0\n        raise StopIteration\n\n    self._iter_index += 1\n    return getattr(self, data[self._iter_index - 1].name)\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize iteration counter</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Initialize iteration counter\"\"\"\n\n    self._iter_index = 0\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.is_primary","title":"<code>is_primary()</code>","text":"<p>Returns True if event.action is one of the primary (left-button) actions.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def is_primary(self) -&gt; bool:\n\"\"\"Returns True if event.action is one of the primary (left-button) actions.\"\"\"\n\n    return self.action in {MouseAction.LEFT_CLICK, MouseAction.LEFT_DRAG}\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.is_scroll","title":"<code>is_scroll()</code>","text":"<p>Returns True if event.action is one of the scrolling actions.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def is_scroll(self) -&gt; bool:\n\"\"\"Returns True if event.action is one of the scrolling actions.\"\"\"\n\n    return self.action in {MouseAction.SCROLL_DOWN, MouseAction.SCROLL_UP}\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.MouseEvent.is_secondary","title":"<code>is_secondary()</code>","text":"<p>Returns True if event.action is one of the secondary (secondary-button) actions.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def is_secondary(self) -&gt; bool:\n\"\"\"Returns True if event.action is one of the secondary (secondary-button) actions.\"\"\"\n\n    return self.action in {MouseAction.RIGHT_CLICK, MouseAction.RIGHT_DRAG}\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.blink","title":"<code>blink(text, reset_style=True)</code>","text":"<p>Returns text blinking.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def blink(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Returns text blinking.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n    \"\"\"\n\n    return set_mode(\"blink\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.bold","title":"<code>bold(text, reset_style=True)</code>","text":"<p>Returns text in bold.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def bold(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Returns text in bold.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n    \"\"\"\n\n    return set_mode(\"bold\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.clear","title":"<code>clear(what='screen')</code>","text":"<p>Clears the specified screen region.</p> <p>Parameters:</p> Name Type Description Default <code>what</code> <code>str</code> <p>The specifier defining the screen area.</p> <code>'screen'</code> <p>Available options: * screen: clear whole screen and go to origin * bos: clear screen from cursor backwards * eos: clear screen from cursor forwards * line: clear line and go to beginning * bol: clear line from cursor backwards * eol: clear line from cursor forwards</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def clear(what: str = \"screen\") -&gt; None:\n\"\"\"Clears the specified screen region.\n\n    Args:\n        what: The specifier defining the screen area.\n\n    Available options:\n    * screen: clear whole screen and go to origin\n    * bos: clear screen from cursor backwards\n    * eos: clear screen from cursor forwards\n    * line: clear line and go to beginning\n    * bol: clear line from cursor backwards\n    * eol: clear line from cursor forwards\n    \"\"\"\n\n    commands = {\n        \"eos\": \"\\x1b[0J\",\n        \"bos\": \"\\x1b[1J\",\n        \"screen\": \"\\x1b[2J\",\n        \"eol\": \"\\x1b[0K\",\n        \"bol\": \"\\x1b[1K\",\n        \"line\": \"\\x1b[2K\",\n    }\n\n    get_terminal().write(commands[what])\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_column","title":"<code>cursor_column(num=0)</code>","text":"<p>Moves the cursor to the <code>num</code>-th character of the current line.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The new cursor position.</p> <code>0</code> Note <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def cursor_column(num: int = 0) -&gt; None:\n\"\"\"Moves the cursor to the `num`-th character of the current line.\n\n    Args:\n        num: The new cursor position.\n\n    Note:\n        This does not flush the terminal for performance reasons. You\n        can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    get_terminal().write(f\"\\x1b[{num}G\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_down","title":"<code>cursor_down(num=1)</code>","text":"<p>Moves the cursor up by <code>num</code> lines.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>How many lines the cursor should move by. Must be positive, to move in the opposite direction use <code>cursor_up</code>.</p> <code>1</code> Note <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def cursor_down(num: int = 1) -&gt; None:\n\"\"\"Moves the cursor up by `num` lines.\n\n    Args:\n        num: How many lines the cursor should move by. Must be positive,\n            to move in the opposite direction use `cursor_up`.\n    Note:\n        This does not flush the terminal for performance reasons. You\n        can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    get_terminal().write(f\"\\x1b[{num}B\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_home","title":"<code>cursor_home()</code>","text":"<p>Moves cursor to <code>get_terminal().origin</code>.</p> Note <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def cursor_home() -&gt; None:\n\"\"\"Moves cursor to `get_terminal().origin`.\n\n    Note:\n        This does not flush the terminal for performance reasons. You\n        can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    get_terminal().write(\"\\x1b[H\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_left","title":"<code>cursor_left(num=1)</code>","text":"<p>Moves the cursor left by <code>num</code> lines.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>How many characters the cursor should move by. Must be positive, to move in the opposite direction use <code>cursor_right</code>.</p> <code>1</code> Note <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def cursor_left(num: int = 1) -&gt; None:\n\"\"\"Moves the cursor left by `num` lines.\n\n    Args:\n        num: How many characters the cursor should move by. Must be positive,\n            to move in the opposite direction use `cursor_right`.\n    Note:\n        This does not flush the terminal for performance reasons. You\n        can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    get_terminal().write(f\"\\x1b[{num}D\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_next_line","title":"<code>cursor_next_line(num=1)</code>","text":"<p>Moves the cursor to the beginning of the <code>num</code>-th line downwards.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The amount the cursor should move by. Must be positive, to move in the opposite direction use <code>cursor_prev_line</code>.</p> <code>1</code> Note <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def cursor_next_line(num: int = 1) -&gt; None:\n\"\"\"Moves the cursor to the beginning of the `num`-th line downwards.\n\n    Args:\n        num: The amount the cursor should move by. Must be positive, to move\n            in the opposite direction use `cursor_prev_line`.\n    Note:\n        This does not flush the terminal for performance reasons. You\n        can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    get_terminal().write(f\"\\x1b[{num}E\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_prev_line","title":"<code>cursor_prev_line(num=1)</code>","text":"<p>Moves the cursor to the beginning of the <code>num</code>-th line upwards.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The amount the cursor should move by. Must be positive, to move in the opposite direction use <code>cursor_next_line</code>.</p> <code>1</code> Note <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def cursor_prev_line(num: int = 1) -&gt; None:\n\"\"\"Moves the cursor to the beginning of the `num`-th line upwards.\n\n    Args:\n        num: The amount the cursor should move by. Must be positive, to move\n            in the opposite direction use `cursor_next_line`.\n    Note:\n        This does not flush the terminal for performance reasons. You\n        can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    get_terminal().write(f\"\\x1b[{num}F\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_right","title":"<code>cursor_right(num=1)</code>","text":"<p>Moves the cursor right by <code>num</code> lines.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>How many characters the cursor should move by. Must be positive, to move in the opposite direction use <code>cursor_left</code>.</p> <code>1</code> Note <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def cursor_right(num: int = 1) -&gt; None:\n\"\"\"Moves the cursor right by `num` lines.\n\n    Args:\n        num: How many characters the cursor should move by. Must be positive,\n            to move in the opposite direction use `cursor_left`.\n    Note:\n        This does not flush the terminal for performance reasons. You\n        can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    get_terminal().write(f\"\\x1b[{num}C\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.cursor_up","title":"<code>cursor_up(num=1)</code>","text":"<p>Moves the cursor up by <code>num</code> lines.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>How many lines the cursor should move by. Must be positive, to move in the opposite direction use <code>cursor_down</code>.</p> <code>1</code> Note <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def cursor_up(num: int = 1) -&gt; None:\n\"\"\"Moves the cursor up by `num` lines.\n\n    Args:\n        num: How many lines the cursor should move by. Must be positive,\n            to move in the opposite direction use `cursor_down`.\n    Note:\n        This does not flush the terminal for performance reasons. You\n        can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    get_terminal().write(f\"\\x1b[{num}A\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.dim","title":"<code>dim(text, reset_style=True)</code>","text":"<p>Returns text in dim.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def dim(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Returns text in dim.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n    \"\"\"\n\n    return set_mode(\"dim\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.hide_cursor","title":"<code>hide_cursor()</code>","text":"<p>Stops printing the cursor.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def hide_cursor() -&gt; None:\n\"\"\"Stops printing the cursor.\"\"\"\n\n    get_terminal().write(\"\\x1b[?25l\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.inverse","title":"<code>inverse(text, reset_style=True)</code>","text":"<p>Returns text inverse-colored.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def inverse(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Returns text inverse-colored.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n    \"\"\"\n\n    return set_mode(\"inverse\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.invisible","title":"<code>invisible(text, reset_style=True)</code>","text":"<p>Returns text as invisible.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Note <p>This isn't very widely supported.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def invisible(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Returns text as invisible.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n\n    Note:\n        This isn't very widely supported.\n    \"\"\"\n\n    return set_mode(\"invisible\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.italic","title":"<code>italic(text, reset_style=True)</code>","text":"<p>Returns text in italic.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def italic(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Returns text in italic.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n    \"\"\"\n\n    return set_mode(\"italic\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.move_cursor","title":"<code>move_cursor(pos)</code>","text":"<p>Moves the cursor.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>Tuple of that the cursor will be moved to.</p> required <p>This does not flush the terminal for performance reasons. You can do it manually with <code>sys.stdout.flush()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def move_cursor(pos: tuple[int, int]) -&gt; None:\n\"\"\"Moves the cursor.\n\n    Args:\n        pos: Tuple of that the cursor will be moved to.\n\n    This does not flush the terminal for performance reasons. You\n    can do it manually with `sys.stdout.flush()`.\n    \"\"\"\n\n    posx, posy = pos\n    get_terminal().write(f\"\\x1b[{posy};{posx}H\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.overline","title":"<code>overline(text, reset_style=True)</code>","text":"<p>Return text overlined.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Note <p>This isnt' very widely supported.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def overline(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Return text overlined.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n\n    Note:\n        This isnt' very widely supported.\n    \"\"\"\n\n    return set_mode(\"overline\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.print_to","title":"<code>print_to(pos, *args, **kwargs)</code>","text":"<p>Prints text to given <code>pos</code>.</p> Note <p>This method passes through all arguments (except for <code>pos</code>) to the <code>print</code> method.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def print_to(pos: tuple[int, int], *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Prints text to given `pos`.\n\n    Note:\n        This method passes through all arguments (except for `pos`) to the `print`\n        method.\n    \"\"\"\n\n    move_cursor(pos)\n    print(*args, **kwargs)\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.report_cursor","title":"<code>report_cursor()</code>","text":"<p>Gets position of cursor.</p> <p>Returns:</p> Type Description <code>'Optional[tuple[int, int]]'</code> <p>A tuple of integers, (columns, rows), describing the</p> <code>'Optional[tuple[int, int]]'</code> <p>current (printing) cursor's position. Returns None if</p> <code>'Optional[tuple[int, int]]'</code> <p>this could not be determined.</p> <code>'Optional[tuple[int, int]]'</code> <p>Note that this position is not the mouse position. See</p> <code>'Optional[tuple[int, int]]'</code> <p><code>report_mouse</code> if that is what you are interested in.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def report_cursor() -&gt; \"Optional[tuple[int, int]]\":\n\"\"\"Gets position of cursor.\n\n    Returns:\n        A tuple of integers, (columns, rows), describing the\n        current (printing) cursor's position. Returns None if\n        this could not be determined.\n\n        Note that this position is **not** the mouse position. See\n        `report_mouse` if that is what you are interested in.\n    \"\"\"\n\n    get_terminal().write(\"\\x1b[6n\", flush=True)\n    chars = getch()\n    posy, posx = chars[2:-1].split(\";\")\n\n    if not posx.isdigit() or not posy.isdigit():\n        return None\n\n    return int(posx), int(posy)\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.report_mouse","title":"<code>report_mouse(event, method='decimal_xterm', stop=False)</code>","text":"<p>Starts reporting of mouse events.</p> <p>You can specify multiple events to report on.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The type of event to report on. See below for options.</p> required <code>method</code> <code>Optional[str]</code> <p>The method of reporting to use. See below for options.</p> <code>'decimal_xterm'</code> <code>stop</code> <code>bool</code> <p>If set to True, the stopping code is written to stdout.</p> <code>False</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>The given event is not supported.</p> Note <p>If you need this functionality, you're probably better off using the wrapper <code>pytermgui.context_managers.mouse_handler</code>, which allows listening on multiple events, gives a translator method and handles exceptions.</p> Possible events <ul> <li>press: Report when the mouse is clicked, left or right button.</li> <li>highlight: Report highlighting.</li> <li>press_hold: Report with a left or right click, as well as both     left &amp; right drag and release.</li> <li>all: Report every event, even hover.</li> </ul> Methods <ul> <li>None: Non-decimal xterm method. Limited in coordinates.</li> <li>decimal_xterm: The default setting. Most universally supported.</li> <li>decimal_urxvt: Older, less compatible, but useful on some systems.</li> <li>decimal_utf8:  Apparently not too stable.</li> </ul> <p>More information here.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def report_mouse(\n    event: str, method: Optional[str] = \"decimal_xterm\", stop: bool = False\n) -&gt; None:\n\"\"\"Starts reporting of mouse events.\n\n    You can specify multiple events to report on.\n\n    Args:\n        event: The type of event to report on. See below for options.\n        method: The method of reporting to use. See below for options.\n        stop: If set to True, the stopping code is written to stdout.\n\n    Raises:\n        NotImplementedError: The given event is not supported.\n\n    Note:\n        If you need this functionality, you're probably better off using the wrapper\n        `pytermgui.context_managers.mouse_handler`, which allows listening on multiple\n        events, gives a translator method and handles exceptions.\n\n    Possible events:\n        - **press**: Report when the mouse is clicked, left or right button.\n        - **highlight**: Report highlighting.\n        - **press_hold**: Report with a left or right click, as well as both\n            left &amp; right drag and release.\n        - **all**: Report every event, even hover.\n\n    Methods:\n        - **None**: Non-decimal xterm method. Limited in coordinates.\n        - **decimal_xterm**: The default setting. Most universally supported.\n        - **decimal_urxvt**: Older, less compatible, but useful on some systems.\n        - **decimal_utf8**:  Apparently not too stable.\n\n    More information &lt;a href='https://stackoverflow.com/a/5970472'&gt;here&lt;/a&gt;.\n    \"\"\"\n\n    terminal = get_terminal()\n\n    if event == \"press\":\n        terminal.write(\"\\x1b[?1000\")\n\n    elif event == \"highlight\":\n        terminal.write(\"\\x1b[?1001\")\n\n    elif event == \"press_hold\":\n        terminal.write(\"\\x1b[?1002\")\n\n    elif event == \"all\":\n        terminal.write(\"\\x1b[?1003\")\n\n    else:\n        raise NotImplementedError(f\"Mouse report event {event!r} is not supported!\")\n\n    terminal.write(\"l\" if stop else \"h\")\n\n    if method == \"decimal_utf8\":\n        terminal.write(\"\\x1b[?1005\")\n\n    elif method == \"decimal_xterm\":\n        terminal.write(\"\\x1b[?1006\")\n\n    elif method == \"decimal_urxvt\":\n        terminal.write(\"\\x1b[?1015\")\n\n    elif method is None:\n        return\n\n    else:\n        raise NotImplementedError(f\"Mouse report method {method} is not supported!\")\n\n    terminal.write(\"l\" if stop else \"h\", flush=True)\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.reset","title":"<code>reset()</code>","text":"<p>Resets printing mode.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def reset() -&gt; str:\n\"\"\"Resets printing mode.\"\"\"\n\n    return set_mode(\"reset\", False)\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.restore_cursor","title":"<code>restore_cursor()</code>","text":"<p>Restore cursor position as saved by <code>save_cursor</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def restore_cursor() -&gt; None:\n\"\"\"Restore cursor position as saved by `save_cursor`.\"\"\"\n\n    get_terminal().write(\"\\x1b[u\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.restore_screen","title":"<code>restore_screen()</code>","text":"<p>Restores the contents of the screen saved by <code>save_screen()</code>.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def restore_screen() -&gt; None:\n\"\"\"Restores the contents of the screen saved by `save_screen()`.\"\"\"\n\n    print(\"\\x1b[?47l\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.save_cursor","title":"<code>save_cursor()</code>","text":"<p>Saves the current cursor position.</p> <p>Use <code>restore_cursor</code> to restore it.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def save_cursor() -&gt; None:\n\"\"\"Saves the current cursor position.\n\n    Use `restore_cursor` to restore it.\n    \"\"\"\n\n    get_terminal().write(\"\\x1b[s\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.save_screen","title":"<code>save_screen()</code>","text":"<p>Saves the contents of the screen, and wipes it.</p> <p>Use <code>restore_screen()</code> to get them back.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def save_screen() -&gt; None:\n\"\"\"Saves the contents of the screen, and wipes it.\n\n    Use `restore_screen()` to get them back.\n    \"\"\"\n\n    print(\"\\x1b[?47h\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.set_alt_buffer","title":"<code>set_alt_buffer()</code>","text":"<p>Starts an alternate buffer.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def set_alt_buffer() -&gt; None:\n\"\"\"Starts an alternate buffer.\"\"\"\n\n    print(\"\\x1b[?1049h\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.set_echo","title":"<code>set_echo()</code>","text":"<p>Starts echoing of user input.</p> Note <p>This is currently only available on POSIX.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def set_echo() -&gt; None:\n\"\"\"Starts echoing of user input.\n\n    Note:\n        This is currently only available on POSIX.\n    \"\"\"\n\n    if not _name == \"posix\":\n        return\n\n    system(\"stty echo\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.set_mode","title":"<code>set_mode(mode, write=True)</code>","text":"<p>Sets terminal display mode.</p> <p>This is better left internal. To use these modes, you can call their specific functions, such as <code>bold(\"text\")</code> or <code>italic(\"text\")</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Union[str, int]</code> <p>One of the available modes. Strings and integers both work.</p> required <code>write</code> <code>bool</code> <p>Boolean that determines whether the output should be written to stdout.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>A string that sets the given mode.</p> Available modes <ul> <li>0: reset</li> <li>1: bold</li> <li>2: dim</li> <li>3: italic</li> <li>4: underline</li> <li>5: blink</li> <li>7: inverse</li> <li>8: invisible</li> <li>9: strikethrough</li> <li>53: overline</li> </ul> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def set_mode(mode: Union[str, int], write: bool = True) -&gt; str:\n\"\"\"Sets terminal display mode.\n\n    This is better left internal. To use these modes, you can call their\n    specific functions, such as `bold(\"text\")` or `italic(\"text\")`.\n\n    Args:\n        mode: One of the available modes. Strings and integers both work.\n        write: Boolean that determines whether the output should be written\n            to stdout.\n\n    Returns:\n        A string that sets the given mode.\n\n    Available modes:\n        - 0: reset\n        - 1: bold\n        - 2: dim\n        - 3: italic\n        - 4: underline\n        - 5: blink\n        - 7: inverse\n        - 8: invisible\n        - 9: strikethrough\n        - 53: overline\n    \"\"\"\n\n    options = {\n        \"reset\": 0,\n        \"bold\": 1,\n        \"dim\": 2,\n        \"italic\": 3,\n        \"underline\": 4,\n        \"blink\": 5,\n        \"inverse\": 7,\n        \"invisible\": 8,\n        \"strikethrough\": 9,\n        \"overline\": 53,\n    }\n\n    if not str(mode).isdigit():\n        mode = options[str(mode)]\n\n    code = f\"\\x1b[{mode}m\"\n    if write:\n        get_terminal().write(code)\n\n    return code\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.show_cursor","title":"<code>show_cursor()</code>","text":"<p>Starts printing the cursor.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def show_cursor() -&gt; None:\n\"\"\"Starts printing the cursor.\"\"\"\n\n    get_terminal().write(\"\\x1b[?25h\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.strikethrough","title":"<code>strikethrough(text, reset_style=True)</code>","text":"<p>Return text as strikethrough.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def strikethrough(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Return text as strikethrough.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n    \"\"\"\n\n    return set_mode(\"strikethrough\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.translate_mouse","title":"<code>translate_mouse(code, method)</code>","text":"<p>Translates the output of produced by setting <code>report_mouse</code> into MouseEvents.</p> <p>This method currently only supports <code>decimal_xterm</code> and <code>decimal_urxvt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The string of mouse code(s) to translate.</p> required <code>method</code> <code>str</code> <p>The reporting method to translate. One of <code>decimal_xterm</code>, <code>decimal_urxvt</code>.</p> required <p>Returns:</p> Type Description <code>list[MouseEvent | None] | None</code> <p>A list of optional mouse events obtained from the code argument. If the code was malformed,</p> <code>list[MouseEvent | None] | None</code> <p>and no codes could be determined None is returned.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def translate_mouse(code: str, method: str) -&gt; list[MouseEvent | None] | None:\n\"\"\"Translates the output of produced by setting `report_mouse` into MouseEvents.\n\n    This method currently only supports `decimal_xterm` and `decimal_urxvt`.\n\n    Args:\n        code: The string of mouse code(s) to translate.\n        method: The reporting method to translate. One of `decimal_xterm`, `decimal_urxvt`.\n\n    Returns:\n        A list of optional mouse events obtained from the code argument. If the code was malformed,\n        and no codes could be determined None is returned.\n    \"\"\"\n\n    if code == \"\\x1b\":\n        return None\n\n    mouse_codes = {\n        \"decimal_xterm\": {\n            \"0M\": MouseAction.LEFT_CLICK,\n            \"0m\": MouseAction.RELEASE,\n            \"2M\": MouseAction.RIGHT_CLICK,\n            \"2m\": MouseAction.RELEASE,\n            \"32\": MouseAction.LEFT_DRAG,\n            \"34\": MouseAction.RIGHT_DRAG,\n            \"35\": MouseAction.HOVER,\n            \"64\": MouseAction.SCROLL_UP,\n            \"65\": MouseAction.SCROLL_DOWN,\n            \"68\": MouseAction.SHIFT_SCROLL_UP,\n            \"69\": MouseAction.SHIFT_SCROLL_DOWN,\n        },\n        \"decimal_urxvt\": {\n            \"32\": MouseAction.LEFT_CLICK,\n            \"34\": MouseAction.RIGHT_CLICK,\n            \"35\": MouseAction.RELEASE,\n            \"64\": MouseAction.LEFT_DRAG,\n            \"66\": MouseAction.RIGHT_DRAG,\n            \"96\": MouseAction.SCROLL_UP,\n            \"97\": MouseAction.SCROLL_DOWN,\n        },\n    }\n\n    mapping = mouse_codes[method]\n    pattern: Pattern = RE_MOUSE[method]\n\n    events: list[MouseEvent | None] = []\n\n    for sequence in code.split(\"\\x1b\"):\n        if len(sequence) == 0:\n            continue\n\n        matches = list(pattern.finditer(sequence))\n        if len(matches) == 0:\n            return None\n\n        for match in matches:\n            identifier, *pos, release_code = match.groups()\n\n            # decimal_xterm uses the last character's\n            # capitalization to signify press/release state\n            if len(release_code) &gt; 0 and identifier in [\"0\", \"2\"]:\n                identifier += release_code\n\n            if identifier in mapping:\n                action = mapping[identifier]\n                assert isinstance(action, MouseAction)\n\n                events.append(MouseEvent(action, (int(pos[0]), int(pos[1]))))\n                continue\n\n            events.append(None)\n\n    return events\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.underline","title":"<code>underline(text, reset_style=True)</code>","text":"<p>Returns text underlined.</p> <p>Parameters:</p> Name Type Description Default <code>reset_style</code> <code>Optional[bool]</code> <p>Boolean that determines whether a reset character should be appended to the end of the string.</p> <code>True</code> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def underline(text: str, reset_style: Optional[bool] = True) -&gt; str:\n\"\"\"Returns text underlined.\n\n    Args:\n        reset_style: Boolean that determines whether a reset character should\n            be appended to the end of the string.\n    \"\"\"\n\n    return set_mode(\"underline\", False) + text + (reset() if reset_style else \"\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.unset_alt_buffer","title":"<code>unset_alt_buffer()</code>","text":"<p>Returns to main buffer, restoring its original state.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def unset_alt_buffer() -&gt; None:\n\"\"\"Returns to main buffer, restoring its original state.\"\"\"\n\n    print(\"\\x1b[?1049l\")\n</code></pre>"},{"location":"reference/pytermgui/ansi_interface/#pytermgui.ansi_interface.unset_echo","title":"<code>unset_echo()</code>","text":"<p>Stops echoing of user input.</p> Note <p>This is currently only available on POSIX.</p> Source code in <code>pytermgui/ansi_interface.py</code> <pre><code>def unset_echo() -&gt; None:\n\"\"\"Stops echoing of user input.\n\n    Note:\n        This is currently only available on POSIX.\n    \"\"\"\n\n    if not _name == \"posix\":\n        return\n\n    system(\"stty -echo\")\n</code></pre>"},{"location":"reference/pytermgui/cell/","title":"cell","text":""},{"location":"reference/pytermgui/cell/#pytermgui.cell.Cell","title":"<code>Cell</code>  <code>dataclass</code>","text":"<p>A unit that represents a single, possibly ANSI-styled character.</p> Source code in <code>pytermgui/cell.py</code> <pre><code>@dataclass\nclass Cell:\n\"\"\"A unit that represents a single, possibly ANSI-styled character.\"\"\"\n\n    char: str = \"\"\n    styles: str = \"\"\n\n    _foreground: str | None = None\n    _background: str | None = None\n\n    def __str__(self) -&gt; str:\n\"\"\"Gets the content of this cell.\"\"\"\n\n        return self.styles + self.char\n\n    @property\n    def foreground(self) -&gt; str | None:\n\"\"\"Returns the currently set foreground color in this cell.\"\"\"\n\n        return self._foreground\n\n    @foreground.setter\n    def foreground(self, new: str | None) -&gt; None:\n\"\"\"Allows setting the foreground color, while unsetting the current one.\"\"\"\n\n        current = self.foreground\n\n        if current is not None:\n            self.styles = self.styles.replace(current, \"\")\n\n        self.styles += new\n\n        if new is not None:\n            self._foreground = f\"\\x1b[{new}m\"\n\n        else:\n            self._foreground = None\n\n    @property\n    def background(self) -&gt; str | None:\n\"\"\"Returns the currently set background color in this cell.\"\"\"\n\n        return self._background\n\n    @background.setter\n    def background(self, new: str | None) -&gt; None:\n\"\"\"Allows setting the background color, while unsetting the current one.\"\"\"\n\n        current = self.background\n\n        if current is not None:\n            self.styles = self.styles.replace(current, \"\")\n\n        self.styles += new\n\n        if new is not None:\n            self._background = f\"\\x1b[{new}m\"\n\n        else:\n            self._background = None\n\n    @classmethod\n    def from_line(cls, line: str, styles: str = \"\") -&gt; Generator[None, None, Cell]:\n\"\"\"Yields Cells generated from a line of text.\n\n        Args:\n            line: The input line. May or may not contain ANSI styles.\n            styles: Styles that are applied to the line from before the line started.\n\n        Returns:\n            A Cell generator.\n        \"\"\"\n\n        in_style = False\n        current_style = styles\n        current_styles = []\n\n        for char in line:\n            if char == STYLE_START_CHAR:\n                in_style = True\n                current_style = \"\"\n                continue\n\n            if in_style:\n                if char == \"[\":\n                    continue\n\n                if char == STYLE_END_CHAR:\n                    current_styles.append(current_style)\n                    in_style = False\n                    continue\n\n                current_style += char\n                continue\n\n            current_styles, fore, back = _process_styles(current_styles)\n\n            yield Cell(char or \" \", _combine(current_styles), fore, back)\n\n        if current_style != \"\":\n            current_styles, fore, back = _process_styles(\n                current_styles + [current_style]\n            )\n\n            yield Cell(\"\", _combine(current_styles), fore, back)\n\n    @classmethod\n    def first_of(cls, line: str) -&gt; Cell:\n\"\"\"Returns the first cell yielded by `from_line`.\"\"\"\n\n        for cell in cls.from_line(line):\n            return cell\n</code></pre>"},{"location":"reference/pytermgui/cell/#pytermgui.cell.Cell.background","title":"<code>background: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the currently set background color in this cell.</p>"},{"location":"reference/pytermgui/cell/#pytermgui.cell.Cell.foreground","title":"<code>foreground: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the currently set foreground color in this cell.</p>"},{"location":"reference/pytermgui/cell/#pytermgui.cell.Cell.__str__","title":"<code>__str__()</code>","text":"<p>Gets the content of this cell.</p> Source code in <code>pytermgui/cell.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Gets the content of this cell.\"\"\"\n\n    return self.styles + self.char\n</code></pre>"},{"location":"reference/pytermgui/cell/#pytermgui.cell.Cell.first_of","title":"<code>first_of(line)</code>  <code>classmethod</code>","text":"<p>Returns the first cell yielded by <code>from_line</code>.</p> Source code in <code>pytermgui/cell.py</code> <pre><code>@classmethod\ndef first_of(cls, line: str) -&gt; Cell:\n\"\"\"Returns the first cell yielded by `from_line`.\"\"\"\n\n    for cell in cls.from_line(line):\n        return cell\n</code></pre>"},{"location":"reference/pytermgui/cell/#pytermgui.cell.Cell.from_line","title":"<code>from_line(line, styles='')</code>  <code>classmethod</code>","text":"<p>Yields Cells generated from a line of text.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The input line. May or may not contain ANSI styles.</p> required <code>styles</code> <code>str</code> <p>Styles that are applied to the line from before the line started.</p> <code>''</code> <p>Returns:</p> Type Description <code>Generator[None, None, Cell]</code> <p>A Cell generator.</p> Source code in <code>pytermgui/cell.py</code> <pre><code>@classmethod\ndef from_line(cls, line: str, styles: str = \"\") -&gt; Generator[None, None, Cell]:\n\"\"\"Yields Cells generated from a line of text.\n\n    Args:\n        line: The input line. May or may not contain ANSI styles.\n        styles: Styles that are applied to the line from before the line started.\n\n    Returns:\n        A Cell generator.\n    \"\"\"\n\n    in_style = False\n    current_style = styles\n    current_styles = []\n\n    for char in line:\n        if char == STYLE_START_CHAR:\n            in_style = True\n            current_style = \"\"\n            continue\n\n        if in_style:\n            if char == \"[\":\n                continue\n\n            if char == STYLE_END_CHAR:\n                current_styles.append(current_style)\n                in_style = False\n                continue\n\n            current_style += char\n            continue\n\n        current_styles, fore, back = _process_styles(current_styles)\n\n        yield Cell(char or \" \", _combine(current_styles), fore, back)\n\n    if current_style != \"\":\n        current_styles, fore, back = _process_styles(\n            current_styles + [current_style]\n        )\n\n        yield Cell(\"\", _combine(current_styles), fore, back)\n</code></pre>"},{"location":"reference/pytermgui/cmd/","title":"cmd","text":"<p>The command-line module of the library.</p> <p>See ptg --help for more information.</p>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow","title":"<code>AppWindow</code>","text":"<p>             Bases: <code>ptg.Window</code></p> <p>A generic application window.</p> <p>It contains a header with the app's title, as well as some global settings.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>class AppWindow(ptg.Window):\n\"\"\"A generic application window.\n\n    It contains a header with the app's title, as well as some global\n    settings.\n    \"\"\"\n\n    app_title: str\n\"\"\"The display title of the application.\"\"\"\n\n    app_id: str\n\"\"\"The short identifier used by ArgumentParser.\"\"\"\n\n    standalone: bool\n\"\"\"Whether this app was launched directly from the CLI.\"\"\"\n\n    overflow = ptg.Overflow.SCROLL\n    vertical_align = ptg.VerticalAlignment.TOP\n\n    def __init__(self, args: Namespace | None = None, **attrs: Any) -&gt; None:\n        super().__init__(**attrs)\n\n        self.standalone = bool(getattr(args, self.app_id, None))\n\n        bottom = ptg.Container.chars[\"border\"][-1]\n        header_box = ptg.boxes.Box(\n            [\n                \"\",\n                \" x \",\n                bottom * 3,\n            ]\n        )\n\n        self._add_widget(ptg.Container(f\"[ptg.title]{self.app_title}\", box=header_box))\n        self._add_widget(\"\")\n\n    def setup(self) -&gt; None:\n\"\"\"Centers window, sets its width &amp; height.\"\"\"\n\n        self.width = int(self.terminal.width * 2 / 3)\n        self.height = int(self.terminal.height * 2 / 3)\n        self.center(store=False)\n\n    def on_exit(self) -&gt; None:\n\"\"\"Called on application exit.\n\n        Should be used to print current application state to the user's shell.\n        \"\"\"\n\n        ptg.tim.print(f\"{_title()} - [dim]{self.app_title}\")\n        print()\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.app_id","title":"<code>app_id: str</code>  <code>instance-attribute</code>","text":"<p>The short identifier used by ArgumentParser.</p>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.app_title","title":"<code>app_title: str</code>  <code>instance-attribute</code>","text":"<p>The display title of the application.</p>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.standalone","title":"<code>standalone: bool = bool(getattr(args, self.app_id, None))</code>  <code>instance-attribute</code>","text":"<p>Whether this app was launched directly from the CLI.</p>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.on_exit","title":"<code>on_exit()</code>","text":"<p>Called on application exit.</p> <p>Should be used to print current application state to the user's shell.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>def on_exit(self) -&gt; None:\n\"\"\"Called on application exit.\n\n    Should be used to print current application state to the user's shell.\n    \"\"\"\n\n    ptg.tim.print(f\"{_title()} - [dim]{self.app_title}\")\n    print()\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.AppWindow.setup","title":"<code>setup()</code>","text":"<p>Centers window, sets its width &amp; height.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>def setup(self) -&gt; None:\n\"\"\"Centers window, sets its width &amp; height.\"\"\"\n\n    self.width = int(self.terminal.width * 2 / 3)\n    self.height = int(self.terminal.height * 2 / 3)\n    self.center(store=False)\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.ColorPickerWindow","title":"<code>ColorPickerWindow</code>","text":"<p>             Bases: <code>AppWindow</code></p> <p>A window to pick colors from the xterm-256 palette.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>class ColorPickerWindow(AppWindow):\n\"\"\"A window to pick colors from the xterm-256 palette.\"\"\"\n\n    app_title = \"ColorPicker\"\n    app_id = \"color\"\n\n    def __init__(self, args: Namespace | None = None, **attrs: Any) -&gt; None:\n        super().__init__(args, **attrs)\n\n        self._chosen_rgb = ptg.str_to_color(\"black\")\n\n        self._colorpicker = ptg.ColorPicker()\n        self._add_widget(ptg.FancyReprWidget(ptg.palette, starts_at=2))\n        self._add_widget(ptg.Collapsible(\"xterm-256\", \"\", self._colorpicker))\n        self._add_widget(\"\")\n        self._add_widget(\n            ptg.Collapsible(\"RGB &amp; HEX\", \"\", self._create_rgb_picker(), static_width=81)\n        )\n\n        self.setup()\n\n    def _create_rgb_picker(self) -&gt; ptg.Container:\n\"\"\"Creates the RGB picker 'widget'.\"\"\"\n\n        root = ptg.Container(static_width=72)\n\n        matrix = ptg.DensePixelMatrix(68, 20)\n        hexdisplay = ptg.Label()\n        rgbdisplay = ptg.Label()\n\n        sliders = [ptg.Slider() for _ in range(3)]\n\n        def _get_rgb() -&gt; tuple[int, int, int]:\n\"\"\"Computes the RGB value from the 3 sliders.\"\"\"\n\n            values = [int(255 * slider.value) for slider in sliders]\n\n            return values[0], values[1], values[2]\n\n        def _update(*_) -&gt; None:\n\"\"\"Updates the matrix &amp; displays with the current color.\"\"\"\n\n            color = self._chosen_rgb = ptg.RGBColor.from_rgb(_get_rgb())\n            for row in range(matrix.rows):\n                for col in range(matrix.columns):\n                    matrix[row, col] = color.hex\n\n            hexdisplay.value = f\"[ptg.body]{color.hex}\"\n            rgbdisplay.value = f\"[ptg.body]rgb({', '.join(map(str, color.rgb))})\"\n            matrix.build()\n\n        red, green, blue = sliders\n\n        # red.styles.filled_selected__cursor = \"red\"\n        # green.styles.filled_selected__cursor = \"green\"\n        # blue.styles.filled_selected__cursor = \"blue\"\n\n        for slider in sliders:\n            slider.onchange = _update\n\n        root += hexdisplay\n        root += rgbdisplay\n        root += \"\"\n\n        root += matrix\n        root += \"\"\n\n        root += red\n        root += green\n        root += blue\n\n        _update()\n        return root\n\n    def on_exit(self) -&gt; None:\n        super().on_exit()\n\n        color = self._chosen_rgb\n        eightbit = \" \".join(\n            button.get_lines()[0] for button in self._colorpicker.chosen\n        )\n\n        ptg.tim.print(\"[ptg.title]Your colors:\")\n        ptg.tim.print(f\"    [{color.hex}]{color.rgb}[/] // [{color.hex}]{color.hex}\")\n        ptg.tim.print()\n        ptg.tim.print(f\"    {eightbit}\")\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.GetchWindow","title":"<code>GetchWindow</code>","text":"<p>             Bases: <code>AppWindow</code></p> <p>A window for the Getch utility.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>class GetchWindow(AppWindow):\n\"\"\"A window for the Getch utility.\"\"\"\n\n    app_title = \"Getch\"\n    app_id = \"getch\"\n\n    def __init__(self, args: Namespace | None = None, **attrs: Any) -&gt; None:\n        super().__init__(args, **attrs)\n\n        self.bind(ptg.keys.ANY_KEY, self._update)\n\n        self._content = ptg.Container(\"Press any key...\", static_width=50)\n        self._add_widget(self._content)\n\n        self.setup()\n\n    def _update(self, _: ptg.Widget, key: str) -&gt; None:\n\"\"\"Updates window contents on keypress.\"\"\"\n\n        self._content.set_widgets([])\n        name = _get_key_name(key)\n\n        if name != ascii(key):\n            name = f\"keys.{name}\"\n\n        style = ptg.HighlighterStyle(ptg.highlight_python)\n\n        items = [\n            \"[ptg.title]Your output\",\n            \"\",\n            {\"[ptg.detail]key\": ptg.Label(name, style=style)},\n            {\"[ptg.detail]value:\": ptg.Label(ascii(key), style=style)},\n            {\"[ptg.detail]len()\": ptg.Label(str(len(key)), style=style)},\n            {\n                \"[ptg.detail]real_length()\": ptg.Label(\n                    str(ptg.real_length(key)), style=style\n                )\n            },\n        ]\n\n        for item in items:\n            self._content += item\n\n        if self.standalone:\n            assert self.manager is not None\n            self.manager.stop()\n\n    def on_exit(self) -&gt; None:\n        super().on_exit()\n\n        for line in self._content.get_lines():\n            print(line)\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.InspectorWindow","title":"<code>InspectorWindow</code>","text":"<p>             Bases: <code>AppWindow</code></p> <p>A window for the <code>inspect</code> utility.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>class InspectorWindow(AppWindow):\n\"\"\"A window for the `inspect` utility.\"\"\"\n\n    app_title = \"Inspector\"\n    app_id = \"inspect\"\n\n    def __init__(self, args: Namespace | None = None, **attrs: Any) -&gt; None:\n        super().__init__(args, **attrs)\n\n        self._input = ptg.InputField(value=\"boxes.Box\")\n\n        self._output = ptg.Container(box=\"EMPTY\")\n        self._update()\n\n        self._input.bind(ptg.keys.ENTER, self._update)\n\n        self._add_widget(\n            ptg.Container(\n                self._output,\n                \"\",\n                ptg.Container(self._input),\n                box=\"EMPTY\",\n            )\n        )\n\n        self.setup()\n\n        self.select(0)\n\n    @staticmethod\n    def obj_from_path(path: str) -&gt; object | None:\n\"\"\"Retrieves an object from any valid import path.\n\n        An import path could be something like:\n            pytermgui.window_manager.compositor.Compositor\n\n        ...or if the library in question imports its parts within `__init__.py`-s:\n            pytermgui.Compositor\n        \"\"\"\n\n        parts = path.split(\".\")\n\n        if parts[0] in dir(builtins):\n            obj = getattr(builtins, parts[0])\n\n        elif parts[0] in dir(ptg):\n            obj = getattr(ptg, parts[0])\n\n        else:\n            try:\n                obj = importlib.import_module(\".\".join(parts[:-1]))\n            except (ValueError, ModuleNotFoundError) as error:\n                return (\n                    f\"Could not import object at path {path!r}: {error}.\"\n                    + \" Maybe try using the --eval flag?\"\n                )\n\n        try:\n            obj = getattr(obj, parts[-1])\n        except AttributeError:\n            return obj\n\n        return obj\n\n    def _update(self, *_) -&gt; None:\n\"\"\"Updates output with new inspection result.\"\"\"\n\n        obj = self.obj_from_path(self._input.value)\n\n        self._output.vertical_align = ptg.VerticalAlignment.CENTER\n        self._output.set_widgets([ptg.inspect(obj)])\n\n    def on_exit(self) -&gt; None:\n        super().on_exit()\n\n        self._output.vertical_align = ptg.VerticalAlignment.TOP\n        for line in self._output.get_lines():\n            print(line)\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.InspectorWindow.obj_from_path","title":"<code>obj_from_path(path)</code>  <code>staticmethod</code>","text":"<p>Retrieves an object from any valid import path.</p> An import path could be something like <p>pytermgui.window_manager.compositor.Compositor</p> <p>...or if the library in question imports its parts within <code>__init__.py</code>-s:     pytermgui.Compositor</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>@staticmethod\ndef obj_from_path(path: str) -&gt; object | None:\n\"\"\"Retrieves an object from any valid import path.\n\n    An import path could be something like:\n        pytermgui.window_manager.compositor.Compositor\n\n    ...or if the library in question imports its parts within `__init__.py`-s:\n        pytermgui.Compositor\n    \"\"\"\n\n    parts = path.split(\".\")\n\n    if parts[0] in dir(builtins):\n        obj = getattr(builtins, parts[0])\n\n    elif parts[0] in dir(ptg):\n        obj = getattr(ptg, parts[0])\n\n    else:\n        try:\n            obj = importlib.import_module(\".\".join(parts[:-1]))\n        except (ValueError, ModuleNotFoundError) as error:\n            return (\n                f\"Could not import object at path {path!r}: {error}.\"\n                + \" Maybe try using the --eval flag?\"\n            )\n\n    try:\n        obj = getattr(obj, parts[-1])\n    except AttributeError:\n        return obj\n\n    return obj\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.TIMWindow","title":"<code>TIMWindow</code>","text":"<p>             Bases: <code>AppWindow</code></p> <p>An application to play around with TIM.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>class TIMWindow(AppWindow):\n\"\"\"An application to play around with TIM.\"\"\"\n\n    app_title = \"TIM Playground\"\n    app_id = \"tim\"\n\n    def __init__(self, args: Namespace | None = None, **attrs: Any) -&gt; None:\n        super().__init__(args, **attrs)\n\n        if self.standalone:\n            self.bind(\n                ptg.keys.RETURN,\n                lambda *_: self.manager.stop() if self.manager is not None else None,\n            )\n\n        self._generate_colors()\n\n        self._output = ptg.Label(parent_align=0)\n\n        self._input = ptg.InputField()\n        self._input.styles.value__fill = lambda _, item: item\n\n        self._showcase = self._create_showcase()\n\n        self._input.bind(ptg.keys.ANY_KEY, lambda *_: self._update_output())\n\n        self._add_widget(\n            ptg.Container(\n                ptg.Container(self._output),\n                self._showcase,\n                ptg.Container(self._input),\n                box=\"EMPTY\",\n                static_width=60,\n            )\n        )\n\n        self.bind(ptg.keys.CTRL_R, self._generate_colors)\n\n        self.setup()\n\n        self.select(0)\n\n    @staticmethod\n    def _random_rgb() -&gt; ptg.Color:\n\"\"\"Returns a random Color.\"\"\"\n\n        rgb = tuple(random.randint(0, 255) for _ in range(3))\n\n        return ptg.RGBColor.from_rgb(rgb)  # type: ignore\n\n    def _update_output(self) -&gt; None:\n\"\"\"Updates the output field.\"\"\"\n\n        self._output.value = self._input.value\n\n    def _generate_colors(self, *_) -&gt; None:\n\"\"\"Generates self._example_{255,rgb,hex}.\"\"\"\n\n        ptg.tim.alias(\"ptg.timwindow.255\", str(random.randint(16, 233)))\n        ptg.tim.alias(\"ptg.timwindow.rgb\", \";\".join(map(str, self._random_rgb().rgb)))\n        ptg.tim.alias(\"ptg.timwindow.hex\", self._random_rgb().hex)\n\n    @staticmethod\n    def _create_showcase() -&gt; ptg.Container:\n\"\"\"Creates the showcase container.\"\"\"\n\n        def _show_style(name: str) -&gt; str:\n            return f\"[{name}]{name}\"  # .replace(\"'\", \"\")\n\n        def _create_table(source: Iterable[tuple[str, str]]) -&gt; ptg.Container:\n            root = ptg.Container()\n\n            for left, right in source:\n                row = ptg.Splitter(\n                    ptg.Label(left, parent_align=0), ptg.Label(right, parent_align=2)\n                )\n\n                row.set_char(\"separator\", f\" {ptg.Container.chars['border'][0]}\")\n\n                root += row\n\n            return root\n\n        prefix = \"ptg.timwindow\"\n        tags = [_show_style(style) for style in ptg.markup.style_maps.STYLES]\n        colors = [\n            f\"[[{prefix}.255]0-255[/]]\",\n            f\"[[{prefix}.hex]#RRGGBB[/]]\",\n            f\"[[{prefix}.rgb]RRR;GGG;BBB[/]]\",\n            \"\",\n            f\"[[inverse {prefix}.255]@0-255[/]]\",\n            f\"[[inverse {prefix}.hex]@#RRGGBB[/]]\",\n            f\"[[inverse {prefix}.rgb]@RRR;GGG;BBB[/]]\",\n        ]\n\n        tag_container = _create_table(zip_longest(tags, colors, fillvalue=\"\"))\n        user_container = _create_table(\n            (_show_style(tag), f\"[{tag}]{value}\")\n            for tag, value in ptg.tim.aliases.items()\n            if not tag.startswith(\"/\") and tag not in ptg.palette.data\n        )\n\n        return ptg.Container(tag_container, user_container, box=\"EMPTY\")\n\n    def on_exit(self) -&gt; None:\n        super().on_exit()\n        ptg.tim.print(ptg.highlight_tim(self._input.value))\n        ptg.tim.print(self._input.value)\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.main","title":"<code>main(argv=None)</code>","text":"<p>Runs the program.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list[str] | None</code> <p>A list of arguments, not included the 0th element pointing to the executable path.</p> <code>None</code> Source code in <code>pytermgui/cmd.py</code> <pre><code>def main(argv: list[str] | None = None) -&gt; None:\n\"\"\"Runs the program.\n\n    Args:\n        argv: A list of arguments, not included the 0th element pointing to the\n            executable path.\n    \"\"\"\n\n    _create_aliases()\n\n    args = process_args(argv)\n\n    args.app = args.app or (\n        \"getch\"\n        if args.getch\n        else (\"tim\" if args.tim else (\"color\" if args.color else None))\n    )\n\n    if args.app or len(sys.argv) == 1:\n        run_environment(args)\n\n        return\n\n    with ptg.terminal.record() as recording:\n        if args.size:\n            ptg.tim.print(f\"{ptg.terminal.width}x{ptg.terminal.height}\")\n\n        elif args.version:\n            _print_version()\n\n        elif args.palette:\n            ptg.palette.print()\n\n        elif args.inspect:\n            _run_inspect(args)\n\n        elif args.exec:\n            args.exec = sys.stdin.read() if args.exec == \"-\" else args.exec\n\n            for name in dir(ptg):\n                obj = getattr(ptg, name, None)\n                globals()[name] = obj\n\n            globals()[\"print\"] = ptg.terminal.print\n\n            exec(args.exec, locals(), globals())  # pylint: disable=exec-used\n\n        elif args.highlight:\n            text = sys.stdin.read() if args.highlight == \"-\" else args.highlight\n\n            ptg.tim.print(ptg.highlight_python(text))\n\n        elif args.file:\n            _interpret_file(args)\n\n        if args.export_svg:\n            recording.save_svg(args.export_svg)\n\n        elif args.export_html:\n            recording.save_html(args.export_html)\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.process_args","title":"<code>process_args(argv=None)</code>","text":"<p>Processes command line arguments.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>def process_args(argv: list[str] | None = None) -&gt; Namespace:\n\"\"\"Processes command line arguments.\"\"\"\n\n    parser = ArgumentParser(\n        description=f\"{ptg.tim.parse(_title())}'s command line environment.\"\n    )\n\n    apps = [short for (_, short), _ in APPLICATION_MAP.items()]\n\n    app_group = parser.add_argument_group(\"Applications\")\n    app_group.add_argument(\n        \"--app\",\n        type=str.lower,\n        help=\"Launch an app.\",\n        metavar=f\"{', '.join(app.capitalize() for app in apps)}\",\n        choices=apps,\n    )\n\n    app_group.add_argument(\n        \"-g\", \"--getch\", help=\"Launch the Getch app.\", action=\"store_true\"\n    )\n\n    app_group.add_argument(\n        \"-t\", \"--tim\", help=\"Launch the TIM Playground app.\", action=\"store_true\"\n    )\n\n    app_group.add_argument(\n        \"-c\",\n        \"--color\",\n        help=\"Launch the ColorPicker app.\",\n        action=\"store_true\",\n    )\n\n    inspect_group = parser.add_argument_group(\"Inspection\")\n    inspect_group.add_argument(\n        \"-i\", \"--inspect\", help=\"Inspect an object.\", metavar=\"PATH_OR_CODE\"\n    )\n    inspect_group.add_argument(\n        \"-e\",\n        \"--eval\",\n        help=\"Evaluate the expression given to `--inspect` instead of treating it as a path.\",\n        action=\"store_true\",\n    )\n\n    inspect_group.add_argument(\n        \"--methods\", help=\"Always show methods when inspecting.\", action=\"store_true\"\n    )\n    inspect_group.add_argument(\n        \"--dunder\",\n        help=\"Always show __dunder__ methods when inspecting.\",\n        action=\"store_true\",\n    )\n    inspect_group.add_argument(\n        \"--private\",\n        help=\"Always show _private methods when inspecting.\",\n        action=\"store_true\",\n    )\n\n    util_group = parser.add_argument_group(\"Utilities\")\n    util_group.add_argument(\n        \"-s\",\n        \"--size\",\n        help=\"Output the current terminal size in WxH format.\",\n        action=\"store_true\",\n    )\n\n    util_group.add_argument(\n        \"-v\",\n        \"--version\",\n        help=\"Print version &amp; system information.\",\n        action=\"store_true\",\n    )\n\n    util_group.add_argument(\n        \"--palette\",\n        help=\"Print the default PyTermGUI color palette.\",\n        action=\"store_true\",\n    )\n\n    util_group.add_argument(\n        \"--highlight\",\n        help=(\n            \"Highlight some python-like code syntax.\"\n            + \" No argument or '-' will read STDIN.\"\n        ),\n        metavar=\"SYNTAX\",\n        const=\"-\",\n        nargs=\"?\",\n    )\n\n    util_group.add_argument(\n        \"--exec\",\n        help=\"Execute some Python code. No argument or '-' will read STDIN.\",\n        const=\"-\",\n        nargs=\"?\",\n    )\n\n    util_group.add_argument(\"-f\", \"--file\", help=\"Interpret a PTG-YAML file.\")\n    util_group.add_argument(\n        \"--print-only\",\n        help=\"When interpreting YAML, print the environment without running it interactively.\",\n        action=\"store_true\",\n    )\n\n    export_group = parser.add_argument_group(\"Exporters\")\n\n    export_group.add_argument(\n        \"--export-svg\",\n        help=\"Export the result of any non-interactive argument as an SVG file.\",\n        metavar=\"FILE\",\n    )\n    export_group.add_argument(\n        \"--export-html\",\n        help=\"Export the result of any non-interactive argument as an HTML file.\",\n        metavar=\"FILE\",\n    )\n\n    argv = argv or sys.argv[1:]\n    args = parser.parse_args(args=argv)\n\n    return args\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.run_environment","title":"<code>run_environment(args)</code>","text":"<p>Runs the WindowManager environment.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>An argparse namespace containing relevant arguments.</p> required Source code in <code>pytermgui/cmd.py</code> <pre><code>def run_environment(args: Namespace) -&gt; None:\n\"\"\"Runs the WindowManager environment.\n\n    Args:\n        args: An argparse namespace containing relevant arguments.\n    \"\"\"\n\n    def _find_focused(manager: ptg.WindowManager) -&gt; ptg.Window | None:\n        if manager.focused is None:\n            return None\n\n        # Find foremost non-persistent window\n        for window in manager:\n            if window.is_persistent:\n                continue\n\n            return window\n\n        return None\n\n    def _toggle_attachment(manager: ptg.WindowManager) -&gt; None:\n        focused = _find_focused(manager)\n\n        if focused is None:\n            return\n\n        slot = manager.layout.body\n        if slot.content is None:\n            slot.content = focused\n        else:\n            slot.detach_content()\n\n        manager.layout.apply()\n\n    def _close_focused(manager: ptg.WindowManager) -&gt; None:\n        focused = _find_focused(manager)\n\n        if focused is None:\n            return\n\n        focused.close()\n\n    _configure_widgets()\n\n    window: AppWindow | None = None\n    with ptg.WindowManager() as manager:\n        app_picker = _create_app_picker(manager)\n\n        manager.bind(\n            ptg.keys.CTRL_W,\n            lambda *_: _close_focused(manager),\n            \"Close window\",\n        )\n        manager.bind(\n            ptg.keys.F12,\n            lambda *_: screenshot(manager),\n            \"Screenshot\",\n        )\n        manager.bind(\n            ptg.keys.CTRL_F,\n            lambda *_: _toggle_attachment(manager),\n            \"Toggle layout\",\n        )\n\n        manager.bind(\n            ptg.keys.CTRL_A,\n            lambda *_: {\n                manager.focus(app_picker),  # type: ignore\n                app_picker.execute_binding(ptg.keys.CTRL_A),\n            },\n        )\n        manager.bind(\n            ptg.keys.ALT + ptg.keys.TAB,\n            lambda *_: manager.focus_next(),\n        )\n        manager.bind(\n            \"!\",\n            lambda *_: ptg.palette.regenerate(\n                primary=\";\".join(str(random.randint(0, 256)) for _ in range(3))\n            ),\n            \"Re-palette\",\n        )\n\n        if not args.app:\n            manager.layout = _create_layout()\n\n            manager.add(_create_header(), assign=\"header\")\n            manager.add(app_picker, assign=\"applications\")\n            manager.add(_create_footer(manager), assign=\"footer\")\n\n            manager.toast(\n                \"[ptg.title]Welcome to the [/ptg.title ptg.brand_title]\"\n                + \"PyTermGUI[/ptg.brand_title ptg.title] CLI!\",\n                offset=ptg.terminal.height // 2 - 3,\n                delay=700,\n            )\n\n        else:\n            manager.layout.add_slot(\"Body\")\n\n            app = _app_from_short(args.app)\n            window = app(args)\n            manager.add(window, assign=\"body\")\n\n    window = window or manager.focused  # type: ignore\n    if window is None or not isinstance(window, AppWindow):\n        return\n\n    window.on_exit()\n</code></pre>"},{"location":"reference/pytermgui/cmd/#pytermgui.cmd.screenshot","title":"<code>screenshot(man)</code>","text":"<p>Opens a modal dialogue &amp; saves a screenshot.</p> Source code in <code>pytermgui/cmd.py</code> <pre><code>def screenshot(man: ptg.WindowManager) -&gt; None:\n\"\"\"Opens a modal dialogue &amp; saves a screenshot.\"\"\"\n\n    tempname = \".screenshot_temp.svg\"\n\n    modal: ptg.Window\n\n    def _finish(*_: Any) -&gt; None:\n\"\"\"Closes the modal and renames the window.\"\"\"\n\n        man.remove(modal)\n        filename = field.value or \"screenshot\"\n\n        if not filename.endswith(\".svg\"):\n            filename += \".svg\"\n\n        os.rename(tempname, filename)\n\n        man.toast(\"[ptg.title]Screenshot saved!\", \"\", f\"[ptg.detail]{filename}\")\n\n    title = sys.argv[0]\n    field = ptg.InputField(prompt=\"Save as: \")\n\n    man.screenshot(title=title, filename=tempname)\n\n    modal = man.alert(\n        \"[ptg.title]Screenshot taken!\", \"\", ptg.Container(field), \"\", [\"Save!\", _finish]\n    )\n</code></pre>"},{"location":"reference/pytermgui/colors/","title":"colors","text":"<p>The module containing all of the color-centric features of this library.</p> <p>This module provides a base class, <code>Color</code>, and a bunch of abstractions over it.</p> <p>Shoutout to: https://stackoverflow.com/a/33206814, one of the best StackOverflow answers I've ever bumped into.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color","title":"<code>Color</code>  <code>dataclass</code>","text":"<p>A terminal color.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The data contained within this color.</p> required <code>background</code> <code>bool</code> <p>Whether this color will represent a color.</p> <code>False</code> <p>These colors are all formattable. There are currently 2 'spec' strings: - f\"{my_color:tim}\" -&gt; Returns self.markup - f\"{my_color:seq}\" -&gt; Returns self.sequence</p> They can thus be used in TIM strings <p>ptg.tim.parse(\"[{my_color:tim}]Hello\") '[]Hello' <p>And in normal, ANSI coded strings:</p> <pre><code>&gt;&gt;&gt; \"{my_color:seq}Hello\"\n'&lt;my_color.sequence&gt;Hello'\n</code></pre> Source code in <code>pytermgui/colors.py</code> <pre><code>@dataclass\nclass Color:  # pylint: disable=too-many-public-methods\n\"\"\"A terminal color.\n\n    Args:\n        value: The data contained within this color.\n        background: Whether this color will represent a color.\n\n    These colors are all formattable. There are currently 2 'spec' strings:\n    - f\"{my_color:tim}\" -&gt; Returns self.markup\n    - f\"{my_color:seq}\" -&gt; Returns self.sequence\n\n    They can thus be used in TIM strings:\n\n        &gt;&gt;&gt; ptg.tim.parse(\"[{my_color:tim}]Hello\")\n        '[&lt;my_color.markup&gt;]Hello'\n\n    And in normal, ANSI coded strings:\n\n        &gt;&gt;&gt; \"{my_color:seq}Hello\"\n        '&lt;my_color.sequence&gt;Hello'\n    \"\"\"\n\n    value: str\n    background: bool = False\n\n    system: ColorSystem = field(init=False)\n\n    default_foreground: Color | None = field(default=None, repr=False)\n    default_background: Color | None = field(default=None, repr=False)\n\n    _rgb: tuple[int, int, int] | None = field(init=False, default=None, repr=False)\n\n    def __format__(self, spec: str) -&gt; str:\n\"\"\"Formats the color by the given specification.\"\"\"\n\n        if spec == \"tim\":\n            return self.markup\n\n        if spec == \"seq\":\n            return self.sequence\n\n        return repr(self)\n\n    @classmethod\n    def from_rgb(cls, rgb: RGBTriplet) -&gt; Color:\n\"\"\"Creates a color from the given RGB.\n\n        Args:\n            rgb: The RGB value to base the new color off of.\n        \"\"\"\n\n        return RGBColor.from_rgb(rgb)\n\n    @classmethod\n    def from_hls(cls, hsl: RGBTriplet) -&gt; Color:\n\"\"\"Creates a color from the given HLS.\n\n        HLS stands for Hue, Lightness &amp; Saturation. It is more commonly known as HSL,\n        but the `colorsys` library uses HLS instead so that's what we use too.\n\n        Args:\n            hsl: The HLS value to base the new color off of.\n        \"\"\"\n\n        rgb = cast(\n            RGBTriplet,\n            map(lambda n: int(256 * n), colorsys.hls_to_rgb(*hsl)),\n        )\n\n        return RGBColor.from_rgb(rgb)\n\n    @property\n    def sequence(self) -&gt; str:\n\"\"\"Returns the ANSI sequence representation of the color.\"\"\"\n\n        raise NotImplementedError\n\n    @cached_property\n    def markup(self) -&gt; str:\n\"\"\"Returns the TIM representation of this color.\"\"\"\n\n        return (\"@\" if self.background else \"\") + self.value\n\n    @cached_property\n    def rgb(self) -&gt; RGBTriplet:\n\"\"\"Returns this color as a tuple of (red, green, blue) values.\"\"\"\n\n        if self._rgb is None:\n            raise NotImplementedError\n\n        return self._rgb\n\n    @cached_property\n    def red(self) -&gt; Number:\n\"\"\"Returns the red component of this color.\"\"\"\n\n        return self.rgb[0]\n\n    @cached_property\n    def green(self) -&gt; Number:\n\"\"\"Returns the red component of this color.\"\"\"\n\n        return self.rgb[1]\n\n    @cached_property\n    def blue(self) -&gt; Number:\n\"\"\"Returns the red component of this color.\"\"\"\n\n        return self.rgb[2]\n\n    @cached_property\n    def hls(self) -&gt; RGBTriplet:\n\"\"\"Returns the HLS (Hue, Lightness, Saturation) representation of this color.\"\"\"\n\n        return colorsys.rgb_to_hls(self.red / 256, self.green / 256, self.blue / 256)\n\n    @cached_property\n    def hue(self) -&gt; float:\n\"\"\"Returns the hue component of this color.\"\"\"\n\n        return self.hls[0]\n\n    @cached_property\n    def lightness(self) -&gt; float:\n\"\"\"Returns the lightness component of this color.\"\"\"\n\n        return self.hls[1]\n\n    @cached_property\n    def saturation(self) -&gt; float:\n\"\"\"Returns the saturation component of this color.\"\"\"\n\n        return self.hls[2]\n\n    @cached_property\n    def hex(self) -&gt; str:\n\"\"\"Returns CSS-like HEX representation of this color.\"\"\"\n\n        buff = \"#\"\n        for color in self.rgb:\n            buff += f\"{format(color, 'x'):0&gt;2}\"\n\n        return buff\n\n    @classmethod\n    def get_default_foreground(cls) -&gt; Color:\n\"\"\"Gets the terminal emulator's default foreground color.\"\"\"\n\n        if cls.default_foreground is not None:\n            return cls.default_foreground\n\n        return _get_palette_color(\"10\")\n\n    @classmethod\n    def get_default_background(cls) -&gt; Color:\n\"\"\"Gets the terminal emulator's default foreground color.\"\"\"\n\n        if cls.default_background is not None:\n            return cls.default_background\n\n        return _get_palette_color(\"11\")\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Returns the reverse-parseable name of this color.\"\"\"\n\n        return (\"@\" if self.background else \"\") + self.value\n\n    @cached_property\n    def luminance(self) -&gt; float:\n\"\"\"Returns this color's perceived luminance (brightness).\n\n        From https://stackoverflow.com/a/596243\n        \"\"\"\n\n        def _linearize(color: float) -&gt; float:\n\"\"\"Converts sRGB color to linear value.\"\"\"\n\n            if color &lt;= 0.04045:\n                return color / 12.92\n\n            return ((color + 0.055) / 1.055) ** 2.4\n\n        red, green, blue = float(self.rgb[0]), float(self.rgb[1]), float(self.rgb[2])\n\n        red /= 255\n        green /= 255\n        blue /= 255\n\n        red = _linearize(red)\n        blue = _linearize(blue)\n        green = _linearize(green)\n\n        return 0.2126 * red + 0.7152 * green + 0.0722 * blue\n\n    def hue_offset(self, offset: float) -&gt; Color:\n\"\"\"Returns the color offset by the given hue.\"\"\"\n\n        hue, lightness, saturation = colorsys.rgb_to_hls(\n            self.red / 256, self.green / 256, self.blue / 256\n        )\n\n        hue = (hue + offset) % 1\n\n        return Color.parse(\n            \";\".join(\n                map(\n                    lambda n: str(int(256 * n)),\n                    colorsys.hls_to_rgb(hue, lightness, saturation),\n                )\n            ),\n            background=self.background,\n            localize=False,\n        )\n\n    @cached_property\n    def brightness(self) -&gt; float:\n\"\"\"Returns the perceived \"brightness\" of a color.\n\n        From https://stackoverflow.com/a/56678483\n        \"\"\"\n\n        if self.luminance &lt;= (216 / 24389):\n            brightness = self.luminance * (24389 / 27)\n\n        else:\n            brightness = self.luminance ** (1 / 3) * 116 - 16\n\n        return brightness / 100\n\n    @cached_property\n    def complement(self) -&gt; Color:\n\"\"\"Returns the complement of this color.\"\"\"\n\n        if self.hue == 0.0:\n            return (\n                Color.parse(\"#FFFFFF\")\n                if self.lightness == 0.0\n                else Color.parse(\"#000000\")\n            )\n\n        return self.hue_offset(0.5)\n\n    @cached_property\n    def triadic(self) -&gt; tuple[Color, Color, Color]:\n\"\"\"Computes the triadic group this color is in.\n\n        Triadic colors are 3-way complements of eachother.\n\n        Returns:\n            This color, the first triadic element and the second one.\n        \"\"\"\n\n        return self, self.hue_offset(1 / 3), self.hue_offset(2 / 3)\n\n    @cached_property\n    def tetradic(self) -&gt; tuple[Color, Color, Color, Color]:\n\"\"\"Computes the tetradic group this color is in.\n\n        Tetradic colors are 4-way complements of eachother.\n\n        Returns:\n            This color, the first tetradic element and the second one.\n        \"\"\"\n\n        return self, self.hue_offset(1 / 4), self.complement, self.hue_offset(3 / 4)\n\n    @cached_property\n    def analogous(self) -&gt; tuple[Color, Color, Color]:\n\"\"\"Computes the analogous group this colors is in.\n\n        Analogous colors are located next to eachother on the color wheel.\n\n        Returns:\n            The color to the left, this color and the color to the right.\n        \"\"\"\n\n        return self.hue_offset(-1 / 12), self, self.hue_offset(1 / 12)\n\n    @cached_property\n    def contrast(self) -&gt; Color:\n\"\"\"Returns a color (black or white) that complies with the W3C contrast ratio guidelines.\"\"\"\n\n        if self.luminance &gt; 0.179:\n            return Color.parse(\"#000000\").blend_complement(0.05)\n\n        return Color.parse(\"#FFFFFF\").blend_complement(0.05)\n\n    def blend(self, other: Color, alpha: float = 0.5, localize: bool = False) -&gt; Color:\n\"\"\"Blends a color into another one.\n\n        Args:\n            other: The color to blend with.\n            alpha: How much the other color should influence the outcome.\n            localize: If set, the returned color will returned its localized version by running\n                `get_localized` on it before returning.\n\n        Returns:\n            A `Color` that is the result of the blending.\n        \"\"\"\n\n        red1, green1, blue1 = self.rgb\n        red2, green2, blue2 = other.rgb\n\n        blended: Color = RGBColor.from_rgb(\n            (\n                int(red1 + (red2 - red1) * alpha),\n                int(green1 + (green2 - green1) * alpha),\n                int(blue1 + (blue2 - blue1) * alpha),\n            )\n        )\n\n        if localize:\n            blended = blended.get_localized()\n\n        return blended\n\n    def blend_complement(self, alpha: float = 0.5) -&gt; Color:\n\"\"\"Blends this color with its complement.\n\n        See `Color.blend`.\n        \"\"\"\n\n        return self.blend(self.complement, alpha)\n\n    def blend_contrast(self, alpha: float = 0.5) -&gt; Color:\n\"\"\"Blends this color with its contrast pair.\n\n        See `Color.blend`.\n        \"\"\"\n\n        return self.blend(self.contrast, alpha)\n\n    def darken(self, alpha: float = 0.5) -&gt; Color:\n\"\"\"Darkens the color by blending it with black, using the alpha provided.\"\"\"\n\n        return self.blend(Color.parse(\"#000000\"), alpha)\n\n    def lighten(self, alpha: float = 0.5) -&gt; Color:\n\"\"\"Lightens the color by blending it with white, using the alpha provided.\"\"\"\n\n        return self.blend(Color.parse(\"#FFFFFF\"), alpha)\n\n    @classmethod\n    def parse(\n        cls,\n        text: str,\n        background: bool = False,  # pylint: disable=redefined-outer-name\n        localize: bool = True,\n        use_cache: bool = False,\n    ) -&gt; Color:\n\"\"\"Uses `str_to_color` to parse some text into a `Color`.\"\"\"\n\n        return str_to_color(\n            text=text,\n            is_background=background,\n            localize=localize,\n            use_cache=use_cache,\n        )\n\n    def __call__(self, text: str, reset: bool = True) -&gt; str:\n\"\"\"Colors the given string.\"\"\"\n\n        buff = self.sequence + text\n        if reset:\n            buff += reset_style()\n\n        return buff\n\n    def get_localized(self) -&gt; Color:\n\"\"\"Creates a terminal-capability local Color instance.\n\n        This method essentially allows for graceful degradation of colors in the\n        terminal.\n        \"\"\"\n\n        system = terminal.colorsystem\n        if self.system &lt;= system:\n            return self\n\n        colortype = SYSTEM_TO_TYPE[system]\n\n        local = colortype.from_rgb(self.rgb)\n        local.background = self.background\n\n        return local\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.analogous","title":"<code>analogous: tuple[Color, Color, Color]</code>  <code>cached</code> <code>property</code>","text":"<p>Computes the analogous group this colors is in.</p> <p>Analogous colors are located next to eachother on the color wheel.</p> <p>Returns:</p> Type Description <code>tuple[Color, Color, Color]</code> <p>The color to the left, this color and the color to the right.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.blue","title":"<code>blue: Number</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the red component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.brightness","title":"<code>brightness: float</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the perceived \"brightness\" of a color.</p> <p>From https://stackoverflow.com/a/56678483</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.complement","title":"<code>complement: Color</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the complement of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.contrast","title":"<code>contrast: Color</code>  <code>cached</code> <code>property</code>","text":"<p>Returns a color (black or white) that complies with the W3C contrast ratio guidelines.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.green","title":"<code>green: Number</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the red component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.hex","title":"<code>hex: str</code>  <code>cached</code> <code>property</code>","text":"<p>Returns CSS-like HEX representation of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.hls","title":"<code>hls: RGBTriplet</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the HLS (Hue, Lightness, Saturation) representation of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.hue","title":"<code>hue: float</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the hue component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.lightness","title":"<code>lightness: float</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the lightness component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.luminance","title":"<code>luminance: float</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this color's perceived luminance (brightness).</p> <p>From https://stackoverflow.com/a/596243</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.markup","title":"<code>markup: str</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the TIM representation of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the reverse-parseable name of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.red","title":"<code>red: Number</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the red component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.rgb","title":"<code>rgb: RGBTriplet</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this color as a tuple of (red, green, blue) values.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.saturation","title":"<code>saturation: float</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the saturation component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.sequence","title":"<code>sequence: str</code>  <code>property</code>","text":"<p>Returns the ANSI sequence representation of the color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.tetradic","title":"<code>tetradic: tuple[Color, Color, Color, Color]</code>  <code>cached</code> <code>property</code>","text":"<p>Computes the tetradic group this color is in.</p> <p>Tetradic colors are 4-way complements of eachother.</p> <p>Returns:</p> Type Description <code>tuple[Color, Color, Color, Color]</code> <p>This color, the first tetradic element and the second one.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.triadic","title":"<code>triadic: tuple[Color, Color, Color]</code>  <code>cached</code> <code>property</code>","text":"<p>Computes the triadic group this color is in.</p> <p>Triadic colors are 3-way complements of eachother.</p> <p>Returns:</p> Type Description <code>tuple[Color, Color, Color]</code> <p>This color, the first triadic element and the second one.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.__call__","title":"<code>__call__(text, reset=True)</code>","text":"<p>Colors the given string.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def __call__(self, text: str, reset: bool = True) -&gt; str:\n\"\"\"Colors the given string.\"\"\"\n\n    buff = self.sequence + text\n    if reset:\n        buff += reset_style()\n\n    return buff\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.__format__","title":"<code>__format__(spec)</code>","text":"<p>Formats the color by the given specification.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def __format__(self, spec: str) -&gt; str:\n\"\"\"Formats the color by the given specification.\"\"\"\n\n    if spec == \"tim\":\n        return self.markup\n\n    if spec == \"seq\":\n        return self.sequence\n\n    return repr(self)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.blend","title":"<code>blend(other, alpha=0.5, localize=False)</code>","text":"<p>Blends a color into another one.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Color</code> <p>The color to blend with.</p> required <code>alpha</code> <code>float</code> <p>How much the other color should influence the outcome.</p> <code>0.5</code> <code>localize</code> <code>bool</code> <p>If set, the returned color will returned its localized version by running <code>get_localized</code> on it before returning.</p> <code>False</code> <p>Returns:</p> Type Description <code>Color</code> <p>A <code>Color</code> that is the result of the blending.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def blend(self, other: Color, alpha: float = 0.5, localize: bool = False) -&gt; Color:\n\"\"\"Blends a color into another one.\n\n    Args:\n        other: The color to blend with.\n        alpha: How much the other color should influence the outcome.\n        localize: If set, the returned color will returned its localized version by running\n            `get_localized` on it before returning.\n\n    Returns:\n        A `Color` that is the result of the blending.\n    \"\"\"\n\n    red1, green1, blue1 = self.rgb\n    red2, green2, blue2 = other.rgb\n\n    blended: Color = RGBColor.from_rgb(\n        (\n            int(red1 + (red2 - red1) * alpha),\n            int(green1 + (green2 - green1) * alpha),\n            int(blue1 + (blue2 - blue1) * alpha),\n        )\n    )\n\n    if localize:\n        blended = blended.get_localized()\n\n    return blended\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.blend_complement","title":"<code>blend_complement(alpha=0.5)</code>","text":"<p>Blends this color with its complement.</p> <p>See <code>Color.blend</code>.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def blend_complement(self, alpha: float = 0.5) -&gt; Color:\n\"\"\"Blends this color with its complement.\n\n    See `Color.blend`.\n    \"\"\"\n\n    return self.blend(self.complement, alpha)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.blend_contrast","title":"<code>blend_contrast(alpha=0.5)</code>","text":"<p>Blends this color with its contrast pair.</p> <p>See <code>Color.blend</code>.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def blend_contrast(self, alpha: float = 0.5) -&gt; Color:\n\"\"\"Blends this color with its contrast pair.\n\n    See `Color.blend`.\n    \"\"\"\n\n    return self.blend(self.contrast, alpha)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.darken","title":"<code>darken(alpha=0.5)</code>","text":"<p>Darkens the color by blending it with black, using the alpha provided.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def darken(self, alpha: float = 0.5) -&gt; Color:\n\"\"\"Darkens the color by blending it with black, using the alpha provided.\"\"\"\n\n    return self.blend(Color.parse(\"#000000\"), alpha)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.from_hls","title":"<code>from_hls(hsl)</code>  <code>classmethod</code>","text":"<p>Creates a color from the given HLS.</p> <p>HLS stands for Hue, Lightness &amp; Saturation. It is more commonly known as HSL, but the <code>colorsys</code> library uses HLS instead so that's what we use too.</p> <p>Parameters:</p> Name Type Description Default <code>hsl</code> <code>RGBTriplet</code> <p>The HLS value to base the new color off of.</p> required Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef from_hls(cls, hsl: RGBTriplet) -&gt; Color:\n\"\"\"Creates a color from the given HLS.\n\n    HLS stands for Hue, Lightness &amp; Saturation. It is more commonly known as HSL,\n    but the `colorsys` library uses HLS instead so that's what we use too.\n\n    Args:\n        hsl: The HLS value to base the new color off of.\n    \"\"\"\n\n    rgb = cast(\n        RGBTriplet,\n        map(lambda n: int(256 * n), colorsys.hls_to_rgb(*hsl)),\n    )\n\n    return RGBColor.from_rgb(rgb)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.from_rgb","title":"<code>from_rgb(rgb)</code>  <code>classmethod</code>","text":"<p>Creates a color from the given RGB.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>RGBTriplet</code> <p>The RGB value to base the new color off of.</p> required Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef from_rgb(cls, rgb: RGBTriplet) -&gt; Color:\n\"\"\"Creates a color from the given RGB.\n\n    Args:\n        rgb: The RGB value to base the new color off of.\n    \"\"\"\n\n    return RGBColor.from_rgb(rgb)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.get_default_background","title":"<code>get_default_background()</code>  <code>classmethod</code>","text":"<p>Gets the terminal emulator's default foreground color.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef get_default_background(cls) -&gt; Color:\n\"\"\"Gets the terminal emulator's default foreground color.\"\"\"\n\n    if cls.default_background is not None:\n        return cls.default_background\n\n    return _get_palette_color(\"11\")\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.get_default_foreground","title":"<code>get_default_foreground()</code>  <code>classmethod</code>","text":"<p>Gets the terminal emulator's default foreground color.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef get_default_foreground(cls) -&gt; Color:\n\"\"\"Gets the terminal emulator's default foreground color.\"\"\"\n\n    if cls.default_foreground is not None:\n        return cls.default_foreground\n\n    return _get_palette_color(\"10\")\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.get_localized","title":"<code>get_localized()</code>","text":"<p>Creates a terminal-capability local Color instance.</p> <p>This method essentially allows for graceful degradation of colors in the terminal.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def get_localized(self) -&gt; Color:\n\"\"\"Creates a terminal-capability local Color instance.\n\n    This method essentially allows for graceful degradation of colors in the\n    terminal.\n    \"\"\"\n\n    system = terminal.colorsystem\n    if self.system &lt;= system:\n        return self\n\n    colortype = SYSTEM_TO_TYPE[system]\n\n    local = colortype.from_rgb(self.rgb)\n    local.background = self.background\n\n    return local\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.hue_offset","title":"<code>hue_offset(offset)</code>","text":"<p>Returns the color offset by the given hue.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def hue_offset(self, offset: float) -&gt; Color:\n\"\"\"Returns the color offset by the given hue.\"\"\"\n\n    hue, lightness, saturation = colorsys.rgb_to_hls(\n        self.red / 256, self.green / 256, self.blue / 256\n    )\n\n    hue = (hue + offset) % 1\n\n    return Color.parse(\n        \";\".join(\n            map(\n                lambda n: str(int(256 * n)),\n                colorsys.hls_to_rgb(hue, lightness, saturation),\n            )\n        ),\n        background=self.background,\n        localize=False,\n    )\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.lighten","title":"<code>lighten(alpha=0.5)</code>","text":"<p>Lightens the color by blending it with white, using the alpha provided.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def lighten(self, alpha: float = 0.5) -&gt; Color:\n\"\"\"Lightens the color by blending it with white, using the alpha provided.\"\"\"\n\n    return self.blend(Color.parse(\"#FFFFFF\"), alpha)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.Color.parse","title":"<code>parse(text, background=False, localize=True, use_cache=False)</code>  <code>classmethod</code>","text":"<p>Uses <code>str_to_color</code> to parse some text into a <code>Color</code>.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef parse(\n    cls,\n    text: str,\n    background: bool = False,  # pylint: disable=redefined-outer-name\n    localize: bool = True,\n    use_cache: bool = False,\n) -&gt; Color:\n\"\"\"Uses `str_to_color` to parse some text into a `Color`.\"\"\"\n\n    return str_to_color(\n        text=text,\n        is_background=background,\n        localize=localize,\n        use_cache=use_cache,\n    )\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.GreyscaleRampColor","title":"<code>GreyscaleRampColor</code>","text":"<p>             Bases: <code>IndexedColor</code></p> <p>The color type used for NO_COLOR greyscale ramps.</p> <p>This implementation uses the color's perceived brightness as its base.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>class GreyscaleRampColor(IndexedColor):\n\"\"\"The color type used for NO_COLOR greyscale ramps.\n\n    This implementation uses the color's perceived brightness as its base.\n    \"\"\"\n\n    @classmethod\n    def from_rgb(cls, rgb: RGBTriplet) -&gt; GreyscaleRampColor:\n\"\"\"Gets a greyscale color based on the given color's luminance.\"\"\"\n\n        color = cls(\"0\")\n        setattr(color, \"_rgb\", rgb)\n\n        index = int(232 + color.brightness * 23)\n        color.value = str(index)\n\n        return color\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.GreyscaleRampColor.from_rgb","title":"<code>from_rgb(rgb)</code>  <code>classmethod</code>","text":"<p>Gets a greyscale color based on the given color's luminance.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef from_rgb(cls, rgb: RGBTriplet) -&gt; GreyscaleRampColor:\n\"\"\"Gets a greyscale color based on the given color's luminance.\"\"\"\n\n    color = cls(\"0\")\n    setattr(color, \"_rgb\", rgb)\n\n    index = int(232 + color.brightness * 23)\n    color.value = str(index)\n\n    return color\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.HEXColor","title":"<code>HEXColor</code>  <code>dataclass</code>","text":"<p>             Bases: <code>RGBColor</code></p> <p>An arbitrary, CSS-like HEX color.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@dataclass\nclass HEXColor(RGBColor):\n\"\"\"An arbitrary, CSS-like HEX color.\"\"\"\n\n    system = ColorSystem.TRUE\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Ensures data validity.\"\"\"\n\n        data = self.value\n        if data.startswith(\"#\"):\n            data = data[1:]\n\n        indices = (0, 2), (2, 4), (4, 6)\n        rgb = []\n        for start, end in indices:\n            value = data[start:end]\n            rgb.append(int(value, base=16))\n\n        self._rgb = rgb[0], rgb[1], rgb[2]\n\n        assert len(self._rgb) == 3\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.HEXColor.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Ensures data validity.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Ensures data validity.\"\"\"\n\n    data = self.value\n    if data.startswith(\"#\"):\n        data = data[1:]\n\n    indices = (0, 2), (2, 4), (4, 6)\n    rgb = []\n    for start, end in indices:\n        value = data[start:end]\n        rgb.append(int(value, base=16))\n\n    self._rgb = rgb[0], rgb[1], rgb[2]\n\n    assert len(self._rgb) == 3\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor","title":"<code>IndexedColor</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Color</code></p> <p>A color representing an index into the xterm-256 color palette.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@dataclass(repr=False)\nclass IndexedColor(Color):\n\"\"\"A color representing an index into the xterm-256 color palette.\"\"\"\n\n    system = ColorSystem.EIGHT_BIT\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Ensures data validity.\"\"\"\n\n        if not self.value.isdigit():\n            raise ValueError(\n                f\"IndexedColor value has to be numerical, got {self.value!r}.\"\n            )\n\n        if not 0 &lt;= int(self.value) &lt; 256:\n            raise ValueError(\n                f\"IndexedColor value has to fit in range 0-255, got {self.value!r}.\"\n            )\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields a fancy looking string.\"\"\"\n\n        yield f\"&lt;{type(self).__name__} value: {self.value}, preview: \"\n\n        yield {\"text\": f\"{self:seq}{PREVIEW_CHAR}\\x1b[0m\", \"highlight\": False}\n\n        yield \"&gt;\"\n\n    @classmethod\n    def from_rgb(cls, rgb: RGBTriplet) -&gt; IndexedColor:\n\"\"\"Constructs an `IndexedColor` from the closest matching option.\"\"\"\n\n        if rgb in _COLOR_MATCH_CACHE:\n            color = _COLOR_MATCH_CACHE[rgb]\n\n            assert isinstance(color, IndexedColor)\n            return color\n\n        if terminal.colorsystem == ColorSystem.STANDARD:\n            return StandardColor.from_rgb(rgb)\n\n        # Normalize the color values\n        red, green, blue = (x / 255 for x in rgb)\n\n        # Calculate the eight-bit color index\n        color_num = 16\n        color_num += 36 * round(red * 5.0)\n        color_num += 6 * round(green * 5.0)\n        color_num += round(blue * 5.0)\n\n        color = cls(str(color_num))\n        _COLOR_MATCH_CACHE[rgb] = color\n\n        return color\n\n    @property\n    def sequence(self) -&gt; str:\nr\"\"\"Returns an ANSI sequence representing this color.\"\"\"\n\n        index = int(self.value)\n\n        return \"\\x1b[\" + (\"48\" if self.background else \"38\") + f\";5;{index}m\"\n\n    @cached_property\n    def rgb(self) -&gt; RGBTriplet:\n\"\"\"Returns an RGB representation of this color.\"\"\"\n\n        if self._rgb is not None:\n            return self._rgb\n\n        index = int(self.value)\n        rgb = COLOR_TABLE[index]\n\n        return (rgb[0], rgb[1], rgb[2])\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.rgb","title":"<code>rgb: RGBTriplet</code>  <code>cached</code> <code>property</code>","text":"<p>Returns an RGB representation of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.sequence","title":"<code>sequence: str</code>  <code>property</code>","text":"<p>Returns an ANSI sequence representing this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.__fancy_repr__","title":"<code>__fancy_repr__()</code>","text":"<p>Yields a fancy looking string.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields a fancy looking string.\"\"\"\n\n    yield f\"&lt;{type(self).__name__} value: {self.value}, preview: \"\n\n    yield {\"text\": f\"{self:seq}{PREVIEW_CHAR}\\x1b[0m\", \"highlight\": False}\n\n    yield \"&gt;\"\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Ensures data validity.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Ensures data validity.\"\"\"\n\n    if not self.value.isdigit():\n        raise ValueError(\n            f\"IndexedColor value has to be numerical, got {self.value!r}.\"\n        )\n\n    if not 0 &lt;= int(self.value) &lt; 256:\n        raise ValueError(\n            f\"IndexedColor value has to fit in range 0-255, got {self.value!r}.\"\n        )\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.IndexedColor.from_rgb","title":"<code>from_rgb(rgb)</code>  <code>classmethod</code>","text":"<p>Constructs an <code>IndexedColor</code> from the closest matching option.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef from_rgb(cls, rgb: RGBTriplet) -&gt; IndexedColor:\n\"\"\"Constructs an `IndexedColor` from the closest matching option.\"\"\"\n\n    if rgb in _COLOR_MATCH_CACHE:\n        color = _COLOR_MATCH_CACHE[rgb]\n\n        assert isinstance(color, IndexedColor)\n        return color\n\n    if terminal.colorsystem == ColorSystem.STANDARD:\n        return StandardColor.from_rgb(rgb)\n\n    # Normalize the color values\n    red, green, blue = (x / 255 for x in rgb)\n\n    # Calculate the eight-bit color index\n    color_num = 16\n    color_num += 36 * round(red * 5.0)\n    color_num += 6 * round(green * 5.0)\n    color_num += round(blue * 5.0)\n\n    color = cls(str(color_num))\n    _COLOR_MATCH_CACHE[rgb] = color\n\n    return color\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor","title":"<code>RGBColor</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Color</code></p> <p>An arbitrary RGB color.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@dataclass(repr=False)\nclass RGBColor(Color):\n\"\"\"An arbitrary RGB color.\"\"\"\n\n    system = ColorSystem.TRUE\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Ensures data validity.\"\"\"\n\n        if self.value.count(\";\") != 2:\n            raise ValueError(\n                \"Invalid value passed to RGBColor.\"\n                + f\" Format has to be rrr;ggg;bbb, got {self.value!r}.\"\n            )\n\n        rgb = tuple(int(num) for num in self.value.split(\";\"))\n        self._rgb = rgb[0], rgb[1], rgb[2]\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields a fancy looking string.\"\"\"\n\n        yield (\n            f\"&lt;{type(self).__name__} red: {self.red}, green: {self.green},\"\n            + f\" blue: {self.blue}, preview: \"\n        )\n\n        yield {\"text\": f\"{self:seq}{PREVIEW_CHAR}\\x1b[0m\", \"highlight\": False}\n\n        yield \"&gt;\"\n\n    @classmethod\n    def from_rgb(cls, rgb: RGBTriplet) -&gt; RGBColor:\n\"\"\"Returns an `RGBColor` from the given triplet.\"\"\"\n\n        return cls(\";\".join(map(str, rgb)))\n\n    @property\n    def red(self) -&gt; float:\n\"\"\"Returns the red component of this color.\"\"\"\n\n        return self.rgb[0]\n\n    @property\n    def green(self) -&gt; float:\n\"\"\"Returns the green component of this color.\"\"\"\n\n        return self.rgb[1]\n\n    @property\n    def blue(self) -&gt; float:\n\"\"\"Returns the blue component of this color.\"\"\"\n\n        return self.rgb[2]\n\n    @property\n    def sequence(self) -&gt; str:\n\"\"\"Returns the ANSI sequence representing this color.\"\"\"\n\n        return (\n            \"\\x1b[\"\n            + (\"48\" if self.background else \"38\")\n            + \";2;\"\n            + \";\".join(str(num) for num in self.rgb)\n            + \"m\"\n        )\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.blue","title":"<code>blue: float</code>  <code>property</code>","text":"<p>Returns the blue component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.green","title":"<code>green: float</code>  <code>property</code>","text":"<p>Returns the green component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.red","title":"<code>red: float</code>  <code>property</code>","text":"<p>Returns the red component of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.sequence","title":"<code>sequence: str</code>  <code>property</code>","text":"<p>Returns the ANSI sequence representing this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.__fancy_repr__","title":"<code>__fancy_repr__()</code>","text":"<p>Yields a fancy looking string.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields a fancy looking string.\"\"\"\n\n    yield (\n        f\"&lt;{type(self).__name__} red: {self.red}, green: {self.green},\"\n        + f\" blue: {self.blue}, preview: \"\n    )\n\n    yield {\"text\": f\"{self:seq}{PREVIEW_CHAR}\\x1b[0m\", \"highlight\": False}\n\n    yield \"&gt;\"\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Ensures data validity.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Ensures data validity.\"\"\"\n\n    if self.value.count(\";\") != 2:\n        raise ValueError(\n            \"Invalid value passed to RGBColor.\"\n            + f\" Format has to be rrr;ggg;bbb, got {self.value!r}.\"\n        )\n\n    rgb = tuple(int(num) for num in self.value.split(\";\"))\n    self._rgb = rgb[0], rgb[1], rgb[2]\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.RGBColor.from_rgb","title":"<code>from_rgb(rgb)</code>  <code>classmethod</code>","text":"<p>Returns an <code>RGBColor</code> from the given triplet.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef from_rgb(cls, rgb: RGBTriplet) -&gt; RGBColor:\n\"\"\"Returns an `RGBColor` from the given triplet.\"\"\"\n\n    return cls(\";\".join(map(str, rgb)))\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor","title":"<code>StandardColor</code>","text":"<p>             Bases: <code>IndexedColor</code></p> <p>A color in the xterm-16 palette.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>class StandardColor(IndexedColor):\n\"\"\"A color in the xterm-16 palette.\"\"\"\n\n    system = ColorSystem.STANDARD\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Returns the markup-compatible name for this color.\"\"\"\n\n        index = name = int(self.value)\n\n        # Normal colors\n        if 30 &lt;= index &lt;= 47:\n            name -= 30\n\n        elif 90 &lt;= index &lt;= 107:\n            name -= 82\n\n        return (\"@\" if self.background else \"\") + str(name)\n\n    @classmethod\n    def from_ansi(cls, code: str) -&gt; StandardColor:\n\"\"\"Creates a standard color from the given ANSI code.\n\n        These codes have to be a digit ranging between 31 and 47.\n        \"\"\"\n\n        if not code.isdigit():\n            raise ColorSyntaxError(\n                f\"Standard color codes must be digits, not {code!r}.\"\n            )\n\n        code_int = int(code)\n\n        if not 30 &lt;= code_int &lt;= 47 and not 90 &lt;= code_int &lt;= 107:\n            raise ColorSyntaxError(\n                f\"Standard color codes must be in the range ]30;47[ or ]90;107[, got {code_int!r}.\"\n            )\n\n        is_background = 40 &lt;= code_int &lt;= 47 or 100 &lt;= code_int &lt;= 107\n\n        if is_background:\n            code_int -= 10\n\n        return cls(str(code_int), background=is_background)\n\n    @classmethod\n    def from_rgb(cls, rgb: RGBTriplet) -&gt; StandardColor:\n\"\"\"Creates a color with the closest-matching xterm index, based on rgb.\n\n        Args:\n            rgb: The target color.\n        \"\"\"\n\n        if rgb in _COLOR_MATCH_CACHE:\n            color = _COLOR_MATCH_CACHE[rgb]\n\n            if color.system is ColorSystem.STANDARD:\n                assert isinstance(color, StandardColor)\n                return color\n\n        # Find the least-different color in the table\n        index = min(range(16), key=lambda i: _get_color_difference(rgb, COLOR_TABLE[i]))\n\n        if index &gt; 7:\n            index += 82\n        else:\n            index += 30\n\n        color = cls(str(index))\n\n        _COLOR_MATCH_CACHE[rgb] = color\n\n        return color\n\n    @property\n    def sequence(self) -&gt; str:\nr\"\"\"Returns an ANSI sequence representing this color.\"\"\"\n\n        index = int(self.value)\n\n        if self.background:\n            index += 10\n\n        return f\"\\x1b[{index}m\"\n\n    @cached_property\n    def rgb(self) -&gt; RGBTriplet:\n\"\"\"Returns an RGB representation of this color.\"\"\"\n\n        index = int(self.value)\n\n        if 30 &lt;= index &lt;= 47:\n            index -= 30\n\n        elif 90 &lt;= index &lt;= 107:\n            index -= 82\n\n        rgb = COLOR_TABLE[index]\n\n        return (rgb[0], rgb[1], rgb[2])\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the markup-compatible name for this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.rgb","title":"<code>rgb: RGBTriplet</code>  <code>cached</code> <code>property</code>","text":"<p>Returns an RGB representation of this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.sequence","title":"<code>sequence: str</code>  <code>property</code>","text":"<p>Returns an ANSI sequence representing this color.</p>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.from_ansi","title":"<code>from_ansi(code)</code>  <code>classmethod</code>","text":"<p>Creates a standard color from the given ANSI code.</p> <p>These codes have to be a digit ranging between 31 and 47.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef from_ansi(cls, code: str) -&gt; StandardColor:\n\"\"\"Creates a standard color from the given ANSI code.\n\n    These codes have to be a digit ranging between 31 and 47.\n    \"\"\"\n\n    if not code.isdigit():\n        raise ColorSyntaxError(\n            f\"Standard color codes must be digits, not {code!r}.\"\n        )\n\n    code_int = int(code)\n\n    if not 30 &lt;= code_int &lt;= 47 and not 90 &lt;= code_int &lt;= 107:\n        raise ColorSyntaxError(\n            f\"Standard color codes must be in the range ]30;47[ or ]90;107[, got {code_int!r}.\"\n        )\n\n    is_background = 40 &lt;= code_int &lt;= 47 or 100 &lt;= code_int &lt;= 107\n\n    if is_background:\n        code_int -= 10\n\n    return cls(str(code_int), background=is_background)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.StandardColor.from_rgb","title":"<code>from_rgb(rgb)</code>  <code>classmethod</code>","text":"<p>Creates a color with the closest-matching xterm index, based on rgb.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>RGBTriplet</code> <p>The target color.</p> required Source code in <code>pytermgui/colors.py</code> <pre><code>@classmethod\ndef from_rgb(cls, rgb: RGBTriplet) -&gt; StandardColor:\n\"\"\"Creates a color with the closest-matching xterm index, based on rgb.\n\n    Args:\n        rgb: The target color.\n    \"\"\"\n\n    if rgb in _COLOR_MATCH_CACHE:\n        color = _COLOR_MATCH_CACHE[rgb]\n\n        if color.system is ColorSystem.STANDARD:\n            assert isinstance(color, StandardColor)\n            return color\n\n    # Find the least-different color in the table\n    index = min(range(16), key=lambda i: _get_color_difference(rgb, COLOR_TABLE[i]))\n\n    if index &gt; 7:\n        index += 82\n    else:\n        index += 30\n\n    color = cls(str(index))\n\n    _COLOR_MATCH_CACHE[rgb] = color\n\n    return color\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.background","title":"<code>background(text, color, reset=True)</code>","text":"<p>Sets the background color of the given text.</p> <p>Note that the given color will be forced into <code>background = True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to color.</p> required <code>color</code> <code>str | Color</code> <p>The color to use. See <code>pytermgui.colors.str_to_color</code> for accepted str formats.</p> required <code>reset</code> <code>bool</code> <p>Whether the return value should include a reset sequence at the end.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The colored text, including a reset if set.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def background(text: str, color: str | Color, reset: bool = True) -&gt; str:\n\"\"\"Sets the background color of the given text.\n\n    Note that the given color will be forced into `background = True`.\n\n    Args:\n        text: The text to color.\n        color: The color to use. See `pytermgui.colors.str_to_color` for accepted\n            str formats.\n        reset: Whether the return value should include a reset sequence at the end.\n\n    Returns:\n        The colored text, including a reset if set.\n    \"\"\"\n\n    if not isinstance(color, Color):\n        color = str_to_color(color)\n\n    color.background = True\n\n    return color(text, reset=reset)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.clear_color_cache","title":"<code>clear_color_cache()</code>","text":"<p>Clears <code>_COLOR_CACHE</code> and <code>_COLOR_MATCH_CACHE</code>.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def clear_color_cache() -&gt; None:\n\"\"\"Clears `_COLOR_CACHE` and `_COLOR_MATCH_CACHE`.\"\"\"\n\n    _COLOR_CACHE.clear()\n    _COLOR_MATCH_CACHE.clear()\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.foreground","title":"<code>foreground(text, color, reset=True)</code>","text":"<p>Sets the foreground color of the given text.</p> <p>Note that the given color will be forced into <code>background = True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to color.</p> required <code>color</code> <code>str | Color</code> <p>The color to use. See <code>pytermgui.colors.str_to_color</code> for accepted str formats.</p> required <code>reset</code> <code>bool</code> <p>Whether the return value should include a reset sequence at the end.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The colored text, including a reset if set.</p> Source code in <code>pytermgui/colors.py</code> <pre><code>def foreground(text: str, color: str | Color, reset: bool = True) -&gt; str:\n\"\"\"Sets the foreground color of the given text.\n\n    Note that the given color will be forced into `background = True`.\n\n    Args:\n        text: The text to color.\n        color: The color to use. See `pytermgui.colors.str_to_color` for accepted\n            str formats.\n        reset: Whether the return value should include a reset sequence at the end.\n\n    Returns:\n        The colored text, including a reset if set.\n    \"\"\"\n\n    if not isinstance(color, Color):\n        color = str_to_color(color)\n\n    color.background = False\n\n    return color(text, reset=reset)\n</code></pre>"},{"location":"reference/pytermgui/colors/#pytermgui.colors.str_to_color","title":"<code>str_to_color(text, is_background=False, localize=True, use_cache=True)</code>  <code>cached</code>","text":"<p>Creates a <code>Color</code> from the given text.</p> <p>Accepted formats:</p> <ul> <li>0-255: <code>IndexedColor</code>.</li> <li>'rrr;ggg;bbb': <code>RGBColor</code>.</li> <li>'(#)rrggbb': <code>HEXColor</code>. Leading hash is optional.</li> </ul> <p>You can also add a leading '@' into the string to make the output represent a background color, such as <code>@#123abc</code>.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The string to format from.</p> required <code>is_background</code> <code>bool</code> <p>Whether the output should be forced into a background color. Mostly used internally, when set will take precedence over syntax of leading '@' symbol.</p> <code>False</code> <code>localize</code> <code>bool</code> <p>Whether <code>get_localized</code> should be called on the output color.</p> <code>True</code> <code>use_cache</code> <code>bool</code> <p>Whether caching should be used.</p> <code>True</code> Source code in <code>pytermgui/colors.py</code> <pre><code>@lru_cache(maxsize=1024)\ndef str_to_color(\n    text: str,\n    is_background: bool = False,\n    localize: bool = True,\n    use_cache: bool = True,\n) -&gt; Color:\n\"\"\"Creates a `Color` from the given text.\n\n    Accepted formats:\n\n    - 0-255: `IndexedColor`.\n    - 'rrr;ggg;bbb': `RGBColor`.\n    - '(#)rrggbb': `HEXColor`. Leading hash is optional.\n\n    You can also add a leading '@' into the string to make the output represent a\n    background color, such as `@#123abc`.\n\n    Args:\n        text: The string to format from.\n        is_background: Whether the output should be forced into a background color.\n            Mostly used internally, when set will take precedence over syntax of leading\n            '@' symbol.\n        localize: Whether `get_localized` should be called on the output color.\n        use_cache: Whether caching should be used.\n    \"\"\"\n\n    def _trim_code(code: str) -&gt; str:\n\"\"\"Trims the given color code.\"\"\"\n\n        if not all(char.isdigit() or char in \"m;\" for char in code):\n            return code\n\n        is_background = code.startswith(\"48;\")\n\n        if (code.startswith(\"38;5;\") or code.startswith(\"48;5;\")) or (\n            code.startswith(\"38;2;\") or code.startswith(\"48;2;\")\n        ):\n            code = code[5:]\n\n        if code.endswith(\"m\"):\n            code = code[:-1]\n\n        if is_background:\n            code = \"@\" + code\n\n        return code\n\n    text = _trim_code(text)\n\n    if not use_cache:\n        str_to_color.cache_clear()\n\n    if text.startswith(\"@\"):\n        is_background = True\n        text = text[1:]\n\n    if text in NAMED_COLORS:\n        return str_to_color(str(NAMED_COLORS[text]), is_background=is_background)\n\n    color: Color\n\n    # This code is not pretty, but having these separate branches for each type\n    # should improve the performance by quite a large margin.\n    match = RE_256.match(text)\n    if match is not None:\n        # Note: At the moment, all colors become an `IndexedColor`, due to a large\n        #       amount of problems a separated `StandardColor` class caused. Not\n        #       sure if there are any real drawbacks to doing it this way, bar the\n        #       extra characters that 255 colors use up compared to xterm-16.\n        color = IndexedColor(match[0], background=is_background)\n\n        return color.get_localized() if localize else color\n\n    match = RE_HEX.match(text)\n    if match is not None:\n        color = HEXColor(match[0], background=is_background)\n\n        return color.get_localized() if localize else color\n\n    match = RE_RGB.match(text)\n    if match is not None:\n        color = RGBColor(match[0], background=is_background)\n\n        return color.get_localized() if localize else color\n\n    raise ColorSyntaxError(f\"Could not convert {text!r} into a `Color`.\")\n</code></pre>"},{"location":"reference/pytermgui/context_managers/","title":"context_managers","text":"<p>Ease-of-use context-manager classes &amp; functions.</p> <p>There isn't much (or any) additional functionality provided in this module, most things are nicer-packaged combinations to already available methods from <code>pytermgui.ansi_interface</code>.</p>"},{"location":"reference/pytermgui/context_managers/#pytermgui.context_managers.alt_buffer","title":"<code>alt_buffer(echo=False, cursor=True)</code>","text":"<p>Creates non-scrollable alt-buffer.</p> <p>This is useful for retrieving original terminal state after program end.</p> <p>Parameters:</p> Name Type Description Default <code>echo</code> <code>bool</code> <p>Whether <code>unset_echo</code> should be called on startup.</p> <code>False</code> <code>cursor</code> <code>bool</code> <p>Whether <code>hide_cursor</code> should be called on startup.</p> <code>True</code> Source code in <code>pytermgui/context_managers.py</code> <pre><code>@contextmanager\ndef alt_buffer(echo: bool = False, cursor: bool = True) -&gt; Generator[None, None, None]:\n\"\"\"Creates non-scrollable alt-buffer.\n\n    This is useful for retrieving original terminal state after program end.\n\n    Args:\n        echo: Whether `unset_echo` should be called on startup.\n        cursor: Whether `hide_cursor` should be called on startup.\n    \"\"\"\n\n    terminal = get_terminal()\n\n    try:\n        set_alt_buffer()\n\n        if not echo and name == \"posix\" and not terminal.is_interactive():\n            unset_echo()\n\n        if not cursor:\n            hide_cursor()\n\n        yield\n\n    finally:\n        unset_alt_buffer()\n\n        if not echo and name == \"posix\" and not terminal.is_interactive():\n            set_echo()\n            cursor_up()\n\n        if not cursor:\n            show_cursor()\n            cursor_up()\n</code></pre>"},{"location":"reference/pytermgui/context_managers/#pytermgui.context_managers.cursor_at","title":"<code>cursor_at(pos)</code>","text":"<p>Gets callable to print at <code>pos</code>, incrementing <code>y</code> on every print.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>The position to start printing at. Follows the order (columns, rows).</p> required <p>Yields:</p> Type Description <code>Callable[..., None]</code> <p>A callable printing function. This function forwards all arguments to <code>print</code>,</p> <code>Callable[..., None]</code> <p>but positions the cursor before doing so. After every call, the y position is</p> <code>Callable[..., None]</code> <p>incremented.</p> Source code in <code>pytermgui/context_managers.py</code> <pre><code>@contextmanager\ndef cursor_at(pos: tuple[int, int]) -&gt; Generator[Callable[..., None], None, None]:\n\"\"\"Gets callable to print at `pos`, incrementing `y` on every print.\n\n    Args:\n        pos: The position to start printing at. Follows the order (columns, rows).\n\n    Yields:\n        A callable printing function. This function forwards all arguments to `print`,\n        but positions the cursor before doing so. After every call, the y position is\n        incremented.\n    \"\"\"\n\n    offset = 0\n    posx, posy = pos\n\n    def printer(*args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Print to posx, current y\"\"\"\n\n        nonlocal offset\n\n        print_to((posx, posy + offset), *args, **kwargs)\n        offset += 1\n\n    try:\n        save_cursor()\n        yield printer\n\n    finally:\n        restore_cursor()\n</code></pre>"},{"location":"reference/pytermgui/context_managers/#pytermgui.context_managers.mouse_handler","title":"<code>mouse_handler(events, method='decimal_xterm')</code>","text":"<p>Return a mouse handler function</p> <p>See <code>help(report_mouse)</code> for help about all of the methods.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>list[str]</code> <p>A list of <code>pytermgui.ansi_interface.report_mouse</code> events.</p> required <code>method</code> <code>str</code> <p>The method to use for reporting. Only <code>decimal_urxvt</code> and <code>decimal_xterm</code> are currently supported.</p> <code>'decimal_xterm'</code> <p>Example use:</p> <pre><code>import pytermgui as ptg\n\nwith ptg.mouse_handler([\"press\", \"hover\"]) as mouse:\n    while True:\n      event = mouse(ptg.getch())\n      print(type(event))\n      print(event.action)\n      print(event.position)\n\n'pytermgui.ansi_interface.MouseEvent'\n'pytermgui.ansi_interface.MouseAction.LEFT_CLICK'\n(33, 55)\n</code></pre> Source code in <code>pytermgui/context_managers.py</code> <pre><code>@contextmanager\ndef mouse_handler(\n    events: list[str], method: str = \"decimal_xterm\"\n) -&gt; Generator[MouseTranslator, None, None]:\n\"\"\"Return a mouse handler function\n\n    See `help(report_mouse)` for help about all of the methods.\n\n    Args:\n        events: A list of `pytermgui.ansi_interface.report_mouse` events.\n        method: The method to use for reporting. Only `decimal_urxvt` and\n            `decimal_xterm` are currently supported.\n\n    Example use:\n\n    ```python3\n    import pytermgui as ptg\n\n    with ptg.mouse_handler([\"press\", \"hover\"]) as mouse:\n        while True:\n          event = mouse(ptg.getch())\n          print(type(event))\n          print(event.action)\n          print(event.position)\n\n    'pytermgui.ansi_interface.MouseEvent'\n    'pytermgui.ansi_interface.MouseAction.LEFT_CLICK'\n    (33, 55)\n    ```\n\n    \"\"\"\n\n    try:\n        for event in events:\n            report_mouse(event, method=method)\n\n        yield lambda code: translate_mouse(code, method=method)\n\n    finally:\n        for event in events:\n            report_mouse(event, method=method, stop=True)\n</code></pre>"},{"location":"reference/pytermgui/enums/","title":"enums","text":"<p>This module provides commonly used enumerations for the library. It also has a class implementing Enum-s with default values. All Enums below subclass it, meaning you can use their <code>get_default()</code> methods to get the globally set default value.</p> <p>To modify defaults, use the <code>defaults</code> dictionary.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.CenteringPolicy","title":"<code>CenteringPolicy</code>","text":"<p>             Bases: <code>DefaultEnum</code></p> <p>Policies to center <code>Container</code> according to.</p> Source code in <code>pytermgui/enums.py</code> <pre><code>class CenteringPolicy(DefaultEnum):\n\"\"\"Policies to center `Container` according to.\"\"\"\n\n    ALL = _auto()\n    VERTICAL = _auto()\n    HORIZONTAL = _auto()\n</code></pre>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.DefaultEnum","title":"<code>DefaultEnum</code>","text":"<p>             Bases: <code>IntEnum</code></p> <p>An Enum class that can return its default value.</p> Source code in <code>pytermgui/enums.py</code> <pre><code>class DefaultEnum(IntEnum):\n\"\"\"An Enum class that can return its default value.\"\"\"\n\n    @classmethod\n    def get_default(cls) -&gt; IntEnum | None:\n\"\"\"Get default value\"\"\"\n\n        return defaults.get(cls)\n</code></pre>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.DefaultEnum.get_default","title":"<code>get_default()</code>  <code>classmethod</code>","text":"<p>Get default value</p> Source code in <code>pytermgui/enums.py</code> <pre><code>@classmethod\ndef get_default(cls) -&gt; IntEnum | None:\n\"\"\"Get default value\"\"\"\n\n    return defaults.get(cls)\n</code></pre>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.HorizontalAlignment","title":"<code>HorizontalAlignment</code>","text":"<p>             Bases: <code>DefaultEnum</code></p> <p>Policies to align widgets by.</p> <p>These are applied by the parent object, and are relative to them.</p> Source code in <code>pytermgui/enums.py</code> <pre><code>class HorizontalAlignment(DefaultEnum):\n\"\"\"Policies to align widgets by.\n\n    These are applied by the parent object, and are\n    relative to them.\"\"\"\n\n    LEFT = 0\n\"\"\"Align widget to the left edge.\"\"\"\n\n    CENTER = 1\n\"\"\"Center widget in the available width.\"\"\"\n\n    RIGHT = 2\n\"\"\"Align widget to the right edge.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.HorizontalAlignment.CENTER","title":"<code>CENTER = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Center widget in the available width.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.HorizontalAlignment.LEFT","title":"<code>LEFT = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align widget to the left edge.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.HorizontalAlignment.RIGHT","title":"<code>RIGHT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align widget to the right edge.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow","title":"<code>Overflow</code>","text":"<p>             Bases: <code>DefaultEnum</code></p> <p>Overflow policies implemented by Container.</p> Source code in <code>pytermgui/enums.py</code> <pre><code>class Overflow(DefaultEnum):\n\"\"\"Overflow policies implemented by Container.\"\"\"\n\n    HIDE = 0\n\"\"\"Stop gathering lines once there is no room left.\"\"\"\n\n    SCROLL = 1\n\"\"\"Allow scrolling when there is too many lines.\"\"\"\n\n    RESIZE = 2\n\"\"\"Resize parent to fit with the new lines.\n\n    Note:\n        When applied to a window, this prevents resizing its height\n        using the bottom border.\n    \"\"\"\n\n    # TODO: Implement Overflow.AUTO\n    AUTO = 9999\n\"\"\"NotImplemented\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow.AUTO","title":"<code>AUTO = 9999</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NotImplemented</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow.HIDE","title":"<code>HIDE = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Stop gathering lines once there is no room left.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow.RESIZE","title":"<code>RESIZE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Resize parent to fit with the new lines.</p> Note <p>When applied to a window, this prevents resizing its height using the bottom border.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.Overflow.SCROLL","title":"<code>SCROLL = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Allow scrolling when there is too many lines.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.SizePolicy","title":"<code>SizePolicy</code>","text":"<p>             Bases: <code>DefaultEnum</code></p> <p>Values according to which Widget sizes are assigned.</p> Source code in <code>pytermgui/enums.py</code> <pre><code>class SizePolicy(DefaultEnum):\n\"\"\"Values according to which Widget sizes are assigned.\"\"\"\n\n    FILL = 0\n\"\"\"Inner widget will take up as much width as possible.\"\"\"\n\n    STATIC = 1\n\"\"\"Inner widget will take up an exact amount of width.\"\"\"\n\n    RELATIVE = 2\n\"\"\"Inner widget will take up widget.relative_width * available\n    space.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.SizePolicy.FILL","title":"<code>FILL = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inner widget will take up as much width as possible.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.SizePolicy.RELATIVE","title":"<code>RELATIVE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inner widget will take up widget.relative_width * available space.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.SizePolicy.STATIC","title":"<code>STATIC = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inner widget will take up an exact amount of width.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.VerticalAlignment","title":"<code>VerticalAlignment</code>","text":"<p>             Bases: <code>DefaultEnum</code></p> <p>Vertical alignment options for widgets.</p> Source code in <code>pytermgui/enums.py</code> <pre><code>class VerticalAlignment(DefaultEnum):\n\"\"\"Vertical alignment options for widgets.\"\"\"\n\n    TOP = 0\n\"\"\"Align widgets to the top\"\"\"\n\n    CENTER = 1\n\"\"\"Align widgets in the center, with equal* padding on the top and bottom.\n\n    Note:\n        When the available height is not divisible by 2, the extra line of padding\n        is added to the bottom.\n    \"\"\"\n\n    BOTTOM = 2\n\"\"\"Align widgets to the bottom.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.VerticalAlignment.BOTTOM","title":"<code>BOTTOM = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align widgets to the bottom.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.VerticalAlignment.CENTER","title":"<code>CENTER = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align widgets in the center, with equal* padding on the top and bottom.</p> Note <p>When the available height is not divisible by 2, the extra line of padding is added to the bottom.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.VerticalAlignment.TOP","title":"<code>TOP = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Align widgets to the top</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange","title":"<code>WidgetChange</code>","text":"<p>             Bases: <code>Enum</code></p> <p>The type of change that happened within a widget.</p> Source code in <code>pytermgui/enums.py</code> <pre><code>class WidgetChange(Enum):\n\"\"\"The type of change that happened within a widget.\"\"\"\n\n    LINES = _auto()\n\"\"\"The result of `get_lines` has changed, but size changes didn't happen.\"\"\"\n\n    SIZE = _auto()\n\"\"\"Both WIDTH and HEIGHT has changed.\"\"\"\n\n    WIDTH = _auto()\n\"\"\"The width of the widget changed, possibly involving LINES type changes.\"\"\"\n\n    HEIGHT = _auto()\n\"\"\"The height of the widget changed, possibly involving LINES type changes.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange.HEIGHT","title":"<code>HEIGHT = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The height of the widget changed, possibly involving LINES type changes.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange.LINES","title":"<code>LINES = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The result of <code>get_lines</code> has changed, but size changes didn't happen.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange.SIZE","title":"<code>SIZE = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Both WIDTH and HEIGHT has changed.</p>"},{"location":"reference/pytermgui/enums/#pytermgui.enums.WidgetChange.WIDTH","title":"<code>WIDTH = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The width of the widget changed, possibly involving LINES type changes.</p>"},{"location":"reference/pytermgui/exceptions/","title":"exceptions","text":"<p>Custom Exception-s used in pytermgui.</p>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.AnsiSyntaxError","title":"<code>AnsiSyntaxError</code>","text":"<p>             Bases: <code>ParserSyntaxError</code></p> <p>Raised when parsed ANSI text contains an error.</p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>class AnsiSyntaxError(ParserSyntaxError):\n\"\"\"Raised when parsed ANSI text contains an error.\"\"\"\n\n    _delimiters = (\"\\\\x1b[\", \"m\")\n</code></pre>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ColorSyntaxError","title":"<code>ColorSyntaxError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a color string could not be parsed into a <code>pytermgui.colors.Color</code></p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>class ColorSyntaxError(Exception):\n\"\"\"Raised when a color string could not be parsed into a `pytermgui.colors.Color`\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.LineLengthError","title":"<code>LineLengthError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a widget line is not the expected length.</p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>class LineLengthError(Exception):\n\"\"\"Raised when a widget line is not the expected length.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.MarkupSyntaxError","title":"<code>MarkupSyntaxError</code>","text":"<p>             Bases: <code>ParserSyntaxError</code></p> <p>Raised when parsed markup text contains an error.</p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>class MarkupSyntaxError(ParserSyntaxError):\n\"\"\"Raised when parsed markup text contains an error.\"\"\"\n\n    _delimiters = (\"[\", \"]\")\n</code></pre>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ParserSyntaxError","title":"<code>ParserSyntaxError</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Parent exception for unparsable strings.</p> <p>This exception takes some basic parameters, and formats a message depending on the _delimiters value. This has to be supplied by each child, while the rest of the arguments are to be given at construction.</p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>@dataclass\nclass ParserSyntaxError(Exception):\n\"\"\"Parent exception for unparsable strings.\n\n    This exception takes some basic parameters, and formats\n    a message depending on the _delimiters value. This has to\n    be supplied by each child, while the rest of the arguments\n    are to be given at construction.\"\"\"\n\n    tag: str\n    cause: str\n    context: str\n    _delimiters: tuple[str, str] = field(init=False)\n\n    @property\n    def message(self) -&gt; str:\n\"\"\"Create message from tag, context and cause.\"\"\"\n\n        msg = f'Tag \"{self.tag}\" '\n\n        if self.context != \"\":\n            index = self.context.find(self.tag)\n            escaped_context = repr(self.context).strip(\"'\")\n\n            if len(self.context) &gt; 50:\n                escaped_context = (\n                    \"...\"\n                    + ascii(self.context).strip(\"'\")[max(index - 25, 0) : index + 25]\n                    + \"...\"\n                )\n\n            highlighted = escaped_context.replace(\n                self.tag, \"\\x1b[31m\\x1b[1m\" + self.tag + \"\\x1b[0m\", 1\n            )\n\n            msg += f'in string \"{highlighted}\" '\n\n        return f\"{msg}{self.cause}.\"\n\n    def escape_message(self) -&gt; str:\n\"\"\"Return message with markup tags escaped.\"\"\"\n\n        char = self._delimiters[0]\n        return self.message.replace(char, \"\\\\\" + char)\n\n    def __str__(self) -&gt; str:\n\"\"\"Show message.\"\"\"\n\n        return self.message\n</code></pre>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ParserSyntaxError.message","title":"<code>message: str</code>  <code>property</code>","text":"<p>Create message from tag, context and cause.</p>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ParserSyntaxError.__str__","title":"<code>__str__()</code>","text":"<p>Show message.</p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Show message.\"\"\"\n\n    return self.message\n</code></pre>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.ParserSyntaxError.escape_message","title":"<code>escape_message()</code>","text":"<p>Return message with markup tags escaped.</p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>def escape_message(self) -&gt; str:\n\"\"\"Return message with markup tags escaped.\"\"\"\n\n    char = self._delimiters[0]\n    return self.message.replace(char, \"\\\\\" + char)\n</code></pre>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.TimeoutException","title":"<code>TimeoutException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when an action has timed out.</p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>class TimeoutException(Exception):\n\"\"\"Raised when an action has timed out.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/exceptions/#pytermgui.exceptions.WidthExceededError","title":"<code>WidthExceededError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when an element's width is larger than the screen.</p> Source code in <code>pytermgui/exceptions.py</code> <pre><code>class WidthExceededError(Exception):\n\"\"\"Raised when an element's width is larger than the screen.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/exporters/","title":"exporters","text":"<p>This module provides various methods and utilities to turn TIM into HTML &amp; SVG.</p>"},{"location":"reference/pytermgui/exporters/#pytermgui.exporters.prettify_xml","title":"<code>prettify_xml(xml)</code>","text":"<p>Prettifies some XML.</p> Source code in <code>pytermgui/exporters.py</code> <pre><code>def prettify_xml(xml: str) -&gt; str:\n\"\"\"Prettifies some XML.\"\"\"\n\n    dom = md.parseString(xml)\n    pretty_xml = dom.toprettyxml()\n\n    return \"\\n\".join([s for s in pretty_xml.splitlines()[1:] if s.strip() != \"\"])\n</code></pre>"},{"location":"reference/pytermgui/exporters/#pytermgui.exporters.to_html","title":"<code>to_html(obj, prefix=None, inline_styles=False, include_background=True, vertical_offset=0.0, horizontal_offset=0.0, formatter=HTML_FORMAT, joiner='\\n')</code>","text":"<p>Creates a static HTML representation of the given object.</p> <p>Note that the output HTML will not be very attractive or easy to read. This is because these files probably aren't meant to be read by a human anyways, so file sizes are more important.</p> <p>If you do care about the visual style of the output, you can run it through some prettifiers to get the result you are looking for.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Widget | StyledText | str</code> <p>The object to represent. Takes either a Widget or some markup text.</p> required <code>prefix</code> <code>str | None</code> <p>The prefix included in the generated classes, e.g. instead of <code>ptg-0</code>, you would get <code>ptg-my-prefix-0</code>.</p> <code>None</code> <code>inline_styles</code> <code>bool</code> <p>If set, styles will be set for each span using the inline <code>style</code> argument, otherwise a full style section is constructed.</p> <code>False</code> <code>include_background</code> <code>bool</code> <p>Whether to include the terminal's background color in the output.</p> <code>True</code> Source code in <code>pytermgui/exporters.py</code> <pre><code>def to_html(  # pylint: disable=too-many-arguments, too-many-locals\n    obj: Widget | StyledText | str,\n    prefix: str | None = None,\n    inline_styles: bool = False,\n    include_background: bool = True,\n    vertical_offset: float = 0.0,\n    horizontal_offset: float = 0.0,\n    formatter: str = HTML_FORMAT,\n    joiner: str = \"\\n\",\n) -&gt; str:\n\"\"\"Creates a static HTML representation of the given object.\n\n    Note that the output HTML will not be very attractive or easy to read. This is\n    because these files probably aren't meant to be read by a human anyways, so file\n    sizes are more important.\n\n    If you do care about the visual style of the output, you can run it through some\n    prettifiers to get the result you are looking for.\n\n    Args:\n        obj: The object to represent. Takes either a Widget or some markup text.\n        prefix: The prefix included in the generated classes, e.g. instead of `ptg-0`,\n            you would get `ptg-my-prefix-0`.\n        inline_styles: If set, styles will be set for each span using the inline `style`\n            argument, otherwise a full style section is constructed.\n        include_background: Whether to include the terminal's background color in the\n            output.\n    \"\"\"\n\n    document_styles: list[list[str]] = []\n\n    if isinstance(obj, Widget):\n        data = obj.get_lines()\n\n    elif isinstance(obj, str):\n        data = obj.splitlines()\n\n    else:\n        data = str(obj).splitlines()\n\n    lines = []\n    for dataline in data:\n        line = \"\"\n\n        for span, styles in _get_spans(\n            dataline, vertical_offset, horizontal_offset, include_background\n        ):\n            index = _generate_index_in(document_styles, styles)\n            if index == len(document_styles):\n                document_styles.append(styles)\n\n            if inline_styles:\n                stylesheet = \";\".join(styles)\n                line += span.format(f\" styles='{stylesheet}'\")\n\n            else:\n                line += span.format(\" class='\" + _get_cls(prefix or \"\", index) + \"'\")\n\n        # Close any previously not closed divs\n        line += \"&lt;/div&gt;\" * (line.count(\"&lt;div\") - line.count(\"&lt;/div\"))\n        lines.append(line)\n\n    stylesheet = \"\"\n    if not inline_styles:\n        stylesheet = _generate_stylesheet(document_styles, prefix)\n\n    document = formatter.format(\n        foreground=Color.get_default_foreground().hex,\n        background=Color.get_default_background().hex if include_background else \"\",\n        content=joiner.join(lines),\n        styles=stylesheet,\n        font_size=FONT_SIZE,\n    )\n\n    return document\n</code></pre>"},{"location":"reference/pytermgui/exporters/#pytermgui.exporters.to_svg","title":"<code>to_svg(obj, prefix=None, chrome=True, inline_styles=False, title='PyTermGUI', formatter=SVG_FORMAT)</code>","text":"<p>Creates an SVG screenshot of the given object.</p> <p>This screenshot tries to mimick what the Kitty terminal looks like on MacOS, complete with the menu buttons and drop shadow. The <code>title</code> argument will be displayed in the window's top bar.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Widget | StyledText | str</code> <p>The object to represent. Takes either a Widget or some markup text.</p> required <code>prefix</code> <code>str | None</code> <p>The prefix included in the generated classes, e.g. instead of <code>ptg-0</code>, you would get <code>ptg-my-prefix-0</code>.</p> <code>None</code> <code>chrome</code> <code>bool</code> <p>Sets the visibility of the window \"chrome\", e.g. the part of the SVG that mimicks the outside border of a terminal.</p> <code>True</code> <code>inline_styles</code> <code>bool</code> <p>If set, styles will be set for each span using the inline <code>style</code> argument, otherwise a full style section is constructed.</p> <code>False</code> <code>title</code> <code>str</code> <p>A string to display in the top bar of the fake terminal.</p> <code>'PyTermGUI'</code> <code>formatter</code> <code>str</code> <p>The formatting string to use. Inspect <code>pytermgui.exporters.SVG_FORMAT</code> to see all of its arguments.</p> <code>SVG_FORMAT</code> Source code in <code>pytermgui/exporters.py</code> <pre><code>def to_svg(  # pylint: disable=too-many-locals, too-many-arguments, too-many-statements\n    obj: Widget | StyledText | str,\n    prefix: str | None = None,\n    chrome: bool = True,\n    inline_styles: bool = False,\n    title: str = \"PyTermGUI\",\n    formatter: str = SVG_FORMAT,\n) -&gt; str:\n\"\"\"Creates an SVG screenshot of the given object.\n\n    This screenshot tries to mimick what the Kitty terminal looks like on MacOS,\n    complete with the menu buttons and drop shadow. The `title` argument will be\n    displayed in the window's top bar.\n\n    Args:\n        obj: The object to represent. Takes either a Widget or some markup text.\n        prefix: The prefix included in the generated classes, e.g. instead of `ptg-0`,\n            you would get `ptg-my-prefix-0`.\n        chrome: Sets the visibility of the window \"chrome\", e.g. the part of the SVG\n            that mimicks the outside border of a terminal.\n        inline_styles: If set, styles will be set for each span using the inline `style`\n            argument, otherwise a full style section is constructed.\n        title: A string to display in the top bar of the fake terminal.\n        formatter: The formatting string to use. Inspect `pytermgui.exporters.SVG_FORMAT`\n            to see all of its arguments.\n    \"\"\"\n\n    def _is_block(text: str) -&gt; bool:\n\"\"\"Determines whether the given text only contains block characters.\n\n        These characters reside in the unicode range of 9600-9631, which is what we test\n        against.\n        \"\"\"\n\n        return all(9600 &lt;= ord(char) &lt;= 9631 for char in text)\n\n    prefix = prefix if prefix is not None else \"ptg\"\n\n    terminal = get_terminal()\n    default_fore = Color.get_default_foreground().hex\n    default_back = Color.get_default_background().hex\n\n    text = \"\"\n\n    lines = 1\n    cursor_x = cursor_y = 0.0\n    document_styles: list[list[str]] = []\n\n    # We manually set all text to have an alignment-baseline of\n    # text-after-edge to avoid block characters rendering in the\n    # wrong place (not at the top of their \"box\"), but with that\n    # our background rects will be rendered in the wrong place too,\n    # so this is used to offset that.\n    baseline_offset = 0.17 * FONT_HEIGHT\n\n    if isinstance(obj, Widget):\n        obj = \"\\n\".join(obj.get_lines())\n\n    elif isinstance(obj, StyledText):\n        obj = str(obj)\n\n    for plain in tim.group_styles(obj):\n        if \"\\x1b\" in plain.plain:\n            continue\n\n        should_newline = False\n\n        pos, back, styles = _handle_tokens_svg(plain, default_fore, default_back)\n\n        index = _generate_index_in(document_styles, styles)\n\n        if index == len(document_styles):\n            document_styles.append(styles)\n\n        style_attr = (\n            f\"class='{prefix}' style='{';'.join(styles)}'\"\n            if inline_styles\n            else f\"class='{prefix} {_get_cls(prefix, index)}'\"\n        )\n\n        # Manual positioning\n        if pos is not None:\n            cursor_x = pos[0] * FONT_WIDTH - 10\n            cursor_y = pos[1] * FONT_HEIGHT - 15\n\n        for line in plain.plain.splitlines():\n            text_len = len(line) * FONT_WIDTH\n\n            if should_newline:\n                cursor_y += FONT_HEIGHT\n                cursor_x = 0\n\n                lines += 1\n                if lines &gt; terminal.height:\n                    break\n\n            text += _make_tag(\n                \"rect\",\n                x=cursor_x,\n                y=cursor_y - (baseline_offset if not _is_block(line) else 0),\n                fill=back or default_back,\n                width=round(text_len * 1.02, 4),\n                height=round(FONT_HEIGHT * 1.08, 4),\n            )\n\n            text += _make_tag(\n                \"text\",\n                _escape_text(line),\n                dy=\"-0.25em\",\n                x=cursor_x,\n                y=cursor_y + FONT_SIZE,\n                textLength=text_len,\n                raw=style_attr,\n            )\n\n            cursor_x += text_len\n            should_newline = True\n\n        if lines &gt; terminal.height:\n            break\n\n        if plain.plain.endswith(\"\\n\"):\n            cursor_y += FONT_HEIGHT\n            cursor_x = 0\n\n            lines += 1\n\n    stylesheet = \"\" if inline_styles else _generate_stylesheet(document_styles, prefix)\n\n    terminal_width = round(terminal.width * FONT_WIDTH + 2 * TEXT_MARGIN_LEFT, 4)\n    terminal_height = round(\n        terminal.height * FONT_HEIGHT + (2 if chrome else 1) * TEXT_MARGIN_TOP, 4\n    )\n\n    total_width = terminal_width + (2 * SVG_MARGIN_LEFT if chrome else 0)\n    total_height = terminal_height + (2 * SVG_MARGIN_TOP if chrome else 0)\n\n    if chrome:\n        transform = (\n            f\"translate({TEXT_MARGIN_LEFT + SVG_MARGIN_LEFT}, \"\n            + f\"{TEXT_MARGIN_TOP + SVG_MARGIN_TOP})\"\n        )\n\n        chrome_part = f\"\"\"&lt;g&gt;\n            &lt;rect x=\"{SVG_MARGIN_LEFT}\" y=\"{SVG_MARGIN_TOP}\"\n                rx=\"9px\" ry=\"9px\" stroke-width=\"1px\" stroke-linejoin=\"round\"\n                width=\"{terminal_width}\" height=\"{terminal_height}\" fill=\"{default_back}\" /&gt;\n            &lt;circle cx=\"{SVG_MARGIN_LEFT+15}\" cy=\"{SVG_MARGIN_TOP + 15}\" r=\"6\" fill=\"#ff6159\"/&gt;\n            &lt;circle cx=\"{SVG_MARGIN_LEFT+35}\" cy=\"{SVG_MARGIN_TOP + 15}\" r=\"6\" fill=\"#ffbd2e\"/&gt;\n            &lt;circle cx=\"{SVG_MARGIN_LEFT+55}\" cy=\"{SVG_MARGIN_TOP + 15}\" r=\"6\" fill=\"#28c941\"/&gt;\n            &lt;text x=\"{terminal_width // 2}\" y=\"{SVG_MARGIN_TOP + FONT_HEIGHT}\" text-anchor=\"middle\"\n                class=\"{prefix}-title\"&gt;{title}&lt;/text&gt;\n        &lt;/g&gt;\n        \"\"\"\n\n    else:\n        transform = \"translate(16, 16)\"\n\n        chrome_part = f\"\"\"&lt;rect width=\"{total_width}\" height=\"{total_height}\"\n            fill=\"{default_back}\" /&gt;\"\"\"\n\n    output = _make_tag(\"g\", text, transform=transform) + \"\\n\"\n\n    return prettify_xml(\n        formatter.format(\n            # Dimensions\n            total_width=round(total_width, 4),\n            total_height=round(total_height, 4),\n            terminal_width=terminal_width * 1.02,\n            terminal_height=terminal_height - 15,\n            # Styles\n            background=default_back,\n            stylesheet=stylesheet,\n            # Code\n            code=output,\n            prefix=prefix,\n            chrome=chrome_part,\n        )\n    )\n</code></pre>"},{"location":"reference/pytermgui/exporters/#pytermgui.exporters.token_to_css","title":"<code>token_to_css(token, invert=False)</code>","text":"<p>Finds the CSS representation of a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The token to represent.</p> required <code>invert</code> <code>bool</code> <p>If set, the role of background &amp; foreground colors are flipped.</p> <code>False</code> Source code in <code>pytermgui/exporters.py</code> <pre><code>def token_to_css(token: Token, invert: bool = False) -&gt; str:\n\"\"\"Finds the CSS representation of a token.\n\n    Args:\n        token: The token to represent.\n        invert: If set, the role of background &amp; foreground colors\n            are flipped.\n    \"\"\"\n\n    if Token.is_color(token):\n        color = token.color\n\n        style = \"color:\" + color.hex\n\n        if invert:\n            color.background = not color.background\n\n        if color.background:\n            style = \"background-\" + style\n\n        return style\n\n    if token.is_style() and token.value in _STYLE_TO_CSS:\n        return _STYLE_TO_CSS[token.value]\n\n    return \"\"\n</code></pre>"},{"location":"reference/pytermgui/fancy_repr/","title":"fancy_repr","text":"<p>The <code>__fancy_repl__</code> protocol.</p>"},{"location":"reference/pytermgui/fancy_repr/#pytermgui.fancy_repr.SupportsFancyRepr","title":"<code>SupportsFancyRepr</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>An object that supports the <code>__fancy_repr__</code> dunder.</p> Source code in <code>pytermgui/fancy_repr.py</code> <pre><code>class SupportsFancyRepr(Protocol):  # pylint: disable=too-few-public-methods\n\"\"\"An object that supports the `__fancy_repr__` dunder.\"\"\"\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields some fancy text.\n\n        Each value yielded can be one of two types. If a dictionary is yielded,\n        it will be assumed to have `text` and `highlight` fields. `text` will be\n        the string included in the repr, and `highlight` will be a boolean describing\n        whether the part should be highlighted. At the moment highlighting is done by\n        `highlight_python`, but this might be configurable once more highlighters are\n        available.\n\n        If a `str` is yielded, it is assumed to be a shorthand for:\n\n            {\"text\": &lt;your_text&gt;, \"highlight\": True}\n        \"\"\"\n</code></pre>"},{"location":"reference/pytermgui/fancy_repr/#pytermgui.fancy_repr.SupportsFancyRepr.__fancy_repr__","title":"<code>__fancy_repr__()</code>","text":"<p>Yields some fancy text.</p> <p>Each value yielded can be one of two types. If a dictionary is yielded, it will be assumed to have <code>text</code> and <code>highlight</code> fields. <code>text</code> will be the string included in the repr, and <code>highlight</code> will be a boolean describing whether the part should be highlighted. At the moment highlighting is done by <code>highlight_python</code>, but this might be configurable once more highlighters are available.</p> <p>If a <code>str</code> is yielded, it is assumed to be a shorthand for:</p> <pre><code>{\"text\": &lt;your_text&gt;, \"highlight\": True}\n</code></pre> Source code in <code>pytermgui/fancy_repr.py</code> <pre><code>def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields some fancy text.\n\n    Each value yielded can be one of two types. If a dictionary is yielded,\n    it will be assumed to have `text` and `highlight` fields. `text` will be\n    the string included in the repr, and `highlight` will be a boolean describing\n    whether the part should be highlighted. At the moment highlighting is done by\n    `highlight_python`, but this might be configurable once more highlighters are\n    available.\n\n    If a `str` is yielded, it is assumed to be a shorthand for:\n\n        {\"text\": &lt;your_text&gt;, \"highlight\": True}\n    \"\"\"\n</code></pre>"},{"location":"reference/pytermgui/fancy_repr/#pytermgui.fancy_repr.build_fancy_repr","title":"<code>build_fancy_repr(obj)</code>","text":"<p>Interprets objects with the <code>__fancy_repr__</code> protocol.</p> Source code in <code>pytermgui/fancy_repr.py</code> <pre><code>def build_fancy_repr(obj: SupportsFancyRepr) -&gt; str:\n\"\"\"Interprets objects with the `__fancy_repr__` protocol.\"\"\"\n\n    output = \"\"\n    for item in obj.__fancy_repr__():\n        if isinstance(item, str):\n            output += highlight_python(item)\n            continue\n\n        text = item[\"text\"]\n        assert isinstance(text, str)\n\n        highlight = item[\"highlight\"]\n\n        if highlight:\n            text = highlight_python(text)\n\n        output += text\n\n    return output\n</code></pre>"},{"location":"reference/pytermgui/fancy_repr/#pytermgui.fancy_repr.supports_fancy_repr","title":"<code>supports_fancy_repr(obj)</code>","text":"<p>Determines whether the given object supports the fancy repl protocol.</p> Source code in <code>pytermgui/fancy_repr.py</code> <pre><code>def supports_fancy_repr(obj: object) -&gt; bool:\n\"\"\"Determines whether the given object supports the fancy repl protocol.\"\"\"\n\n    return hasattr(obj, \"__fancy_repr__\") and not isinstance(obj, type)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/","title":"file_loaders","text":""},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders--description","title":"Description","text":"<p>This module provides the library with the capability to load files into Widget-s.</p> <p>It provides a FileLoader base class, which is then subclassed by various filetype- specific parsers with their own <code>parse</code> method. The job of this method is to take the file contents as a string, and create a valid json tree out of it.</p> <p>You can \"run\" a PTG YAML file by calling <code>ptg -f &lt;filename&gt;</code> in your terminal.</p> <p>To use any YAML related features, the optional dependency PyYAML is required.</p>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders--implementation-details","title":"Implementation details","text":"<p>The main method of these classes is <code>load</code>, which takes a file-like object or a string, parses it and returns a <code>WidgetNamespace</code> instance. This can then be used to access all custom <code>Widget</code> definitions in the datafile.</p> <p>This module highly depends on the <code>serializer</code> module. Each file loader uses its own <code>Serializer</code> instance, but optionally take a pre-instantiated Serializer at construction. As with that module, this one depends on it \"knowing\" all types of Widget-s you are loading. If you have custom Widget subclass you would like to use in file-based definitions, use the <code>FileLoader.register</code> method, passing in your custom class as the sole argument.</p>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders--file-structure","title":"File structure","text":"<p>Regardless of filetype, all loaded files must follow a specific structure:</p> <pre><code>root\n|- config\n|   |_ custom global widget configuration\n|\n|- markup\n|   |_ custom markup definitions\n|\n|- boxes\n|   |_ custom box definitions\n|\n|_ widgets\n    |_ custom widget definitions\n</code></pre> <p>The loading follows the order config -&gt; markup -&gt; boxes -&gt; widgets. It is not necessary to provide all sections.</p>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders--example-of-usage","title":"Example of usage","text":"<pre><code># -- data.yaml --\n\nmarkup:\nlabel-style: '141 @61 bold'\n\nboxes:\nWINDOW_BOX: [\n\"left --- right\",\n\"left x right\",\n\"left --- right\",\n]\n\nconfig:\nWindow:\nstyles:\nborder: '[@79]{item}'\nbox: SINGLE\n\nLabel:\nstyles:\nvalue: '[label-style]{item}'\n\nwidgets:\nMyWindow:\ntype: Window\nbox: WINDOW_BOX\nwidgets:\nLabel:\nvalue: '[210 bold]This is a title'\n\nLabel: {}\n\nSplitter:\nwidgets:\n- Label:\nparent_align: 0\nvalue: 'This is an option'\n\n- Button:\nlabel: \"Press me!\"\n\nLabel: {}\nLabel:\nvalue: '[label-style]{item}'\n</code></pre> <pre><code># -- loader.py --\n\nimport pytermgui as ptg\n\nwith ptg.YamlLoader() as loader, open(\"data.yaml\", \"r\") as datafile:\n    namespace = loader.load(datafile)\n\nwith ptg.WindowManager() as manager:\n    manager.add(namespace.MyWindow)\n    manager.run()\n\n# Alternatively, one could run `ptg -f \"data.yaml\"` to display all widgets defined.\n# See `ptg -h`.\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader","title":"<code>FileLoader</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for file loader objects.</p> <p>These allow users to load pytermgui content from a specific filetype, with each filetype having their own loaders.</p> <p>To use custom widgets with children of this class, you need to call <code>FileLoader.register</code>.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>class FileLoader(ABC):\n\"\"\"Base class for file loader objects.\n\n    These allow users to load pytermgui content from a specific filetype,\n    with each filetype having their own loaders.\n\n    To use custom widgets with children of this class, you need to call `FileLoader.register`.\"\"\"\n\n    serializer: Serializer\n\"\"\"Object-specific serializer instance. In order to use a specific, already created\n    instance you need to pass it on `FileLoader` construction.\"\"\"\n\n    @abstractmethod\n    def parse(self, data: str) -&gt; dict[Any, Any]:\n\"\"\"Parses string into a dictionary used by `pytermgui.serializer.Serializer`.\n\n        This dictionary follows the structure defined above.\n        \"\"\"\n\n    def __init__(self, serializer: Serializer | None = None) -&gt; None:\n\"\"\"Initialize FileLoader.\n\n        Args:\n            serializer: An optional `pytermgui.serializer.Serializer` instance. If not provided, one\n                is instantiated for every FileLoader instance.\n        \"\"\"\n\n        if serializer is None:\n            serializer = Serializer()\n\n        self.serializer = serializer\n\n    def __enter__(self) -&gt; FileLoader:\n\"\"\"Starts context manager.\"\"\"\n\n        return self\n\n    def __exit__(self, _: Any, exception: Exception, __: Any) -&gt; bool:\n\"\"\"Ends context manager.\"\"\"\n\n        if exception is not None:\n            raise exception\n\n    def register(self, cls: Type[widgets_m.Widget]) -&gt; None:\n\"\"\"Registers a widget to the serializer.\n\n        Args:\n            cls: The widget type to register.\n        \"\"\"\n\n        self.serializer.register(cls)\n\n    def bind(self, name: str, method: Callable[..., Any]) -&gt; None:\n\"\"\"Binds a name to a method.\n\n        Args:\n            name: The name of the method, as referenced in the loaded\n                files.\n            method: The callable to bind.\n        \"\"\"\n\n        self.serializer.bind(name, method)\n\n    def load_str(self, data: str) -&gt; WidgetNamespace:\n\"\"\"Creates a `WidgetNamespace` from string data.\n\n        To parse the data, we use `FileLoader.parse`. To implement custom formats,\n        subclass `FileLoader` with your own `parse` implementation.\n\n        Args:\n            data: The data to parse.\n\n        Returns:\n            A WidgetNamespace created from the provided data.\n        \"\"\"\n\n        parsed = self.parse(data)\n\n        # Get &amp; load config data\n        config_data = parsed.get(\"config\")\n        if config_data is not None:\n            namespace = WidgetNamespace.from_config(config_data, loader=self)\n        else:\n            namespace = WidgetNamespace.from_config({}, loader=self)\n\n        # Create aliases\n        for key, value in (parsed.get(\"markup\") or {}).items():\n            tim.alias(key, value)\n\n        # Create boxes\n        for name, inner in (parsed.get(\"boxes\") or {}).items():\n            self.serializer.register_box(name, widgets_m.boxes.Box(inner))\n\n        # Create widgets\n        for name, inner in (parsed.get(\"widgets\") or {}).items():\n            widget_type = inner.get(\"type\") or name\n\n            box_name = inner.get(\"box\")\n\n            box = None\n            if box_name is not None and box_name in namespace.boxes:\n                box = namespace.boxes[box_name]\n                del inner[\"box\"]\n\n            try:\n                namespace.widgets[name] = self.serializer.from_dict(\n                    inner, widget_type=widget_type\n                )\n            except AttributeError as error:\n                raise ValueError(\n                    f'Could not load \"{name}\" from data:\\n{json.dumps(inner, indent=2)}'\n                ) from error\n\n            if box is not None:\n                namespace.widgets[name].box = box\n\n        return namespace\n\n    def load(self, data: str | IO) -&gt; WidgetNamespace:\n\"\"\"Loads data from a string or a file.\n\n        When an IO object is passed, its data is extracted as a string.\n        This string can then be passed to `load_str`.\n\n        Args:\n            data: Either a string or file stream to load data from.\n\n        Returns:\n            A WidgetNamespace with the data loaded.\n        \"\"\"\n\n        if not isinstance(data, str):\n            data = data.read()\n\n        assert isinstance(data, str)\n        return self.load_str(data)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.serializer","title":"<code>serializer: Serializer = serializer</code>  <code>instance-attribute</code>","text":"<p>Object-specific serializer instance. In order to use a specific, already created instance you need to pass it on <code>FileLoader</code> construction.</p>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.__enter__","title":"<code>__enter__()</code>","text":"<p>Starts context manager.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def __enter__(self) -&gt; FileLoader:\n\"\"\"Starts context manager.\"\"\"\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.__exit__","title":"<code>__exit__(_, exception, __)</code>","text":"<p>Ends context manager.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def __exit__(self, _: Any, exception: Exception, __: Any) -&gt; bool:\n\"\"\"Ends context manager.\"\"\"\n\n    if exception is not None:\n        raise exception\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.__init__","title":"<code>__init__(serializer=None)</code>","text":"<p>Initialize FileLoader.</p> <p>Parameters:</p> Name Type Description Default <code>serializer</code> <code>Serializer | None</code> <p>An optional <code>pytermgui.serializer.Serializer</code> instance. If not provided, one is instantiated for every FileLoader instance.</p> <code>None</code> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def __init__(self, serializer: Serializer | None = None) -&gt; None:\n\"\"\"Initialize FileLoader.\n\n    Args:\n        serializer: An optional `pytermgui.serializer.Serializer` instance. If not provided, one\n            is instantiated for every FileLoader instance.\n    \"\"\"\n\n    if serializer is None:\n        serializer = Serializer()\n\n    self.serializer = serializer\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.bind","title":"<code>bind(name, method)</code>","text":"<p>Binds a name to a method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the method, as referenced in the loaded files.</p> required <code>method</code> <code>Callable[..., Any]</code> <p>The callable to bind.</p> required Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def bind(self, name: str, method: Callable[..., Any]) -&gt; None:\n\"\"\"Binds a name to a method.\n\n    Args:\n        name: The name of the method, as referenced in the loaded\n            files.\n        method: The callable to bind.\n    \"\"\"\n\n    self.serializer.bind(name, method)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.load","title":"<code>load(data)</code>","text":"<p>Loads data from a string or a file.</p> <p>When an IO object is passed, its data is extracted as a string. This string can then be passed to <code>load_str</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | IO</code> <p>Either a string or file stream to load data from.</p> required <p>Returns:</p> Type Description <code>WidgetNamespace</code> <p>A WidgetNamespace with the data loaded.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def load(self, data: str | IO) -&gt; WidgetNamespace:\n\"\"\"Loads data from a string or a file.\n\n    When an IO object is passed, its data is extracted as a string.\n    This string can then be passed to `load_str`.\n\n    Args:\n        data: Either a string or file stream to load data from.\n\n    Returns:\n        A WidgetNamespace with the data loaded.\n    \"\"\"\n\n    if not isinstance(data, str):\n        data = data.read()\n\n    assert isinstance(data, str)\n    return self.load_str(data)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.load_str","title":"<code>load_str(data)</code>","text":"<p>Creates a <code>WidgetNamespace</code> from string data.</p> <p>To parse the data, we use <code>FileLoader.parse</code>. To implement custom formats, subclass <code>FileLoader</code> with your own <code>parse</code> implementation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to parse.</p> required <p>Returns:</p> Type Description <code>WidgetNamespace</code> <p>A WidgetNamespace created from the provided data.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def load_str(self, data: str) -&gt; WidgetNamespace:\n\"\"\"Creates a `WidgetNamespace` from string data.\n\n    To parse the data, we use `FileLoader.parse`. To implement custom formats,\n    subclass `FileLoader` with your own `parse` implementation.\n\n    Args:\n        data: The data to parse.\n\n    Returns:\n        A WidgetNamespace created from the provided data.\n    \"\"\"\n\n    parsed = self.parse(data)\n\n    # Get &amp; load config data\n    config_data = parsed.get(\"config\")\n    if config_data is not None:\n        namespace = WidgetNamespace.from_config(config_data, loader=self)\n    else:\n        namespace = WidgetNamespace.from_config({}, loader=self)\n\n    # Create aliases\n    for key, value in (parsed.get(\"markup\") or {}).items():\n        tim.alias(key, value)\n\n    # Create boxes\n    for name, inner in (parsed.get(\"boxes\") or {}).items():\n        self.serializer.register_box(name, widgets_m.boxes.Box(inner))\n\n    # Create widgets\n    for name, inner in (parsed.get(\"widgets\") or {}).items():\n        widget_type = inner.get(\"type\") or name\n\n        box_name = inner.get(\"box\")\n\n        box = None\n        if box_name is not None and box_name in namespace.boxes:\n            box = namespace.boxes[box_name]\n            del inner[\"box\"]\n\n        try:\n            namespace.widgets[name] = self.serializer.from_dict(\n                inner, widget_type=widget_type\n            )\n        except AttributeError as error:\n            raise ValueError(\n                f'Could not load \"{name}\" from data:\\n{json.dumps(inner, indent=2)}'\n            ) from error\n\n        if box is not None:\n            namespace.widgets[name].box = box\n\n    return namespace\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.parse","title":"<code>parse(data)</code>  <code>abstractmethod</code>","text":"<p>Parses string into a dictionary used by <code>pytermgui.serializer.Serializer</code>.</p> <p>This dictionary follows the structure defined above.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>@abstractmethod\ndef parse(self, data: str) -&gt; dict[Any, Any]:\n\"\"\"Parses string into a dictionary used by `pytermgui.serializer.Serializer`.\n\n    This dictionary follows the structure defined above.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.FileLoader.register","title":"<code>register(cls)</code>","text":"<p>Registers a widget to the serializer.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[widgets_m.Widget]</code> <p>The widget type to register.</p> required Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def register(self, cls: Type[widgets_m.Widget]) -&gt; None:\n\"\"\"Registers a widget to the serializer.\n\n    Args:\n        cls: The widget type to register.\n    \"\"\"\n\n    self.serializer.register(cls)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.JsonLoader","title":"<code>JsonLoader</code>","text":"<p>             Bases: <code>FileLoader</code></p> <p>JSON specific loader subclass.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>class JsonLoader(FileLoader):\n\"\"\"JSON specific loader subclass.\"\"\"\n\n    def parse(self, data: str) -&gt; dict[Any, Any]:\n\"\"\"Parse JSON str.\n\n        Args:\n            data: JSON formatted string.\n\n        Returns:\n            Loadable dictionary.\n        \"\"\"\n\n        return json.loads(data)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.JsonLoader.parse","title":"<code>parse(data)</code>","text":"<p>Parse JSON str.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>JSON formatted string.</p> required <p>Returns:</p> Type Description <code>dict[Any, Any]</code> <p>Loadable dictionary.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def parse(self, data: str) -&gt; dict[Any, Any]:\n\"\"\"Parse JSON str.\n\n    Args:\n        data: JSON formatted string.\n\n    Returns:\n        Loadable dictionary.\n    \"\"\"\n\n    return json.loads(data)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace","title":"<code>WidgetNamespace</code>  <code>dataclass</code>","text":"<p>Class to hold data on loaded namespace.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>@dataclass\nclass WidgetNamespace:\n\"\"\"Class to hold data on loaded namespace.\"\"\"\n\n    # No clue why `widgets` is seen as undefined here,\n    # but not in the code below. It only seems to happen\n    # in certain pylint configs as well.\n    config: dict[\n        Type[widgets_m.Widget], dict[str, Any]  # pylint: disable=undefined-variable\n    ]\n    widgets: dict[str, widgets_m.Widget]\n    boxes: dict[str, widgets_m.boxes.Box] = field(default_factory=dict)\n\n    @classmethod\n    def from_config(cls, data: dict[Any, Any], loader: FileLoader) -&gt; WidgetNamespace:\n\"\"\"Creates a namespace from config data.\n\n        Args:\n            data: A dictionary of config data.\n            loader: The `FileLoader` instance that should be used.\n\n        Returns:\n            A new WidgetNamespace with the given config.\n        \"\"\"\n\n        namespace = WidgetNamespace({}, {})\n        for name, config in data.items():\n            obj = loader.serializer.known_widgets.get(name)\n            if obj is None:\n                raise KeyError(f\"Unknown widget type {name}.\")\n\n            namespace.config[obj] = {\n                \"styles\": obj.styles,\n                \"chars\": obj.chars.copy(),\n            }\n\n            for category, inner in config.items():\n                value: str | widgets_m.styles.MarkupFormatter\n\n                if category not in namespace.config[obj]:\n                    setattr(obj, category, inner)\n                    continue\n\n                for key, value in inner.items():\n                    namespace.config[obj][category][key] = value\n\n        namespace.apply_config()\n        return namespace\n\n    @staticmethod\n    def _apply_section(\n        widget: Type[widgets_m.Widget], title: str, section: dict[str, str]\n    ) -&gt; None:\n\"\"\"Applies configuration section to the widget.\"\"\"\n\n        for key, value in section.items():\n            if title == \"styles\":\n                widget.set_style(key, value)\n                continue\n\n            widget.set_char(key, value)\n\n    def apply_to(self, widget: widgets_m.Widget) -&gt; None:\n\"\"\"Applies namespace config to the widget.\n\n        Args:\n            widget: The widget in question.\n        \"\"\"\n\n        def _apply_sections(\n            data: dict[str, dict[str, str]], widget: widgets_m.Widget\n        ) -&gt; None:\n\"\"\"Applies sections from data to the widget.\"\"\"\n\n            for title, section in data.items():\n                self._apply_section(type(widget), title, section)\n\n        data = self.config.get(type(widget))\n        if data is None:\n            return\n\n        _apply_sections(data, widget)\n\n        if hasattr(widget, \"_widgets\"):\n            for inner in widget:\n                inner_section = self.config.get(type(inner))\n\n                if inner_section is None:\n                    continue\n\n                _apply_sections(inner_section, inner)\n\n    def apply_config(self) -&gt; None:\n\"\"\"Apply self.config to current namespace.\"\"\"\n\n        for widget, settings in self.config.items():\n            for title, section in settings.items():\n                self._apply_section(widget, title, section)\n\n    def __getattr__(self, attr: str) -&gt; widgets_m.Widget:\n\"\"\"Get widget by name from widget list.\"\"\"\n\n        if attr in self.widgets:\n            return self.widgets[attr]\n\n        return self.__dict__[attr]\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace.__getattr__","title":"<code>__getattr__(attr)</code>","text":"<p>Get widget by name from widget list.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def __getattr__(self, attr: str) -&gt; widgets_m.Widget:\n\"\"\"Get widget by name from widget list.\"\"\"\n\n    if attr in self.widgets:\n        return self.widgets[attr]\n\n    return self.__dict__[attr]\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace.apply_config","title":"<code>apply_config()</code>","text":"<p>Apply self.config to current namespace.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def apply_config(self) -&gt; None:\n\"\"\"Apply self.config to current namespace.\"\"\"\n\n    for widget, settings in self.config.items():\n        for title, section in settings.items():\n            self._apply_section(widget, title, section)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace.apply_to","title":"<code>apply_to(widget)</code>","text":"<p>Applies namespace config to the widget.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>widgets_m.Widget</code> <p>The widget in question.</p> required Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def apply_to(self, widget: widgets_m.Widget) -&gt; None:\n\"\"\"Applies namespace config to the widget.\n\n    Args:\n        widget: The widget in question.\n    \"\"\"\n\n    def _apply_sections(\n        data: dict[str, dict[str, str]], widget: widgets_m.Widget\n    ) -&gt; None:\n\"\"\"Applies sections from data to the widget.\"\"\"\n\n        for title, section in data.items():\n            self._apply_section(type(widget), title, section)\n\n    data = self.config.get(type(widget))\n    if data is None:\n        return\n\n    _apply_sections(data, widget)\n\n    if hasattr(widget, \"_widgets\"):\n        for inner in widget:\n            inner_section = self.config.get(type(inner))\n\n            if inner_section is None:\n                continue\n\n            _apply_sections(inner_section, inner)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.WidgetNamespace.from_config","title":"<code>from_config(data, loader)</code>  <code>classmethod</code>","text":"<p>Creates a namespace from config data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[Any, Any]</code> <p>A dictionary of config data.</p> required <code>loader</code> <code>FileLoader</code> <p>The <code>FileLoader</code> instance that should be used.</p> required <p>Returns:</p> Type Description <code>WidgetNamespace</code> <p>A new WidgetNamespace with the given config.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>@classmethod\ndef from_config(cls, data: dict[Any, Any], loader: FileLoader) -&gt; WidgetNamespace:\n\"\"\"Creates a namespace from config data.\n\n    Args:\n        data: A dictionary of config data.\n        loader: The `FileLoader` instance that should be used.\n\n    Returns:\n        A new WidgetNamespace with the given config.\n    \"\"\"\n\n    namespace = WidgetNamespace({}, {})\n    for name, config in data.items():\n        obj = loader.serializer.known_widgets.get(name)\n        if obj is None:\n            raise KeyError(f\"Unknown widget type {name}.\")\n\n        namespace.config[obj] = {\n            \"styles\": obj.styles,\n            \"chars\": obj.chars.copy(),\n        }\n\n        for category, inner in config.items():\n            value: str | widgets_m.styles.MarkupFormatter\n\n            if category not in namespace.config[obj]:\n                setattr(obj, category, inner)\n                continue\n\n            for key, value in inner.items():\n                namespace.config[obj][category][key] = value\n\n    namespace.apply_config()\n    return namespace\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.YamlLoader","title":"<code>YamlLoader</code>","text":"<p>             Bases: <code>FileLoader</code></p> <p>YAML specific loader subclass.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>class YamlLoader(FileLoader):\n\"\"\"YAML specific loader subclass.\"\"\"\n\n    def __init__(self, serializer: Serializer | None = None) -&gt; None:\n\"\"\"Initialize object, check for installation of PyYAML.\"\"\"\n\n        if YAML_ERROR is not None:\n            raise RuntimeError(\n                \"YAML implementation module not found. Please install `PyYAML` to use `YamlLoader`.\"\n            ) from YAML_ERROR\n\n        super().__init__()\n\n    def parse(self, data: str) -&gt; dict[Any, Any]:\n\"\"\"Parse YAML str.\n\n        Args:\n            data: YAML formatted string.\n\n        Returns:\n            Loadable dictionary.\n        \"\"\"\n\n        assert yaml is not None\n        return yaml.safe_load(data)\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.YamlLoader.__init__","title":"<code>__init__(serializer=None)</code>","text":"<p>Initialize object, check for installation of PyYAML.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def __init__(self, serializer: Serializer | None = None) -&gt; None:\n\"\"\"Initialize object, check for installation of PyYAML.\"\"\"\n\n    if YAML_ERROR is not None:\n        raise RuntimeError(\n            \"YAML implementation module not found. Please install `PyYAML` to use `YamlLoader`.\"\n        ) from YAML_ERROR\n\n    super().__init__()\n</code></pre>"},{"location":"reference/pytermgui/file_loaders/#pytermgui.file_loaders.YamlLoader.parse","title":"<code>parse(data)</code>","text":"<p>Parse YAML str.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>YAML formatted string.</p> required <p>Returns:</p> Type Description <code>dict[Any, Any]</code> <p>Loadable dictionary.</p> Source code in <code>pytermgui/file_loaders.py</code> <pre><code>def parse(self, data: str) -&gt; dict[Any, Any]:\n\"\"\"Parse YAML str.\n\n    Args:\n        data: YAML formatted string.\n\n    Returns:\n        Loadable dictionary.\n    \"\"\"\n\n    assert yaml is not None\n    return yaml.safe_load(data)\n</code></pre>"},{"location":"reference/pytermgui/helpers/","title":"helpers","text":"<p>Helper methods and functions for pytermgui.</p>"},{"location":"reference/pytermgui/helpers/#pytermgui.helpers.break_line","title":"<code>break_line(line, limit, non_first_limit=None, fill=None)</code>","text":"<p>Breaks a line into a <code>list[str]</code> with maximum <code>limit</code> length per line.</p> <p>It keeps ongoing ANSI sequences between lines, and inserts a reset sequence at the end of each style-containing line.</p> <p>At the moment it splits strings exactly on the limit, and not on word boundaries. That functionality would be preferred, so it will end up being implemented at some point.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The line to split. May or may not contain ANSI sequences.</p> required <code>limit</code> <code>int</code> <p>The maximum amount of characters allowed in each line, excluding non-printing sequences.</p> required <code>non_first_limit</code> <code>int | None</code> <p>The limit after the first line. If not given, defaults to <code>limit</code>.</p> <code>None</code> Source code in <code>pytermgui/helpers.py</code> <pre><code>def break_line(  # pylint: disable=too-many-branches\n    line: str, limit: int, non_first_limit: int | None = None, fill: str | None = None\n) -&gt; Iterator[str]:\n\"\"\"Breaks a line into a `list[str]` with maximum `limit` length per line.\n\n    It keeps ongoing ANSI sequences between lines, and inserts a reset sequence\n    at the end of each style-containing line.\n\n    At the moment it splits strings exactly on the limit, and not on word\n    boundaries. That functionality would be preferred, so it will end up being\n    implemented at some point.\n\n    Args:\n        line: The line to split. May or may not contain ANSI sequences.\n        limit: The maximum amount of characters allowed in each line, excluding\n            non-printing sequences.\n        non_first_limit: The limit after the first line. If not given, defaults\n            to `limit`.\n    \"\"\"\n\n    if line in [\"\", \"\\x1b[0m\"]:\n        yield \"\"\n        return\n\n    def _pad_and_link(line: str, link: str | None) -&gt; str:\n        count = limit - real_length(line)\n\n        if link is not None:\n            line = LINK_TEMPLATE.format(uri=link, label=line)\n\n        if fill is None:\n            return line\n\n        line += count * fill\n\n        return line\n\n    used = 0\n    current = \"\"\n    sequences = \"\"\n\n    if non_first_limit is None:\n        non_first_limit = limit\n\n    parsers = PARSERS\n    link = None\n\n    for token in tokenize_ansi(line):\n        if token.is_plain():\n            for char in token.value:\n                if char == \"\\n\" or used &gt;= limit:\n                    if sequences != \"\":\n                        current += \"\\x1b[0m\"\n\n                    yield _pad_and_link(current, link)\n                    link = None\n\n                    current = sequences\n                    used = 0\n\n                    limit = non_first_limit\n\n                if char != \"\\n\":\n                    current += char\n                    used += 1\n\n            # If the link wasn't yielded along with its token, remove and add it\n            # to current manually.\n            if link is not None:\n                current = current[: -len(token.value)]\n                current += LINK_TEMPLATE.format(uri=link, label=token.value)\n                link = None\n\n            continue\n\n        if token.value == \"/\":\n            sequences = \"\\x1b[0m\"\n\n            if len(current) &gt; 0:\n                current += sequences\n\n            continue\n\n        if token.is_hyperlink():\n            link = token.value\n            continue\n\n        sequence = parsers[type(token)](token, {}, lambda: line)  # type: ignore\n        sequences += sequence\n        current += sequence\n\n    if current == \"\":\n        return\n\n    if sequences != \"\" and not current.endswith(\"\\x1b[0m\"):\n        current += \"\\x1b[0m\"\n\n    yield _pad_and_link(current, link)\n</code></pre>"},{"location":"reference/pytermgui/highlighters/","title":"highlighters","text":"<p>This module provides the <code>Highlighter</code> class, and some pre-configured instances.</p>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.Highlighter","title":"<code>Highlighter</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>The protocol for highlighters.</p> Source code in <code>pytermgui/highlighters.py</code> <pre><code>class Highlighter(Protocol):  # pylint: disable=too-few-public-methods\n\"\"\"The protocol for highlighters.\"\"\"\n\n    def __call__(self, text: str, cache: bool = True) -&gt; str:\n\"\"\"Highlights the given text.\n\n        Args:\n            text: The text to highlight.\n            cache: If set (default), results will be stored, keyed by their respective\n                inputs, and retrieved the next time the same key is given.\n        \"\"\"\n</code></pre>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.Highlighter.__call__","title":"<code>__call__(text, cache=True)</code>","text":"<p>Highlights the given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to highlight.</p> required <code>cache</code> <code>bool</code> <p>If set (default), results will be stored, keyed by their respective inputs, and retrieved the next time the same key is given.</p> <code>True</code> Source code in <code>pytermgui/highlighters.py</code> <pre><code>def __call__(self, text: str, cache: bool = True) -&gt; str:\n\"\"\"Highlights the given text.\n\n    Args:\n        text: The text to highlight.\n        cache: If set (default), results will be stored, keyed by their respective\n            inputs, and retrieved the next time the same key is given.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter","title":"<code>RegexHighlighter</code>  <code>dataclass</code>","text":"<p>A class to highlight strings using regular expressions.</p> <p>This class must be provided with a list of styles. These styles are really just a tuple of the markup alias name, and their associated RE patterns. If all aliases in the instance use the same prefix, it can be given under the <code>prefix</code> key and ommitted from the style names.</p> <p>On construction, the instance will combine all of its patterns into a monster regex including named capturing groups. The general format is something like:</p> <pre><code>(?P&lt;{name1}&gt;{pattern1})|(?P&lt;{name2}&gt;{pattern2})|...\n</code></pre> <p>Calling this instance will then replace all matches, going in the order of definition, with style-injected versions. These follow the format:</p> <pre><code>[{prefix?}{name}]{content}[/{prefix}{name}]\n</code></pre> <p>Oddities to keep in mind: - Regex replace goes in the order of the defined groups, and is non-overlapping. Two     groups cannot match the same text. - Because of how capturing groups work, everything within the patterns will be     matched. To look for context around a match, look-around assertions can be used.</p> Source code in <code>pytermgui/highlighters.py</code> <pre><code>@dataclass\nclass RegexHighlighter:\n\"\"\"A class to highlight strings using regular expressions.\n\n    This class must be provided with a list of styles. These styles are really just a\n    tuple of the markup alias name, and their associated RE patterns. If *all* aliases\n    in the instance use the same prefix, it can be given under the `prefix` key and\n    ommitted from the style names.\n\n    On construction, the instance will combine all of its patterns into a monster regex\n    including named capturing groups. The general format is something like:\n\n        (?P&lt;{name1}&gt;{pattern1})|(?P&lt;{name2}&gt;{pattern2})|...\n\n    Calling this instance will then replace all matches, going in the order of\n    definition, with style-injected versions. These follow the format:\n\n        [{prefix?}{name}]{content}[/{prefix}{name}]\n\n    Oddities to keep in mind:\n    - Regex replace goes in the order of the defined groups, and is non-overlapping. Two\n        groups cannot match the same text.\n    - Because of how capturing groups work, everything within the patterns will be\n        matched. To look for context around a match, look-around assertions can be used.\n    \"\"\"\n\n    styles: list[tuple[str, str]]\n\"\"\"A list of tuples of (style_alias, pattern_str).\"\"\"\n\n    prefix: str = \"\"\n\"\"\"Some string to insert before each style alias.\"\"\"\n\n    pre_formatter: Callable[[str], str] | None = None\n\"\"\"A callable that formats the input string, before any highlighting is done to it.\"\"\"\n\n    match_formatter: Callable[[Match, str], str] | None = None\n\"\"\"A callable of (match, content) that gets called on every match.\n\n    Its return value will be used as the content that the already set highlighting will apply\n    to. Useful to trim text, or apply other transformations before inserting it back.\n    \"\"\"\n\n    re_flags: int = 0\n\"\"\"All regex flags to apply when compiling the generated pattern, OR-d (|) together.\"\"\"\n\n    _pattern: Pattern = field(init=False)\n    _highlight_cache: dict[str, str] = field(init=False, default_factory=dict)\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Combines all styles into one pattern.\"\"\"\n\n        pattern = \"\"\n        names: list[str] = []\n        for name, ptrn in self.styles:\n            pattern += f\"(?P&lt;{name}&gt;{ptrn})|\"\n            names.append(name)\n\n        pattern = pattern[:-1]\n\n        self._pattern = re.compile(pattern, flags=self.re_flags)\n\n    def __call__(self, text: str, cache: bool = True) -&gt; str:\n\"\"\"Highlights the given text, using the combined regex pattern.\"\"\"\n\n        if self.pre_formatter is not None:\n            text = self.pre_formatter(text)\n\n        if cache and text in self._highlight_cache:\n            return self._highlight_cache[text]\n\n        cache_key = text\n\n        def _insert_style(matchobj: Match) -&gt; str:\n\"\"\"Returns the match inserted into a markup style.\"\"\"\n\n            groups = matchobj.groupdict()\n\n            name = matchobj.lastgroup\n            content = groups.get(str(name), None)\n\n            if self.match_formatter is not None:\n                content = self.match_formatter(matchobj, content)\n\n                if content == \"\":\n                    return \"\"\n\n            tag = f\"{self.prefix}{name}\"\n            style = f\"[{tag}]{{}}[/{tag}]\"\n\n            return style.format(content)\n\n        text = self._pattern.sub(_insert_style, text)\n        self._highlight_cache[cache_key] = text\n\n        return text\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields some fancy looking repr text.\"\"\"\n\n        preview = self(\"highlight_python()\") + \"\\x1b[0m\"\n        pattern = self._pattern.pattern\n\n        if len(pattern) &gt; 40:\n            pattern = pattern[:38] + \"...\"\n\n        yield f\"&lt;{type(self).__name__} pattern: {pattern!r}, preview: \"\n        yield {\"text\": str(preview), \"highlight\": False}\n\n        yield \"&gt;\"\n</code></pre>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.match_formatter","title":"<code>match_formatter: Callable[[Match, str], str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A callable of (match, content) that gets called on every match.</p> <p>Its return value will be used as the content that the already set highlighting will apply to. Useful to trim text, or apply other transformations before inserting it back.</p>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.pre_formatter","title":"<code>pre_formatter: Callable[[str], str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A callable that formats the input string, before any highlighting is done to it.</p>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.prefix","title":"<code>prefix: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Some string to insert before each style alias.</p>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.re_flags","title":"<code>re_flags: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All regex flags to apply when compiling the generated pattern, OR-d (|) together.</p>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.styles","title":"<code>styles: list[tuple[str, str]]</code>  <code>instance-attribute</code>","text":"<p>A list of tuples of (style_alias, pattern_str).</p>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.__call__","title":"<code>__call__(text, cache=True)</code>","text":"<p>Highlights the given text, using the combined regex pattern.</p> Source code in <code>pytermgui/highlighters.py</code> <pre><code>def __call__(self, text: str, cache: bool = True) -&gt; str:\n\"\"\"Highlights the given text, using the combined regex pattern.\"\"\"\n\n    if self.pre_formatter is not None:\n        text = self.pre_formatter(text)\n\n    if cache and text in self._highlight_cache:\n        return self._highlight_cache[text]\n\n    cache_key = text\n\n    def _insert_style(matchobj: Match) -&gt; str:\n\"\"\"Returns the match inserted into a markup style.\"\"\"\n\n        groups = matchobj.groupdict()\n\n        name = matchobj.lastgroup\n        content = groups.get(str(name), None)\n\n        if self.match_formatter is not None:\n            content = self.match_formatter(matchobj, content)\n\n            if content == \"\":\n                return \"\"\n\n        tag = f\"{self.prefix}{name}\"\n        style = f\"[{tag}]{{}}[/{tag}]\"\n\n        return style.format(content)\n\n    text = self._pattern.sub(_insert_style, text)\n    self._highlight_cache[cache_key] = text\n\n    return text\n</code></pre>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.__fancy_repr__","title":"<code>__fancy_repr__()</code>","text":"<p>Yields some fancy looking repr text.</p> Source code in <code>pytermgui/highlighters.py</code> <pre><code>def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields some fancy looking repr text.\"\"\"\n\n    preview = self(\"highlight_python()\") + \"\\x1b[0m\"\n    pattern = self._pattern.pattern\n\n    if len(pattern) &gt; 40:\n        pattern = pattern[:38] + \"...\"\n\n    yield f\"&lt;{type(self).__name__} pattern: {pattern!r}, preview: \"\n    yield {\"text\": str(preview), \"highlight\": False}\n\n    yield \"&gt;\"\n</code></pre>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.RegexHighlighter.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Combines all styles into one pattern.</p> Source code in <code>pytermgui/highlighters.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Combines all styles into one pattern.\"\"\"\n\n    pattern = \"\"\n    names: list[str] = []\n    for name, ptrn in self.styles:\n        pattern += f\"(?P&lt;{name}&gt;{ptrn})|\"\n        names.append(name)\n\n    pattern = pattern[:-1]\n\n    self._pattern = re.compile(pattern, flags=self.re_flags)\n</code></pre>"},{"location":"reference/pytermgui/highlighters/#pytermgui.highlighters.highlight_tim","title":"<code>highlight_tim(text, cache=True)</code>","text":"<p>Highlights some TIM code.</p> Source code in <code>pytermgui/highlighters.py</code> <pre><code>def highlight_tim(text: str, cache: bool = True) -&gt; str:\n\"\"\"Highlights some TIM code.\"\"\"\n\n    @lru_cache(1048)\n    def _highlight(txt: str) -&gt; str:\n        output = \"\"\n        cursor = 0\n        active_tokens: list[Token] = []\n\n        def _get_active_markup() -&gt; str:\n            active_markup = \" \".join(tkn.markup for tkn in active_tokens)\n\n            if active_markup == \"\":\n                return \"\"\n\n            return f\"[{active_markup}]\"\n\n        for matchobj in RE_MARKUP.finditer(txt):\n            start, end = matchobj.span()\n\n            if cursor &lt; start:\n                if cursor &gt; 0:\n                    output += \"]\"\n\n                output += _get_active_markup()\n                output += f\"{txt[cursor:start]}[/]\"\n\n            *_, tags = matchobj.groups()\n\n            output += \"[\"\n            for tag in tags.split():\n                token = consume_tag(tag)\n                output += f\"{token.prettified_markup} \"\n\n                if Token.is_clear(token):\n                    active_tokens = [\n                        tkn for tkn in active_tokens if not token.targets(tkn)\n                    ]\n\n                else:\n                    active_tokens.append(token)\n\n            output = output.rstrip()\n            cursor = end\n\n        if cursor &lt; len(txt) - 1:\n            if cursor &gt; 0:\n                output += \"]\"\n\n            output += _get_active_markup()\n            output += f\"{txt[cursor:]}\"\n\n            if len(active_tokens) &gt; 0:\n                output += \"[/]\"\n\n        if output.count(\"[\") != output.count(\"]\"):\n            output += \"]\"\n\n        return output\n\n    if cache:\n        return _highlight(text)\n\n    return _highlight.__wrapped__(text)\n</code></pre>"},{"location":"reference/pytermgui/input/","title":"input","text":"<p>File providing the getch() function to easily read character inputs.</p> <p>Credits:</p> <ul> <li>Original getch implementation: Danny Yoo</li> <li>Modern additions &amp; idea:       kcsaff</li> </ul> <p>Note that the original link seems to no longer be active, but an archive can be found on GitHub.</p>"},{"location":"reference/pytermgui/input/#pytermgui.input.keys","title":"<code>keys: Keys = Keys(_platform_keys, 'nt')</code>  <code>module-attribute</code>","text":"<p>Instance storing platform specific key codes.</p>"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys","title":"<code>Keys</code>","text":"<p>Class for easy access to key-codes.</p> <p>The keys for CTRL_{ascii_letter}-s can be generated with the following code:</p> <pre><code>for i, letter in enumerate(ascii_lowercase):\n    key = f\"CTRL_{letter.upper()}\"\n    code = chr(i+1).encode('unicode_escape').decode('utf-8')\n\n    print(key, code)\n</code></pre> Source code in <code>pytermgui/input.py</code> <pre><code>class Keys:\n\"\"\"Class for easy access to key-codes.\n\n    The keys for CTRL_{ascii_letter}-s can be generated with\n    the following code:\n\n    ```python3\n    for i, letter in enumerate(ascii_lowercase):\n        key = f\"CTRL_{letter.upper()}\"\n        code = chr(i+1).encode('unicode_escape').decode('utf-8')\n\n        print(key, code)\n    ```\n    \"\"\"\n\n    def __init__(self, platform_keys: dict[str, str], platform: str) -&gt; None:\n\"\"\"Initialize Keys object.\n\n        Args:\n            platform_keys: A dictionary of platform-specific keys.\n            platform: The platform the program is running on.\n        \"\"\"\n\n        self._keys = {\n            \"SPACE\": \" \",\n            \"ESC\": \"\\x1b\",\n            # The ALT character in key combinations is the same as ESC\n            \"ALT\": \"\\x1b\",\n            \"TAB\": \"\\t\",\n            \"ENTER\": \"\\n\",\n            \"RETURN\": \"\\n\",\n            \"CTRL_SPACE\": \"\\x00\",\n            \"CTRL_A\": \"\\x01\",\n            \"CTRL_B\": \"\\x02\",\n            \"CTRL_C\": \"\\x03\",\n            \"CTRL_D\": \"\\x04\",\n            \"CTRL_E\": \"\\x05\",\n            \"CTRL_F\": \"\\x06\",\n            \"CTRL_G\": \"\\x07\",\n            \"CTRL_H\": \"\\x08\",\n            \"CTRL_I\": \"\\t\",\n            \"CTRL_J\": \"\\n\",\n            \"CTRL_K\": \"\\x0b\",\n            \"CTRL_L\": \"\\x0c\",\n            \"CTRL_M\": \"\\r\",\n            \"CTRL_N\": \"\\x0e\",\n            \"CTRL_O\": \"\\x0f\",\n            \"CTRL_P\": \"\\x10\",\n            \"CTRL_Q\": \"\\x11\",\n            \"CTRL_R\": \"\\x12\",\n            \"CTRL_S\": \"\\x13\",\n            \"CTRL_T\": \"\\x14\",\n            \"CTRL_U\": \"\\x15\",\n            \"CTRL_V\": \"\\x16\",\n            \"CTRL_W\": \"\\x17\",\n            \"CTRL_X\": \"\\x18\",\n            \"CTRL_Y\": \"\\x19\",\n            \"CTRL_Z\": \"\\x1a\",\n        }\n\n        self.platform = platform\n\n        if platform_keys is not None:\n            for key, code in platform_keys.items():\n                if key == \"name\":\n                    self.name = code\n                    continue\n\n                self._keys[key] = code\n\n    def __getattr__(self, attr: str) -&gt; str:\n\"\"\"Gets attr from self._keys.\"\"\"\n\n        if attr == \"ANY_KEY\":\n            return attr\n\n        return self._keys.get(attr, \"\")\n\n    def get_name(self, key: str, default: Optional[str] = None) -&gt; Optional[str]:\n\"\"\"Gets canonical name of a key code.\n\n        Args:\n            key: The key to get the name of.\n            default: The return value to substitute if no canonical name could be\n                found. Defaults to None.\n\n        Returns:\n            The canonical name if one can be found, default otherwise.\n        \"\"\"\n\n        for name, value in self._keys.items():\n            if key == value:\n                return name\n\n        return default\n\n    def values(self) -&gt; ValuesView[str]:\n\"\"\"Returns values() of self._keys.\"\"\"\n\n        return self._keys.values()\n\n    def keys(self) -&gt; KeysView[str]:\n\"\"\"Returns keys() of self._keys.\"\"\"\n\n        return self._keys.keys()\n\n    def items(self) -&gt; ItemsView[str, str]:\n\"\"\"Returns items() of self._keys.\"\"\"\n\n        return self._keys.items()\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.__getattr__","title":"<code>__getattr__(attr)</code>","text":"<p>Gets attr from self._keys.</p> Source code in <code>pytermgui/input.py</code> <pre><code>def __getattr__(self, attr: str) -&gt; str:\n\"\"\"Gets attr from self._keys.\"\"\"\n\n    if attr == \"ANY_KEY\":\n        return attr\n\n    return self._keys.get(attr, \"\")\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.__init__","title":"<code>__init__(platform_keys, platform)</code>","text":"<p>Initialize Keys object.</p> <p>Parameters:</p> Name Type Description Default <code>platform_keys</code> <code>dict[str, str]</code> <p>A dictionary of platform-specific keys.</p> required <code>platform</code> <code>str</code> <p>The platform the program is running on.</p> required Source code in <code>pytermgui/input.py</code> <pre><code>def __init__(self, platform_keys: dict[str, str], platform: str) -&gt; None:\n\"\"\"Initialize Keys object.\n\n    Args:\n        platform_keys: A dictionary of platform-specific keys.\n        platform: The platform the program is running on.\n    \"\"\"\n\n    self._keys = {\n        \"SPACE\": \" \",\n        \"ESC\": \"\\x1b\",\n        # The ALT character in key combinations is the same as ESC\n        \"ALT\": \"\\x1b\",\n        \"TAB\": \"\\t\",\n        \"ENTER\": \"\\n\",\n        \"RETURN\": \"\\n\",\n        \"CTRL_SPACE\": \"\\x00\",\n        \"CTRL_A\": \"\\x01\",\n        \"CTRL_B\": \"\\x02\",\n        \"CTRL_C\": \"\\x03\",\n        \"CTRL_D\": \"\\x04\",\n        \"CTRL_E\": \"\\x05\",\n        \"CTRL_F\": \"\\x06\",\n        \"CTRL_G\": \"\\x07\",\n        \"CTRL_H\": \"\\x08\",\n        \"CTRL_I\": \"\\t\",\n        \"CTRL_J\": \"\\n\",\n        \"CTRL_K\": \"\\x0b\",\n        \"CTRL_L\": \"\\x0c\",\n        \"CTRL_M\": \"\\r\",\n        \"CTRL_N\": \"\\x0e\",\n        \"CTRL_O\": \"\\x0f\",\n        \"CTRL_P\": \"\\x10\",\n        \"CTRL_Q\": \"\\x11\",\n        \"CTRL_R\": \"\\x12\",\n        \"CTRL_S\": \"\\x13\",\n        \"CTRL_T\": \"\\x14\",\n        \"CTRL_U\": \"\\x15\",\n        \"CTRL_V\": \"\\x16\",\n        \"CTRL_W\": \"\\x17\",\n        \"CTRL_X\": \"\\x18\",\n        \"CTRL_Y\": \"\\x19\",\n        \"CTRL_Z\": \"\\x1a\",\n    }\n\n    self.platform = platform\n\n    if platform_keys is not None:\n        for key, code in platform_keys.items():\n            if key == \"name\":\n                self.name = code\n                continue\n\n            self._keys[key] = code\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.get_name","title":"<code>get_name(key, default=None)</code>","text":"<p>Gets canonical name of a key code.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to get the name of.</p> required <code>default</code> <code>Optional[str]</code> <p>The return value to substitute if no canonical name could be found. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The canonical name if one can be found, default otherwise.</p> Source code in <code>pytermgui/input.py</code> <pre><code>def get_name(self, key: str, default: Optional[str] = None) -&gt; Optional[str]:\n\"\"\"Gets canonical name of a key code.\n\n    Args:\n        key: The key to get the name of.\n        default: The return value to substitute if no canonical name could be\n            found. Defaults to None.\n\n    Returns:\n        The canonical name if one can be found, default otherwise.\n    \"\"\"\n\n    for name, value in self._keys.items():\n        if key == value:\n            return name\n\n    return default\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.items","title":"<code>items()</code>","text":"<p>Returns items() of self._keys.</p> Source code in <code>pytermgui/input.py</code> <pre><code>def items(self) -&gt; ItemsView[str, str]:\n\"\"\"Returns items() of self._keys.\"\"\"\n\n    return self._keys.items()\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.keys","title":"<code>keys()</code>","text":"<p>Returns keys() of self._keys.</p> Source code in <code>pytermgui/input.py</code> <pre><code>def keys(self) -&gt; KeysView[str]:\n\"\"\"Returns keys() of self._keys.\"\"\"\n\n    return self._keys.keys()\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.Keys.values","title":"<code>values()</code>","text":"<p>Returns values() of self._keys.</p> Source code in <code>pytermgui/input.py</code> <pre><code>def values(self) -&gt; ValuesView[str]:\n\"\"\"Returns values() of self._keys.\"\"\"\n\n    return self._keys.values()\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.feed","title":"<code>feed(text)</code>","text":"<p>Manually feeds some text to be read by <code>getch</code>.</p> <p>This can be used to emulate input, as well as to \"interrupt\" a blocking <code>getch</code> call (though <code>getch_timeout</code> works better for that scenario).</p> Source code in <code>pytermgui/input.py</code> <pre><code>def feed(text: str) -&gt; None:\n\"\"\"Manually feeds some text to be read by `getch`.\n\n    This can be used to emulate input, as well as to \"interrupt\" a blocking `getch`\n    call (though `getch_timeout` works better for that scenario).\n    \"\"\"\n\n    feeder_stream.write(text)\n    feeder_stream.seek(0)\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.getch","title":"<code>getch(printable=False, interrupts=True, windows_raise_timeout=False)</code>","text":"<p>Wrapper to call the platform-appropriate character getter.</p> <p>Parameters:</p> Name Type Description Default <code>printable</code> <code>bool</code> <p>When set, printable versions of the input are returned.</p> <code>False</code> <code>interrupts</code> <code>bool</code> <p>If not set, <code>KeyboardInterrupt</code> is silenced and <code>chr(3)</code> (<code>CTRL_C</code>) is returned.</p> <code>True</code> <code>windows_raise_timeout</code> <code>bool</code> <p>If set, <code>TimeoutException</code> (raised by Windows' getch when no input is available) isn't silenced.</p> <code>False</code> Source code in <code>pytermgui/input.py</code> <pre><code>def getch(\n    printable: bool = False,\n    interrupts: bool = True,\n    windows_raise_timeout: bool = False,\n) -&gt; str:\n\"\"\"Wrapper to call the platform-appropriate character getter.\n\n    Args:\n        printable: When set, printable versions of the input are returned.\n        interrupts: If not set, `KeyboardInterrupt` is silenced and `chr(3)` (`CTRL_C`)\n            is returned.\n        windows_raise_timeout: If set, `TimeoutException` (raised by Windows' getch when\n            no input is available) isn't silenced.\n    \"\"\"\n\n    fed_text = feeder_stream.getvalue()\n\n    if fed_text != \"\":\n        feeder_stream.seek(0)\n        feeder_stream.truncate(0)\n        return fed_text\n\n    try:\n        key = _getch()\n\n        # msvcrt.getch returns CTRL_C as a character, unlike UNIX systems\n        # where an interrupt is raised. Thus, we need to manually raise\n        # the interrupt.\n        if key == chr(3):\n            raise KeyboardInterrupt\n\n    except KeyboardInterrupt as error:\n        if interrupts:\n            raise KeyboardInterrupt(\"Unhandled interrupt\") from error\n\n        key = chr(3)\n\n    except TimeoutException:\n        if windows_raise_timeout:\n            raise\n\n        key = \"\"\n\n    if printable:\n        key = key.encode(\"unicode_escape\").decode(\"utf-8\")\n\n    return key\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.getch_timeout","title":"<code>getch_timeout(duration, default='', printable=False, interrupts=True)</code>","text":"<p>Calls <code>getch</code>, returns <code>default</code> if timeout passes before getting input.</p> <p>No timeout is applied on Windows systems, as there is no support for <code>SIGALRM</code>. Instead, it will return immediately if no input is provided, since the Windows APIs expose a way to detect that case.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>float</code> <p>How long the call should wait for input.</p> required <code>default</code> <code>str</code> <p>The value to return if timeout occured.</p> <code>''</code> Source code in <code>pytermgui/input.py</code> <pre><code>def getch_timeout(\n    duration: float, default: str = \"\", printable: bool = False, interrupts: bool = True\n) -&gt; Any:\n\"\"\"Calls `getch`, returns `default` if timeout passes before getting input.\n\n    No timeout is applied on Windows systems, as there is no support for\n    `SIGALRM`. Instead, it will return immediately if no input is provided, since the\n    Windows APIs expose a way to detect that case.\n\n    Args:\n        duration: How long the call should wait for input.\n        default: The value to return if timeout occured.\n    \"\"\"\n\n    if isinstance(_getch, _GetchWindows):\n        try:\n            return getch(windows_raise_timeout=True)\n\n        except TimeoutException:\n            return default\n\n    with timeout(duration):\n        return getch(printable=printable, interrupts=interrupts)\n\n    return default\n</code></pre>"},{"location":"reference/pytermgui/input/#pytermgui.input.timeout","title":"<code>timeout(duration)</code>","text":"<p>Allows context to run for a certain amount of time, quits it once it's up.</p> <p>Note that this should never be run on Windows, as the required signals are not present. Whenever this function is run, there should be a preliminary OS check, to avoid running into issues on unsupported machines.</p> Source code in <code>pytermgui/input.py</code> <pre><code>@contextmanager\ndef timeout(duration: float) -&gt; Generator[None, None, None]:\n\"\"\"Allows context to run for a certain amount of time, quits it once it's up.\n\n    Note that this should never be run on Windows, as the required signals are not\n    present. Whenever this function is run, there should be a preliminary OS check,\n    to avoid running into issues on unsupported machines.\n    \"\"\"\n\n    def _raise_timeout(*_, **__):\n        raise TimeoutException(\"The action has timed out.\")\n\n    try:\n        # set the timeout handler\n        signal.signal(signal.SIGALRM, _raise_timeout)\n        signal.setitimer(signal.ITIMER_REAL, duration)\n        yield\n\n    except TimeoutException:\n        pass\n\n    finally:\n        signal.alarm(0)\n</code></pre>"},{"location":"reference/pytermgui/inspector/","title":"inspector","text":"<p>This module provides introspection utilities.</p> <p>The <code>inspect</code> method can be used to create an <code>Inspector</code> widget, which can then be used to see what is happening inside any python object. This method is usually preferred for instantiating an <code>Inspector</code>, as it sets up overwriteable default arguments passed to the new widget.</p> <p>These defaults are meant to hide the non-important information when they are not needed, in order to allow the least amount of code for the most usability. For example, by default, when passed a class, <code>inspect</code> will clip the docstrings to their first lines, but show all methods. When an class' method is given it will hide show the full docstring, and also use the method's fully qualified name.</p>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector","title":"<code>Inspector</code>","text":"<p>             Bases: <code>Container</code></p> <p>A widget to inspect any Python object.</p> Source code in <code>pytermgui/inspector.py</code> <pre><code>class Inspector(Container):\n\"\"\"A widget to inspect any Python object.\"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        target: object = None,\n        show_private: bool = False,\n        show_dunder: bool = False,\n        show_methods: bool = False,\n        show_full_doc: bool = False,\n        show_qualname: bool = True,\n        show_header: bool = True,\n        **attrs: Any,\n    ):\n\"\"\"Initializes an inspector.\n\n        Note that most of the time, using `inspect` to do this is going to be more\n        useful.\n\n        Some styles of the inspector can be changed using the `code.name`,\n        `code.file` and `code.keyword` markup aliases. The rest of the\n        highlighting is done using `pprint`, with all of its respective colors.\n\n        Args:\n            show_private: Whether `_private` attributes should be shown.\n            show_dunder: Whether `__dunder__` attributes should be shown.\n            show_methods: Whether methods should be shown when encountering a class.\n            show_full_doc: If not set, docstrings are cut to only include their first\n                line.\n            show_qualname: Show fully-qualified name, e.g. `module.submodule.name`\n                instead of `name`.\n            show_header: If not set, the header containing the path to the object and\n                its qualname will not be added.\n        \"\"\"\n\n        if \"box\" not in attrs:\n            attrs[\"box\"] = \"EMPTY\"\n\n        super().__init__(**attrs)\n\n        self.width = self.terminal.width\n\n        self.show_private = show_private\n        self.show_dunder = show_dunder\n        self.show_methods = show_methods\n        self.show_full_doc = show_full_doc\n        self.show_qualname = show_qualname\n        self.show_header = show_header\n\n        # TODO: Fix attr-showing\n        self.show_attrs = False\n\n        self.target: object\n        if target is not None:\n            self.inspect(target)\n            self.target = target\n\n    def _get_header(self) -&gt; Container:\n\"\"\"Creates a header containing the name and location of the object.\"\"\"\n\n        header = Container(box=\"SINGLE\")\n\n        line = \"[code.name]\"\n        if self.target_type is ObjectType.MODULE:\n            line += self.target.__name__  # type: ignore\n\n        else:\n            cls = (\n                self.target\n                if isclass(self.target) or isfunction(self.target)\n                else self.target.__class__\n            )\n            line += cls.__module__ + \".\" + cls.__qualname__  # type: ignore\n\n        header += line\n\n        try:\n            file = getfile(self.target)  # type: ignore\n        except TypeError:\n            return header\n\n        header += f\"Located in [code.file ~file://{file}]{file}[/]\"\n\n        return header\n\n    def _get_definition(self) -&gt; Label:\n\"\"\"Returns the definition str of self.target.\"\"\"\n\n        target = self.target\n\n        if self.show_qualname:\n            name = getattr(target, \"__qualname__\", type(target).__name__)\n        else:\n            name = getattr(target, \"__name__\", type(target).__name__)\n\n        if self.target_type == ObjectType.LIVE:\n            target = type(target)\n\n        otype = _determine_type(target)\n\n        keyword = \"\"\n        if otype == ObjectType.CLASS:\n            keyword = \"class \"\n\n        elif otype == ObjectType.FUNCTION:\n            keyword = \"def \"\n\n        try:\n            assert callable(target)\n            definition = self.highlight(keyword + name + str(signature(target)) + \":\")\n\n        except (TypeError, ValueError, AssertionError):\n            definition = self.highlight(keyword + name + \"(...)\")\n\n        return Label(definition, parent_align=0, non_first_padding=4)\n\n    def _get_docs(self, padding: int) -&gt; Label:\n\"\"\"Returns a list of Labels of the object's documentation.\"\"\"\n\n        default = Label(\"...\", style=\"102\")\n        if self.target.__doc__ is None:\n            return default\n\n        doc = getdoc(self.target)\n\n        if doc is None:\n            return default\n\n        lines = doc.splitlines()\n        if not self.show_full_doc and len(lines) &gt; 0:\n            lines = [lines[0]]\n\n        trimmed = \"\\n\".join(lines)\n\n        return Label(\n            trimmed.replace(\"[\", r\"\\[\"),\n            style=\"102\",\n            parent_align=0,\n            padding=padding,\n        )\n\n    def _get_keys(self) -&gt; list[str]:\n\"\"\"Gets all inspectable keys of an object.\n\n        It first checks for an `__all__` attribute, and substitutes `dir` if not found.\n        Then, if there are too many keys and the given target is a module it tries to\n        list all of the present submodules.\n        \"\"\"\n\n        keys = getattr(self.target, \"__all__\", dir(self.target))\n\n        if not self.show_dunder:\n            keys = [key for key in keys if not key.startswith(\"__\")]\n\n        if not self.show_private:\n            keys = [key for key in keys if not (key.startswith(\"_\") and key[1] != \"_\")]\n\n        if not self.show_methods:\n            keys = [\n                key for key in keys if not callable(getattr(self.target, key, None))\n            ]\n\n        keys.sort(key=lambda item: callable(getattr(self.target, item, None)))\n\n        return keys\n\n    def _get_preview(self) -&gt; Container:\n\"\"\"Gets a Container with self.target inside.\"\"\"\n\n        preview = Container(static_width=self.width // 2, parent_align=0, box=\"SINGLE\")\n\n        if isinstance(self.target, str) and RE_MARKUP.match(self.target) is not None:\n            preview += Label(prettify(self.target, parse=False), parent_align=0)\n            return preview\n\n        for line in prettify(self.target).splitlines():\n\n            if real_length(line) &gt; preview.width - preview.sidelength:\n                preview.width = real_length(line) + preview.sidelength\n\n            preview += Label(tim.get_markup(line), parent_align=0)\n\n        preview.width = min(preview.width, self.terminal.width - preview.sidelength)\n        return preview\n\n    @staticmethod\n    def highlight(text: str) -&gt; str:\n\"\"\"Applies highlighting to a given string.\n\n        This highlight includes keywords, builtin types and more.\n\n        Args:\n            text: The string to highlight.\n\n        Returns:\n            Unparsed markup.\n        \"\"\"\n\n        def _split(text: str, chars: str = \" ,:|()[]{}\") -&gt; list[tuple[str, str]]:\n\"\"\"Splits given text by the given chars.\n\n            Args:\n                text: The text to split.\n                chars: A string of characters we will split by.\n\n            Returns:\n                A tuple of (delimiter, word) tuples. Delimiter is one of the characters\n                of `chars`.\n            \"\"\"\n\n            last_delim = \"\"\n            output = []\n            word = \"\"\n            for char in text:\n                if char in chars:\n                    output.append((last_delim, word))\n                    last_delim = char\n                    word = \"\"\n                    continue\n\n                word += char\n\n            output.append((last_delim, word))\n            return output\n\n        buff = \"\"\n        for (delim, word) in _split(text):\n            stripped = word.strip(\"'\")\n            highlighted = highlight_python(stripped)\n\n            if highlighted != stripped:\n                buff += delim + stripped\n                continue\n\n            buff += delim + stripped\n\n        return highlight_python(buff)\n\n    def inspect(self, target: object) -&gt; Inspector:\n\"\"\"Inspects a given object, and sets self.target to it.\n\n        Returns:\n            Self, with the new content based on the inspection.\n        \"\"\"\n\n        self.target = target\n        self.target_type = _determine_type(target)\n\n        # Header\n        if self.show_header and self.box is not INDENTED_EMPTY_BOX:\n            self.lazy_add(self._get_header())\n\n        # Body\n        if self.target_type is not ObjectType.MODULE:\n            self.lazy_add(self._get_definition())\n\n        padding = 0 if self.target_type is ObjectType.MODULE else 4\n\n        self.lazy_add(self._get_docs(padding))\n\n        keys = self._get_keys()\n\n        for key in keys:\n            attr = getattr(target, key, None)\n\n            # Don't show type aliases\n            if _is_type_alias(attr):\n                continue\n\n            # Only show functions if they are not lambdas\n            if (isfunction(attr) or callable(attr)) and (\n                hasattr(attr, \"__name__\") and not attr.__name__ == \"&lt;lambda&gt;\"\n            ):\n                self.lazy_add(\n                    Inspector(\n                        box=INDENTED_EMPTY_BOX,\n                        show_dunder=self.show_dunder,\n                        show_private=self.show_private,\n                        show_full_doc=False,\n                        show_qualname=self.show_qualname,\n                    ).inspect(attr)\n                )\n                continue\n\n            if not self.show_attrs:\n                continue\n\n            for i, line in enumerate(prettify(attr, parse=False).splitlines()):\n                if i == 0:\n                    line = f\"- {key}: {line}\"\n\n                self.lazy_add(Label(line, parent_align=0))\n\n        # Footer\n        if self.target_type in [ObjectType.LIVE, ObjectType.BUILTIN]:\n            self.lazy_add(self._get_preview())\n\n        return self\n\n    def debug(self) -&gt; str:\n\"\"\"Returns identifiable information used in repr.\"\"\"\n\n        if self.terminal.is_interactive and not self.terminal.displayhook_installed:\n            return \"\\n\".join(self.get_lines())\n\n        return Widget.debug(self)\n</code></pre>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector.__init__","title":"<code>__init__(target=None, show_private=False, show_dunder=False, show_methods=False, show_full_doc=False, show_qualname=True, show_header=True, **attrs)</code>","text":"<p>Initializes an inspector.</p> <p>Note that most of the time, using <code>inspect</code> to do this is going to be more useful.</p> <p>Some styles of the inspector can be changed using the <code>code.name</code>, <code>code.file</code> and <code>code.keyword</code> markup aliases. The rest of the highlighting is done using <code>pprint</code>, with all of its respective colors.</p> <p>Parameters:</p> Name Type Description Default <code>show_private</code> <code>bool</code> <p>Whether <code>_private</code> attributes should be shown.</p> <code>False</code> <code>show_dunder</code> <code>bool</code> <p>Whether <code>__dunder__</code> attributes should be shown.</p> <code>False</code> <code>show_methods</code> <code>bool</code> <p>Whether methods should be shown when encountering a class.</p> <code>False</code> <code>show_full_doc</code> <code>bool</code> <p>If not set, docstrings are cut to only include their first line.</p> <code>False</code> <code>show_qualname</code> <code>bool</code> <p>Show fully-qualified name, e.g. <code>module.submodule.name</code> instead of <code>name</code>.</p> <code>True</code> <code>show_header</code> <code>bool</code> <p>If not set, the header containing the path to the object and its qualname will not be added.</p> <code>True</code> Source code in <code>pytermgui/inspector.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    target: object = None,\n    show_private: bool = False,\n    show_dunder: bool = False,\n    show_methods: bool = False,\n    show_full_doc: bool = False,\n    show_qualname: bool = True,\n    show_header: bool = True,\n    **attrs: Any,\n):\n\"\"\"Initializes an inspector.\n\n    Note that most of the time, using `inspect` to do this is going to be more\n    useful.\n\n    Some styles of the inspector can be changed using the `code.name`,\n    `code.file` and `code.keyword` markup aliases. The rest of the\n    highlighting is done using `pprint`, with all of its respective colors.\n\n    Args:\n        show_private: Whether `_private` attributes should be shown.\n        show_dunder: Whether `__dunder__` attributes should be shown.\n        show_methods: Whether methods should be shown when encountering a class.\n        show_full_doc: If not set, docstrings are cut to only include their first\n            line.\n        show_qualname: Show fully-qualified name, e.g. `module.submodule.name`\n            instead of `name`.\n        show_header: If not set, the header containing the path to the object and\n            its qualname will not be added.\n    \"\"\"\n\n    if \"box\" not in attrs:\n        attrs[\"box\"] = \"EMPTY\"\n\n    super().__init__(**attrs)\n\n    self.width = self.terminal.width\n\n    self.show_private = show_private\n    self.show_dunder = show_dunder\n    self.show_methods = show_methods\n    self.show_full_doc = show_full_doc\n    self.show_qualname = show_qualname\n    self.show_header = show_header\n\n    # TODO: Fix attr-showing\n    self.show_attrs = False\n\n    self.target: object\n    if target is not None:\n        self.inspect(target)\n        self.target = target\n</code></pre>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector.debug","title":"<code>debug()</code>","text":"<p>Returns identifiable information used in repr.</p> Source code in <code>pytermgui/inspector.py</code> <pre><code>def debug(self) -&gt; str:\n\"\"\"Returns identifiable information used in repr.\"\"\"\n\n    if self.terminal.is_interactive and not self.terminal.displayhook_installed:\n        return \"\\n\".join(self.get_lines())\n\n    return Widget.debug(self)\n</code></pre>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector.highlight","title":"<code>highlight(text)</code>  <code>staticmethod</code>","text":"<p>Applies highlighting to a given string.</p> <p>This highlight includes keywords, builtin types and more.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The string to highlight.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Unparsed markup.</p> Source code in <code>pytermgui/inspector.py</code> <pre><code>@staticmethod\ndef highlight(text: str) -&gt; str:\n\"\"\"Applies highlighting to a given string.\n\n    This highlight includes keywords, builtin types and more.\n\n    Args:\n        text: The string to highlight.\n\n    Returns:\n        Unparsed markup.\n    \"\"\"\n\n    def _split(text: str, chars: str = \" ,:|()[]{}\") -&gt; list[tuple[str, str]]:\n\"\"\"Splits given text by the given chars.\n\n        Args:\n            text: The text to split.\n            chars: A string of characters we will split by.\n\n        Returns:\n            A tuple of (delimiter, word) tuples. Delimiter is one of the characters\n            of `chars`.\n        \"\"\"\n\n        last_delim = \"\"\n        output = []\n        word = \"\"\n        for char in text:\n            if char in chars:\n                output.append((last_delim, word))\n                last_delim = char\n                word = \"\"\n                continue\n\n            word += char\n\n        output.append((last_delim, word))\n        return output\n\n    buff = \"\"\n    for (delim, word) in _split(text):\n        stripped = word.strip(\"'\")\n        highlighted = highlight_python(stripped)\n\n        if highlighted != stripped:\n            buff += delim + stripped\n            continue\n\n        buff += delim + stripped\n\n    return highlight_python(buff)\n</code></pre>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.Inspector.inspect","title":"<code>inspect(target)</code>","text":"<p>Inspects a given object, and sets self.target to it.</p> <p>Returns:</p> Type Description <code>Inspector</code> <p>Self, with the new content based on the inspection.</p> Source code in <code>pytermgui/inspector.py</code> <pre><code>def inspect(self, target: object) -&gt; Inspector:\n\"\"\"Inspects a given object, and sets self.target to it.\n\n    Returns:\n        Self, with the new content based on the inspection.\n    \"\"\"\n\n    self.target = target\n    self.target_type = _determine_type(target)\n\n    # Header\n    if self.show_header and self.box is not INDENTED_EMPTY_BOX:\n        self.lazy_add(self._get_header())\n\n    # Body\n    if self.target_type is not ObjectType.MODULE:\n        self.lazy_add(self._get_definition())\n\n    padding = 0 if self.target_type is ObjectType.MODULE else 4\n\n    self.lazy_add(self._get_docs(padding))\n\n    keys = self._get_keys()\n\n    for key in keys:\n        attr = getattr(target, key, None)\n\n        # Don't show type aliases\n        if _is_type_alias(attr):\n            continue\n\n        # Only show functions if they are not lambdas\n        if (isfunction(attr) or callable(attr)) and (\n            hasattr(attr, \"__name__\") and not attr.__name__ == \"&lt;lambda&gt;\"\n        ):\n            self.lazy_add(\n                Inspector(\n                    box=INDENTED_EMPTY_BOX,\n                    show_dunder=self.show_dunder,\n                    show_private=self.show_private,\n                    show_full_doc=False,\n                    show_qualname=self.show_qualname,\n                ).inspect(attr)\n            )\n            continue\n\n        if not self.show_attrs:\n            continue\n\n        for i, line in enumerate(prettify(attr, parse=False).splitlines()):\n            if i == 0:\n                line = f\"- {key}: {line}\"\n\n            self.lazy_add(Label(line, parent_align=0))\n\n    # Footer\n    if self.target_type in [ObjectType.LIVE, ObjectType.BUILTIN]:\n        self.lazy_add(self._get_preview())\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType","title":"<code>ObjectType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>All types an object can be.</p> Source code in <code>pytermgui/inspector.py</code> <pre><code>class ObjectType(Enum):\n\"\"\"All types an object can be.\"\"\"\n\n    LIVE = _auto()\n\"\"\"An instance that does not fit the other types.\"\"\"\n\n    CLASS = _auto()\n\"\"\"A class object.\"\"\"\n\n    MODULE = _auto()\n\"\"\"A module object.\"\"\"\n\n    BUILTIN = _auto()\n\"\"\"Some sort of a builtin object.\n\n    As builtins are often implemented in C, a lot of the standard python APIs\n    won't work on them, so we need to treat them separately.\"\"\"\n\n    FUNCTION = _auto()\n\"\"\"A callable object, that is not a class.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.BUILTIN","title":"<code>BUILTIN = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Some sort of a builtin object.</p> <p>As builtins are often implemented in C, a lot of the standard python APIs won't work on them, so we need to treat them separately.</p>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.CLASS","title":"<code>CLASS = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A class object.</p>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.FUNCTION","title":"<code>FUNCTION = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A callable object, that is not a class.</p>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.LIVE","title":"<code>LIVE = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An instance that does not fit the other types.</p>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.ObjectType.MODULE","title":"<code>MODULE = _auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A module object.</p>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.get_origin","title":"<code>get_origin(_)</code>","text":"<p>Spoofs typing.get_origin, which is used to determine type-hints.</p> <p>Since this function is only available &gt;=3.8, we need to have some implementation on it for 3.7. The code checks for the origin to be non-null, as that is the value returned by this method on non-typing objects.</p> <p>This will cause annotations to show up on 3.7, but not on 3.8+.</p> Source code in <code>pytermgui/inspector.py</code> <pre><code>def get_origin(_: object) -&gt; Any:  # type: ignore\n\"\"\"Spoofs typing.get_origin, which is used to determine type-hints.\n\n    Since this function is only available &gt;=3.8, we need to have some\n    implementation on it for 3.7. The code checks for the origin to be\n    non-null, as that is the value returned by this method on non-typing\n    objects.\n\n    This will cause annotations to show up on 3.7, but not on 3.8+.\n    \"\"\"\n\n    return None\n</code></pre>"},{"location":"reference/pytermgui/inspector/#pytermgui.inspector.inspect","title":"<code>inspect(target, **inspector_args)</code>","text":"<p>Inspects an object.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>object</code> <p>The object to inspect.</p> required <code>**inspector_args</code> <code>Any</code> <p>See <code>Inspector.__init__</code>.</p> <code>{}</code> Source code in <code>pytermgui/inspector.py</code> <pre><code>def inspect(target: object, **inspector_args: Any) -&gt; Inspector:\n\"\"\"Inspects an object.\n\n    Args:\n        target: The object to inspect.\n        **inspector_args: See `Inspector.__init__`.\n    \"\"\"\n\n    def _conditionally_overwrite_kwarg(**kwargs) -&gt; None:\n        for key, value in kwargs.items():\n            if inspector_args.get(key) is None:\n                inspector_args[key] = value\n\n    if ismodule(target):\n        _conditionally_overwrite_kwarg(\n            show_dunder=False,\n            show_private=False,\n            show_full_doc=False,\n            show_methods=True,\n            show_qualname=False,\n        )\n\n    elif isclass(target):\n        _conditionally_overwrite_kwarg(\n            show_dunder=False,\n            show_private=False,\n            show_full_doc=True,\n            show_methods=True,\n            show_qualname=False,\n        )\n\n    elif callable(target) or isbuiltin(target):\n        _conditionally_overwrite_kwarg(\n            show_dunder=False,\n            show_private=False,\n            show_full_doc=True,\n            show_methods=False,\n            show_qualname=True,\n        )\n\n    else:\n        _conditionally_overwrite_kwarg(\n            show_dunder=False,\n            show_private=False,\n            show_full_doc=True,\n            show_methods=True,\n            show_qualname=False,\n        )\n\n    inspector = Inspector(**inspector_args).inspect(target)\n\n    return inspector\n</code></pre>"},{"location":"reference/pytermgui/palettes/","title":"palettes","text":"<p>The module responsible for creating snazzy color palettes.</p>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.PaletteGeneratorStrategy","title":"<code>PaletteGeneratorStrategy = Callable[[Color], Tuple[Color, Color, Color, Color]]</code>  <code>module-attribute</code>","text":"<p>Returns 4 colors generated from the base color.</p> <p>The first color will be used as the primary color. This should usually be the base color, but in some strategies (like analogous) it may not make sense.</p> <p>The second and third colors will be the secondary and tertiary colors, respectively.  The last color will be interpreted as the accent.</p>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette","title":"<code>Palette</code>  <code>dataclass</code>","text":"<p>A harmonious color palette.</p> <p>Running <code>Palette.alias</code> on a generated palette will create the following color aliases:</p> <p>Main colors</p> <p>These are the colors used by the majority of the application. Primary should make up around 50% percent of an average screen's colors, while secondary and tertiary should use the remaining 50% together (25% each).</p> <p>Accents should be used sparingly to highlight specific details.</p> <p>Items: primary, secondary, tertiary, accent</p> <p>Semantic colors</p> <p>These colors are all meant to convey some meaning. They shouldn't be used in situation where that meaning, e.g. success, isn't clearly related. When not given as an argument, they are generated by blending some default green, yellow and red with the primary color.</p> <p>Items: success, warning, error</p> <p>Neutral colors</p> <p>These are colors meant to be used as a background to the main group. All of them are a blend of a default background color and one of the main colors: <code>surface</code> is generated from <code>primary</code>, <code>surface2</code> comes from secondary and so on.</p> <p>Items: surface, surface2, surface3, surface4</p> Source code in <code>pytermgui/palettes.py</code> <pre><code>@dataclass(repr=False)\nclass Palette:\n\"\"\"A harmonious color palette.\n\n    Running `Palette.alias` on a generated palette will create the following color\n    aliases:\n\n    !!! cite \"Main colors\"\n\n        These are the colors used by the majority of the application. Primary should\n        make up around 50% percent of an average screen's colors, while secondary and\n        tertiary should use the remaining 50% together (25% each).\n\n        Accents should be used sparingly to highlight specific details.\n\n        **Items:** primary, secondary, tertiary, accent\n\n    !!! cite \"Semantic colors\"\n\n        These colors are all meant to convey some meaning. They shouldn't be used in\n        situation where that meaning, e.g. success, isn't clearly related. When not given\n        as an argument, they are generated by blending some default green, yellow and red\n        with the primary color.\n\n        **Items:** success, warning, error\n\n    !!! cite \"Neutral colors\"\n\n        These are colors meant to be used as a background to the main group. All of them\n        are a blend of a default background color and one of the main colors: `surface`\n        is generated from `primary`, `surface2` comes from secondary and so on.\n\n        **Items:** surface, surface2, surface3, surface4\n    \"\"\"\n\n    data: dict[str, str]\n\n    def __init__(  # pylint: disable=too-many-locals\n        self,\n        *,\n        primary: str,\n        secondary: str | None = None,\n        tertiary: str | None = None,\n        accent: str | None = None,\n        success: str | None = None,\n        warning: str | None = None,\n        error: str | None = None,\n        surface: str | None = None,\n        surface2: str | None = None,\n        surface3: str | None = None,\n        strategy: PaletteGeneratorStrategy = triadic,\n    ) -&gt; None:\n\"\"\"Generates a color palette from the given primary color.\n\n        If any other color arguments are passed, they will be parsed as a color\n        and used as-is. Otherwise, they will be derived from the primary.\n\n        See the class documentation for info on all arguments.\n\n        Args:\n            strategy: A strategy that will be used to derive colors.\n        \"\"\"\n\n        self.data = self._generate_map(\n            primary=primary,\n            secondary=secondary,\n            tertiary=tertiary,\n            accent=accent,\n            success=success,\n            warning=warning,\n            error=error,\n            surface=surface,\n            surface2=surface2,\n            surface3=surface3,\n            strategy=strategy,\n        )\n\n    def _generate_map(  # pylint: disable=too-many-locals\n        self,\n        *,\n        primary: str,\n        secondary: str | None = None,\n        tertiary: str | None = None,\n        accent: str | None = None,\n        success: str | None = None,\n        warning: str | None = None,\n        error: str | None = None,\n        surface: str | None = None,\n        surface2: str | None = None,\n        surface3: str | None = None,\n        strategy: PaletteGeneratorStrategy = triadic,\n    ) -&gt; dict[str, str]:\n\"\"\"Generates a map of color names to values.\n\n        See `__init__` for more information.\n        \"\"\"\n\n        if isinstance(strategy, str):\n            old_strat = strategy\n            strategy = STRATEGIES.get(strategy)\n\n            if strategy is None:\n                raise KeyError(\n                    f\"Unknown strategy {old_strat!r}. Please choose from\"\n                    + f\" {list(STRATEGIES.keys())}.\"\n                )\n\n        c_primary = Color.parse(primary, localize=False)\n\n        # Four main colors\n        c_primary, *generated = strategy(c_primary)\n        c_secondary = _parse_optional(secondary, generated[0])\n        c_tertiary = _parse_optional(tertiary, generated[1])\n        c_accent = _parse_optional(accent, generated[2])\n\n        # Four surface colors, one for each main color\n        c_surface = _parse_optional(surface, SURFACE.blend(c_primary, SURFACE_ALPHA))\n        c_surface2 = _parse_optional(\n            surface2, SURFACE.blend(c_secondary, SURFACE_ALPHA)\n        )\n        c_surface3 = _parse_optional(surface3, SURFACE.blend(c_tertiary, SURFACE_ALPHA))\n        c_surface4 = _parse_optional(surface3, SURFACE.blend(c_accent, SURFACE_ALPHA))\n\n        # Three semantic colors, blended from primary\n        c_success = _parse_optional(success, SUCCESS.blend(c_primary, SEMANTIC_ALPHA))\n        c_warning = _parse_optional(warning, WARNING.blend(c_primary, SEMANTIC_ALPHA))\n        c_error = _parse_optional(error, ERROR.blend(c_primary, SEMANTIC_ALPHA))\n\n        base_palette: dict[str, Color] = {\n            \"primary\": c_primary,\n            \"secondary\": c_secondary,\n            \"tertiary\": c_tertiary,\n            \"accent\": c_accent,\n            \"surface\": c_surface,\n            \"surface2\": c_surface2,\n            \"surface3\": c_surface3,\n            \"surface4\": c_surface4,\n            \"success\": c_success,\n            \"warning\": c_warning,\n            \"error\": c_error,\n        }\n\n        black = Color.parse(\"#000000\")\n        white = Color.parse(\"#FFFFFF\")\n\n        data = {}\n\n        for name, color in base_palette.items():\n            for shadenumber in range(-SHADE_COUNT, SHADE_COUNT + 1):\n                if shadenumber &gt; 0:\n                    shadeindex = f\"+{shadenumber}\"\n                    blend_color = white\n                    blend_multiplier = 1\n\n                elif shadenumber == 0:\n                    shadeindex = \"\"\n\n                else:\n                    shadeindex = str(shadenumber)\n                    blend_color = black\n                    blend_multiplier = -1\n\n                if shadenumber == 0:\n                    blended = color\n\n                else:\n                    blended = color.blend(\n                        blend_color, blend_multiplier * SHADE_INCREMENT * shadenumber\n                    )\n\n                data[f\"{name}{shadeindex}\"] = blended\n\n                bg_variant = deepcopy(blended)\n                bg_variant.background = True\n                data[f\"@{name}{shadeindex}\"] = bg_variant\n\n        return {\n            key: (\"@\" if color.background else \"\") + color.hex\n            for key, color in data.items()\n        }\n\n    def regenerate(self, **kwargs: Any) -&gt; Palette:\n\"\"\"Generates a new palette and replaces self.data with its data.\n\n        Args:\n            **kwargs: All key word args passed to the new Palette. See `__init__`.\n\n        Returns:\n            This palette, after regeneration.\n        \"\"\"\n\n        other = Palette(**kwargs)\n\n        self.data = other.data\n        self.alias()\n\n        return self\n\n    def base_keys(self) -&gt; list[str]:\n\"\"\"Returns the non-background, non-shade alias keys.\"\"\"\n\n        return [\n            key\n            for key in self.data\n            if not \"+\" in key and not \"-\" in key and not key.startswith(\"@\")\n        ]\n\n    def alias(self, lang: MarkupLanguage = tim) -&gt; None:\n\"\"\"Sets up aliases for the given language.\n\n        Note that no unsetters will be generated.\n\n        Args:\n            lang: The language to run `alias_multiple` on.\n        \"\"\"\n\n        lang.clear_cache()\n        lang.alias_multiple(**self.data, generate_unsetter=False)\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Shows off the palette in a compact form.\"\"\"\n\n        yield f\"&lt;{type(self).__name__}\"\n\n        for name, value in [\n            (\"primary\", self.data[\"primary\"]),\n            (\"secondary\", self.data[\"secondary\"]),\n            (\"tertiary\", self.data[\"tertiary\"]),\n            (\"accent\", self.data[\"accent\"]),\n        ]:\n            yield {\n                \"text\": f\" {name}: [@{value} #auto]{value}[/]\",\n                \"highlight\": False,\n            }\n\n        yield \"&gt;\\n\\n\"\n\n        length = max(len(key) for key in self.base_keys()) + 2\n        for name in self.base_keys():\n            line = \"\"\n\n            for shadenumber in range(-SHADE_COUNT, SHADE_COUNT + 1):\n                if shadenumber &gt; 0:\n                    shadeindex = f\"+{shadenumber}\"\n\n                elif shadenumber == 0:\n                    line += f\"[@{self.data[name]} #auto] {name:^{length}} \"\n                    continue\n\n                else:\n                    shadeindex = str(shadenumber)\n\n                line += f\"[@{self.data[name + shadeindex]} #auto]    \"\n\n            yield {\n                \"text\": tim.parse(line + \"[/]\\n\"),\n                \"highlight\": False,\n            }\n\n    def print(self) -&gt; None:\n\"\"\"Shows off the palette in an extended form.\"\"\"\n\n        length = max(len(key) for key in self.base_keys()) + 4\n        keys = self.base_keys()\n\n        for name in keys:\n            names = []\n\n            for shadenumber in range(-SHADE_COUNT, SHADE_COUNT + 1):\n                if shadenumber &gt; 0:\n                    shadeindex = f\"+{shadenumber}\"\n\n                elif shadenumber == 0:\n                    shadeindex = \"\"\n\n                else:\n                    shadeindex = str(shadenumber)\n\n                shaded_name = name + shadeindex\n                names.append(shaded_name)\n\n            tim.print(\"\".join(f\"[@{self.data[name]}]{' ' * length}\" for name in names))\n            tim.print(\n                \"\".join(\n                    f\"[@{self.data[name]} #auto]\"\n                    + (\n                        f\"[bold]{name:^{length}}[/]\"\n                        if name in keys\n                        else name[-2:].center(length)\n                    )\n                    for name in names\n                )\n            )\n            tim.print(\n                \"\".join(\n                    f\"[@{self.data[name]} #auto]{self.data[name]:^{length}}\"\n                    for name in names\n                )\n            )\n            tim.print(\"\".join(f\"[@{self.data[name]}]{' ' * length}\" for name in names))\n</code></pre>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.__fancy_repr__","title":"<code>__fancy_repr__()</code>","text":"<p>Shows off the palette in a compact form.</p> Source code in <code>pytermgui/palettes.py</code> <pre><code>def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Shows off the palette in a compact form.\"\"\"\n\n    yield f\"&lt;{type(self).__name__}\"\n\n    for name, value in [\n        (\"primary\", self.data[\"primary\"]),\n        (\"secondary\", self.data[\"secondary\"]),\n        (\"tertiary\", self.data[\"tertiary\"]),\n        (\"accent\", self.data[\"accent\"]),\n    ]:\n        yield {\n            \"text\": f\" {name}: [@{value} #auto]{value}[/]\",\n            \"highlight\": False,\n        }\n\n    yield \"&gt;\\n\\n\"\n\n    length = max(len(key) for key in self.base_keys()) + 2\n    for name in self.base_keys():\n        line = \"\"\n\n        for shadenumber in range(-SHADE_COUNT, SHADE_COUNT + 1):\n            if shadenumber &gt; 0:\n                shadeindex = f\"+{shadenumber}\"\n\n            elif shadenumber == 0:\n                line += f\"[@{self.data[name]} #auto] {name:^{length}} \"\n                continue\n\n            else:\n                shadeindex = str(shadenumber)\n\n            line += f\"[@{self.data[name + shadeindex]} #auto]    \"\n\n        yield {\n            \"text\": tim.parse(line + \"[/]\\n\"),\n            \"highlight\": False,\n        }\n</code></pre>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.__init__","title":"<code>__init__(*, primary, secondary=None, tertiary=None, accent=None, success=None, warning=None, error=None, surface=None, surface2=None, surface3=None, strategy=triadic)</code>","text":"<p>Generates a color palette from the given primary color.</p> <p>If any other color arguments are passed, they will be parsed as a color and used as-is. Otherwise, they will be derived from the primary.</p> <p>See the class documentation for info on all arguments.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>PaletteGeneratorStrategy</code> <p>A strategy that will be used to derive colors.</p> <code>triadic</code> Source code in <code>pytermgui/palettes.py</code> <pre><code>def __init__(  # pylint: disable=too-many-locals\n    self,\n    *,\n    primary: str,\n    secondary: str | None = None,\n    tertiary: str | None = None,\n    accent: str | None = None,\n    success: str | None = None,\n    warning: str | None = None,\n    error: str | None = None,\n    surface: str | None = None,\n    surface2: str | None = None,\n    surface3: str | None = None,\n    strategy: PaletteGeneratorStrategy = triadic,\n) -&gt; None:\n\"\"\"Generates a color palette from the given primary color.\n\n    If any other color arguments are passed, they will be parsed as a color\n    and used as-is. Otherwise, they will be derived from the primary.\n\n    See the class documentation for info on all arguments.\n\n    Args:\n        strategy: A strategy that will be used to derive colors.\n    \"\"\"\n\n    self.data = self._generate_map(\n        primary=primary,\n        secondary=secondary,\n        tertiary=tertiary,\n        accent=accent,\n        success=success,\n        warning=warning,\n        error=error,\n        surface=surface,\n        surface2=surface2,\n        surface3=surface3,\n        strategy=strategy,\n    )\n</code></pre>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.alias","title":"<code>alias(lang=tim)</code>","text":"<p>Sets up aliases for the given language.</p> <p>Note that no unsetters will be generated.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>MarkupLanguage</code> <p>The language to run <code>alias_multiple</code> on.</p> <code>tim</code> Source code in <code>pytermgui/palettes.py</code> <pre><code>def alias(self, lang: MarkupLanguage = tim) -&gt; None:\n\"\"\"Sets up aliases for the given language.\n\n    Note that no unsetters will be generated.\n\n    Args:\n        lang: The language to run `alias_multiple` on.\n    \"\"\"\n\n    lang.clear_cache()\n    lang.alias_multiple(**self.data, generate_unsetter=False)\n</code></pre>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.base_keys","title":"<code>base_keys()</code>","text":"<p>Returns the non-background, non-shade alias keys.</p> Source code in <code>pytermgui/palettes.py</code> <pre><code>def base_keys(self) -&gt; list[str]:\n\"\"\"Returns the non-background, non-shade alias keys.\"\"\"\n\n    return [\n        key\n        for key in self.data\n        if not \"+\" in key and not \"-\" in key and not key.startswith(\"@\")\n    ]\n</code></pre>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.print","title":"<code>print()</code>","text":"<p>Shows off the palette in an extended form.</p> Source code in <code>pytermgui/palettes.py</code> <pre><code>def print(self) -&gt; None:\n\"\"\"Shows off the palette in an extended form.\"\"\"\n\n    length = max(len(key) for key in self.base_keys()) + 4\n    keys = self.base_keys()\n\n    for name in keys:\n        names = []\n\n        for shadenumber in range(-SHADE_COUNT, SHADE_COUNT + 1):\n            if shadenumber &gt; 0:\n                shadeindex = f\"+{shadenumber}\"\n\n            elif shadenumber == 0:\n                shadeindex = \"\"\n\n            else:\n                shadeindex = str(shadenumber)\n\n            shaded_name = name + shadeindex\n            names.append(shaded_name)\n\n        tim.print(\"\".join(f\"[@{self.data[name]}]{' ' * length}\" for name in names))\n        tim.print(\n            \"\".join(\n                f\"[@{self.data[name]} #auto]\"\n                + (\n                    f\"[bold]{name:^{length}}[/]\"\n                    if name in keys\n                    else name[-2:].center(length)\n                )\n                for name in names\n            )\n        )\n        tim.print(\n            \"\".join(\n                f\"[@{self.data[name]} #auto]{self.data[name]:^{length}}\"\n                for name in names\n            )\n        )\n        tim.print(\"\".join(f\"[@{self.data[name]}]{' ' * length}\" for name in names))\n</code></pre>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.Palette.regenerate","title":"<code>regenerate(**kwargs)</code>","text":"<p>Generates a new palette and replaces self.data with its data.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>All key word args passed to the new Palette. See <code>__init__</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Palette</code> <p>This palette, after regeneration.</p> Source code in <code>pytermgui/palettes.py</code> <pre><code>def regenerate(self, **kwargs: Any) -&gt; Palette:\n\"\"\"Generates a new palette and replaces self.data with its data.\n\n    Args:\n        **kwargs: All key word args passed to the new Palette. See `__init__`.\n\n    Returns:\n        This palette, after regeneration.\n    \"\"\"\n\n    other = Palette(**kwargs)\n\n    self.data = other.data\n    self.alias()\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.analogous","title":"<code>analogous(base)</code>","text":"<p>Colors that sit next to eachother on the colorwheel.</p> <p>Note that the order of primary and secondary colors are swapped by this function. This is done so the colors, when laid out next to eachother, complete a gradient.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>Color</code> <p>The color used for derivations.</p> required <p></p> Source code in <code>pytermgui/palettes.py</code> <pre><code>def analogous(base: Color) -&gt; tuple[Color, Color, Color, Color]:\n\"\"\"Colors that sit next to eachother on the colorwheel.\n\n    Note that the order of primary and secondary colors are swapped\n    by this function. This is done so the colors, when laid out next\n    to eachother, complete a gradient.\n\n    Args:\n        base: The color used for derivations.\n\n    ![Analogous strategy](../../assets/analogous.svg)\n    \"\"\"\n\n    before, _, after = base.analogous\n\n    return before, base, after, base.complement\n</code></pre>"},{"location":"reference/pytermgui/palettes/#pytermgui.palettes.triadic","title":"<code>triadic(base)</code>","text":"<p>Three complementary colors.</p> <p>Each color is offset 120 degrees from the previous one on the colorwheel. If plotted on the colorwheel, they make up a regular triangle.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>Color</code> <p>The color used for derivations.</p> required <p></p> Source code in <code>pytermgui/palettes.py</code> <pre><code>def triadic(base: Color) -&gt; tuple[Color, Color, Color, Color]:\n\"\"\"Three complementary colors.\n\n    Each color is offset 120 degrees from the previous one on the colorwheel. If\n    plotted on the colorwheel, they make up a regular triangle.\n\n    Args:\n        base: The color used for derivations.\n\n    ![Triadic strategy](../../assets/triadic.svg)\n    \"\"\"\n\n    return (*base.triadic, base.complement)\n</code></pre>"},{"location":"reference/pytermgui/prettifiers/","title":"prettifiers","text":"<p>This module provides some methods to prettify things.</p> <p>The main export here is <code>prettify</code>. It uses <code>pytermgui.parser.tim</code>, and all of its markup magic to create prettier representations of whatever is given.</p>"},{"location":"reference/pytermgui/prettifiers/#pytermgui.prettifiers.prettify","title":"<code>prettify(target, indent=2, force_markup=False, expand_all=False, parse=True)</code>","text":"<p>Prettifies any Python object.</p> <p>This uses a set of pre-defined aliases for the styling, and as such is fully customizable.</p> <p>The aliases are:</p> <ul> <li><code>str</code>: Applied to all strings, so long as they do not contain TIM code.</li> <li><code>int</code>: Applied to all integers and booleans. The latter are included as they     subclass int.</li> <li><code>type</code>: Applied to all types.</li> <li><code>none</code>: Applied to NoneType. Note that when using <code>pytermgui.pretty</code> or any     of its printers, a single <code>None</code> return value will not be printed, only when     part of a more complex structure.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Any</code> <p>The object to prettify. Can be any type.</p> required <code>indent</code> <code>int</code> <p>The indentation used for multi-line objects, like containers. When set to 0, these will be collapsed. By default, container types with <code>len() == 1</code> are always collapsed, regardless of this value. See <code>expand_all</code> to overwrite that behaviour.</p> <code>2</code> <code>force_markup</code> <code>bool</code> <p>When this is set every ANSI-sequence string will be turned into markup and syntax highlighted.</p> <code>False</code> <code>expand_all</code> <code>bool</code> <p>When set, objects that would normally be force-collapsed are also going to be expanded.</p> <code>False</code> <code>parse</code> <code>bool</code> <p>If not set, the return value will be a plain markup string, not yet parsed.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>A pretty string of the given target.</p> Source code in <code>pytermgui/prettifiers.py</code> <pre><code>def prettify(  # pylint: disable=too-many-branches\n    target: Any,\n    indent: int = 2,\n    force_markup: bool = False,\n    expand_all: bool = False,\n    parse: bool = True,\n) -&gt; str:\n\"\"\"Prettifies any Python object.\n\n    This uses a set of pre-defined aliases for the styling, and as such is fully\n    customizable.\n\n    The aliases are:\n\n    - `str`: Applied to all strings, so long as they do not contain TIM code.\n    - `int`: Applied to all integers and booleans. The latter are included as they\n        subclass int.\n    - `type`: Applied to all types.\n    - `none`: Applied to NoneType. Note that when using `pytermgui.pretty` or any\n        of its printers, a single `None` return value will not be printed, only when\n        part of a more complex structure.\n\n    Args:\n        target: The object to prettify. Can be any type.\n        indent: The indentation used for multi-line objects, like containers. When\n            set to 0, these will be collapsed. By default, container types with\n            `len() == 1` are always collapsed, regardless of this value. See\n            `expand_all` to overwrite that behaviour.\n        force_markup: When this is set every ANSI-sequence string will be turned\n            into markup and syntax highlighted.\n        expand_all: When set, objects that would normally be force-collapsed are\n            also going to be expanded.\n        parse: If not set, the return value will be a plain markup string, not yet\n            parsed.\n\n    Returns:\n        A pretty string of the given target.\n    \"\"\"\n\n    if isinstance(target, str):\n        if RE_MARKUP.match(target) is not None:\n            try:\n                highlighted_target = highlight_tim(target)\n\n                if parse:\n                    return f'\"{tim.parse(highlighted_target)}\"'\n\n                return highlighted_target + \"[/]\"\n\n            except MarkupSyntaxError:\n                pass\n\n        if RE_ANSI.match(target) is not None:\n            return target + \"\\x1b[0m\"\n\n        target = repr(target)\n\n    if isinstance(target, CONTAINER_TYPES):\n        if len(target) &lt; 2 and not expand_all:\n            indent = 0\n\n        indent_str = (\"\\n\" if indent &gt; 0 else \"\") + indent * \" \"\n\n        chars = str(target)[0], str(target)[-1]\n        buff = chars[0]\n\n        if isinstance(target, (dict, UserDict)):\n            for i, (key, value) in enumerate(target.items()):\n                if i &gt; 0:\n                    buff += \", \"\n\n                buff += indent_str + highlight_python(f\"{key!r}: \")\n\n                pretty = prettify(\n                    value,\n                    indent=indent,\n                    expand_all=expand_all,\n                    force_markup=force_markup,\n                    parse=False,\n                )\n\n                lines = pretty.splitlines()\n                buff += lines[0]\n\n                for line in lines[1:]:\n                    buff += indent_str + line\n\n        else:\n            for i, value in enumerate(target):\n                if i &gt; 0:\n                    buff += \", \"\n\n                pretty = prettify(\n                    value,\n                    indent=indent,\n                    expand_all=expand_all,\n                    force_markup=force_markup,\n                    parse=False,\n                )\n\n                lines = pretty.splitlines()\n\n                for line in lines:\n                    buff += indent_str + line\n\n        if indent &gt; 0:\n            buff += \"\\n\"\n\n        buff += chars[1]\n\n        if force_markup:\n            return buff\n\n        return tim.parse(buff)\n\n    if supports_fancy_repr(target):\n        buff = build_fancy_repr(target)\n\n    else:\n        buff = highlight_python(str(target))\n\n    return tim.parse(buff) if parse else buff\n</code></pre>"},{"location":"reference/pytermgui/pretty/","title":"pretty","text":"<p>This module calls <code>install()</code> on import, and defines <code>print</code> as <code>pprint</code>.</p> <p>It allows setting up pretty print functionality in only one line.</p> Usage <pre><code>&gt;&gt;&gt; from pytermgui.pretty import print\n</code></pre>"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.PTGFormatter","title":"<code>PTGFormatter</code>","text":"<p>             Bases: <code>BaseFormatter</code></p> <p>An IPython formatter for PTG pretty printing.</p> Source code in <code>pytermgui/pretty.py</code> <pre><code>class PTGFormatter(BaseFormatter):  # pylint: disable=too-few-public-methods\n\"\"\"An IPython formatter for PTG pretty printing.\"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"Initializes PTGFormatter, storing **kwargs.\"\"\"\n\n        super().__init__()\n\n        self.kwargs = kwargs\n\n    def __call__(self, value: Any) -&gt; None:\n\"\"\"Pretty prints the given value, as well as a leading newline.\n\n        The newline is needed since IPython output is prepended with\n        \"Out[i]:\", and it might mess alignments up.\n        \"\"\"\n\n        builtins.print(\"\\n\")\n        pprint(value, **self.kwargs)\n\n        # Sets up \"_\" as a way to access return value,\n        # inkeeping with sys.displayhook\n        builtins._ = value  # type: ignore\n</code></pre>"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.PTGFormatter.__call__","title":"<code>__call__(value)</code>","text":"<p>Pretty prints the given value, as well as a leading newline.</p> <p>The newline is needed since IPython output is prepended with \"Out[i]:\", and it might mess alignments up.</p> Source code in <code>pytermgui/pretty.py</code> <pre><code>def __call__(self, value: Any) -&gt; None:\n\"\"\"Pretty prints the given value, as well as a leading newline.\n\n    The newline is needed since IPython output is prepended with\n    \"Out[i]:\", and it might mess alignments up.\n    \"\"\"\n\n    builtins.print(\"\\n\")\n    pprint(value, **self.kwargs)\n\n    # Sets up \"_\" as a way to access return value,\n    # inkeeping with sys.displayhook\n    builtins._ = value  # type: ignore\n</code></pre>"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.PTGFormatter.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initializes PTGFormatter, storing **kwargs.</p> Source code in <code>pytermgui/pretty.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n\"\"\"Initializes PTGFormatter, storing **kwargs.\"\"\"\n\n    super().__init__()\n\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.install","title":"<code>install(indent=2, force_markup=False, expand_all=False)</code>","text":"<p>Sets up <code>pprint</code> to print all REPL output. IPython is also supported.</p> <p>This function sets up a hook that will call <code>pprint</code> after every interactive return. The given arguments are passed directly to <code>pprint</code>, so for more information you can check out that function.</p> <p>Usage is pretty simple:</p> <pre><code>&gt;&gt;&gt; from pytermgui import pretty\n&gt;&gt;&gt; tim.setup_displayhook()\n&gt;&gt;&gt; # Any function output will now be prettified\n</code></pre> <p>...or alternatively, you can import <code>print</code> from <code>pytermgui.pretty</code>, and have it automatically set up, and replace your namespace's <code>print</code> function with <code>tim.pprint</code>:</p> <pre><code>&gt;&gt;&gt; from pytermgui.pretty import print\n... # Under the hood, the above is called and `tim.pprint` is set\n... # for the `print` name\n&gt;&gt;&gt; # Any function output will now be prettified\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>The indentation value used for multi-line objects. This is ignored when the given object has a <code>len() &lt; 2</code>, and <code>expand_all is not set.</code></p> <code>2</code> <code>force_markup</code> <code>bool</code> <p>Turn all ANSI-sequences into tim before pretty printing.</p> <code>False</code> <code>expand_all</code> <code>bool</code> <p>Force-expand containers, even when they would normally be collapsed.</p> <code>False</code> Source code in <code>pytermgui/pretty.py</code> <pre><code>def install(\n    indent: int = 2, force_markup: bool = False, expand_all: bool = False\n) -&gt; None:\n\"\"\"Sets up `pprint` to print all REPL output. IPython is also supported.\n\n    This function sets up a hook that will call `pprint` after every interactive return.\n    The given arguments are passed directly to `pprint`, so for more information\n    you can check out that function.\n\n    Usage is pretty simple:\n\n    ```python3\n    &gt;&gt;&gt; from pytermgui import pretty\n    &gt;&gt;&gt; tim.setup_displayhook()\n    &gt;&gt;&gt; # Any function output will now be prettified\n    ```\n\n    ...or alternatively, you can import `print` from `pytermgui.pretty`,\n    and have it automatically set up, and replace your namespace's `print`\n    function with `tim.pprint`:\n\n    ```python3\n    &gt;&gt;&gt; from pytermgui.pretty import print\n    ... # Under the hood, the above is called and `tim.pprint` is set\n    ... # for the `print` name\n    &gt;&gt;&gt; # Any function output will now be prettified\n    ```\n\n    Args:\n        indent: The indentation value used for multi-line objects. This is ignored when\n            the given object has a `len() &lt; 2`, and `expand_all is not set.`\n        force_markup: Turn all ANSI-sequences into tim before pretty printing.\n        expand_all: Force-expand containers, even when they would normally be collapsed.\n    \"\"\"\n\n    def _hook(value: Any) -&gt; None:\n        if value is None:\n            return\n\n        pprint(value, force_markup=force_markup, indent=indent, expand_all=expand_all)\n\n        # Sets up \"_\" as a way to access return value,\n        # inkeeping with sys.displayhook\n        builtins._ = value  # type: ignore\n\n    if IPYTHON is not None:\n        IPYTHON.display_formatter.formatters[\"text/plain\"] = PTGFormatter(\n            force_markup=force_markup, indent=indent, expand_all=expand_all\n        )\n\n    else:\n        sys.displayhook = _hook\n\n    if not NO_WELCOME:\n        with get_terminal().no_record():\n            builtins.print()\n            tim.print(\"[113 bold]Successfully set up prettification!\")\n            tim.print(\"[245 italic]&gt; All function returns will now be pretty-printed,\")\n            builtins.print()\n            pprint(\"[245 italic]Including [/italic 210]Markup!\")\n            builtins.print()\n\n    get_terminal().displayhook_installed = True\n</code></pre>"},{"location":"reference/pytermgui/pretty/#pytermgui.pretty.pprint","title":"<code>pprint(*items, indent=2, expand_all=False, force_markup=False, parse=True, **print_args)</code>","text":"<p>A wrapper to pretty-print any object.</p> <p>This essentially just calls <code>prettify</code> on each given object, and passes the <code>**print_args</code> right through to print. Note that when the <code>sep</code> print argument is ommitted it is manually set to <code>\", \\n\"</code>.</p> <p>To customize any of the styles, see <code>MarkupLanguage.prettify</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*items</code> <code>Any</code> <p>The items to print. These are passed in the same way they would be into builtin print.</p> <code>()</code> <code>indent</code> <code>int</code> <p>The indentation value used for multi-line objects. This is ignored when the given object has a <code>len() &lt; 2</code>, and <code>expand_all is not set.</code></p> <code>2</code> <code>force_markup</code> <code>bool</code> <p>Turn all ANSI-sequences into markup before pretty printing.</p> <code>False</code> <code>expand_all</code> <code>bool</code> <p>Force-expand containers, even when they would normally be collapsed.</p> <code>False</code> <code>**print_args</code> <code>Any</code> <p>All arguments passed to builtin print.</p> <code>{}</code> Source code in <code>pytermgui/pretty.py</code> <pre><code>def pprint(\n    *items: Any,\n    indent: int = 2,\n    expand_all: bool = False,\n    force_markup: bool = False,\n    parse: bool = True,\n    **print_args: Any,\n) -&gt; None:\nr\"\"\"A wrapper to pretty-print any object.\n\n    This essentially just calls `prettify` on each given object, and passes the\n    `**print_args` right through to print. Note that when the `sep` print argument is\n    ommitted it is manually set to `\", \\n\"`.\n\n    To customize any of the styles, see `MarkupLanguage.prettify`.\n\n    Args:\n        *items: The items to print. These are passed in the same way they would be into\n            builtin print.\n        indent: The indentation value used for multi-line objects. This is ignored when\n            the given object has a `len() &lt; 2`, and `expand_all is not set.`\n        force_markup: Turn all ANSI-sequences into markup before pretty printing.\n        expand_all: Force-expand containers, even when they would normally be collapsed.\n        **print_args: All arguments passed to builtin print.\n    \"\"\"\n\n    if \"sep\" not in print_args:\n        print_args[\"sep\"] = \", \\n\"\n\n    pretty = []\n    for item in items:\n        pretty.append(\n            prettify(\n                item,\n                force_markup=force_markup,\n                indent=indent,\n                expand_all=expand_all,\n                parse=parse,\n            )\n        )\n\n    get_terminal().print(*pretty, **print_args)\n</code></pre>"},{"location":"reference/pytermgui/regex/","title":"regex","text":"<p>This modules contains all of the regex-related names and utilites.</p>"},{"location":"reference/pytermgui/regex/#pytermgui.regex.escape_markup","title":"<code>escape_markup(text)</code>","text":"<p>Escapes any potential markup to avoid double-parsing.</p> <p>Use this when treating already parsed markup.</p> Source code in <code>pytermgui/regex.py</code> <pre><code>def escape_markup(text: str) -&gt; str:\n\"\"\"Escapes any potential markup to avoid double-parsing.\n\n    Use this when treating already parsed markup.\n    \"\"\"\n\n    def _escape(mtch: Match) -&gt; str:\n        full, *_ = mtch.groups()\n\n        return full.replace(\"[\", r\"\\[\")\n\n    return RE_MARKUP.sub(_escape, text)\n</code></pre>"},{"location":"reference/pytermgui/regex/#pytermgui.regex.has_open_sequence","title":"<code>has_open_sequence(text)</code>  <code>cached</code>","text":"<p>Figures out if the given text has any unclosed ANSI sequences.</p> <p>It supports standard SGR (<code>\\x1b[1mHello</code>), OSC (<code>\\x1b[30;2ST\\x1b\\\\</code>) and Kitty APC codes (<code>\u001b_Garguments;hex_data\\x1b\\\\</code>). It also recognizes incorrect syntax; it only considers a tag closed when it is using the right closing sequence, e.g. <code>m</code> or <code>H</code> for SGR, <code>\\x1b\\\\</code> for OSC and APC types.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there is at least one tag that hasn't been closed, False otherwise.</p> Source code in <code>pytermgui/regex.py</code> <pre><code>@lru_cache(maxsize=1024)\ndef has_open_sequence(text: str) -&gt; bool:\n\"\"\"Figures out if the given text has any unclosed ANSI sequences.\n\n    It supports standard SGR (`\\\\x1b[1mHello`), OSC (`\\\\x1b[30;2ST\\\\x1b\\\\\\\\`) and Kitty APC codes\n    (`\\x1b_Garguments;hex_data\\\\x1b\\\\\\\\`). It also recognizes incorrect syntax; it only considers\n    a tag closed when it is using the right closing sequence, e.g. `m` or `H` for SGR, `\\\\x1b\\\\\\\\`\n    for OSC and APC types.\n\n    Args:\n        text: The text to test.\n\n    Returns:\n        True if there is at least one tag that hasn't been closed, False otherwise.\n    \"\"\"\n\n    is_osc = False\n    is_sgr = False\n    is_apc = False\n\n    open_count = 0\n    sequence = \"\"\n\n    for char in text:\n        if char == \"\\x1b\":\n            open_count += 1\n            sequence += char\n            continue\n\n        if len(sequence) == 0:\n            continue\n\n        # Ignore OSC and APC closers as new openers\n        if char == \"\\\\\" and sequence[-1] == \"\\x1b\":\n            open_count -= 1\n\n        is_osc = is_osc or sequence[:2] == \"\\x1b]\"\n        is_sgr = is_sgr or sequence[:2] == \"\\x1b[\"\n        is_apc = is_apc or sequence[:3] == \"\\x1b_G\"\n\n        sequence += char\n        if (is_osc or is_apc) and sequence[-2:] == \"\\x1b\\\\\":\n            sequence = \"\"\n            open_count -= 1\n\n        elif is_sgr and char in {\"m\", \"H\"}:\n            sequence = \"\"\n            open_count -= 1\n\n    return len(sequence) != 0 or open_count != 0\n</code></pre>"},{"location":"reference/pytermgui/regex/#pytermgui.regex.real_length","title":"<code>real_length(text)</code>  <code>cached</code>","text":"<p>Gets the display-length of text.</p> <p>This length means no ANSI sequences are counted. This method is a convenience wrapper for <code>len(strip_ansi(text))</code>.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to calculate the length of.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The display-length of text.</p> Source code in <code>pytermgui/regex.py</code> <pre><code>@lru_cache(maxsize=None)\ndef real_length(text: str) -&gt; int:\n\"\"\"Gets the display-length of text.\n\n    This length means no ANSI sequences are counted. This method is a convenience wrapper\n    for `len(strip_ansi(text))`.\n\n    Args:\n        text: The text to calculate the length of.\n\n    Returns:\n        The display-length of text.\n    \"\"\"\n\n    return len(strip_ansi(text))\n</code></pre>"},{"location":"reference/pytermgui/regex/#pytermgui.regex.strip_ansi","title":"<code>strip_ansi(text)</code>  <code>cached</code>","text":"<p>Removes ANSI sequences from text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>A string or bytes object containing 0 or more ANSI sequences.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The text without any ANSI sequences.</p> Source code in <code>pytermgui/regex.py</code> <pre><code>@lru_cache()\ndef strip_ansi(text: str) -&gt; str:\n\"\"\"Removes ANSI sequences from text.\n\n    Args:\n        text: A string or bytes object containing 0 or more ANSI sequences.\n\n    Returns:\n        The text without any ANSI sequences.\n    \"\"\"\n\n    if hasattr(text, \"plain\"):\n        return text.plain  # type: ignore\n\n    return RE_ANSI.sub(\"\", text)\n</code></pre>"},{"location":"reference/pytermgui/regex/#pytermgui.regex.strip_markup","title":"<code>strip_markup(text)</code>  <code>cached</code>","text":"<p>Removes markup tags from text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>A string or bytes object containing 0 or more markup tags.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The text without any markup tags.</p> Source code in <code>pytermgui/regex.py</code> <pre><code>@lru_cache()\ndef strip_markup(text: str) -&gt; str:\n\"\"\"Removes markup tags from text.\n\n    Args:\n        text: A string or bytes object containing 0 or more markup tags.\n\n    Returns:\n        The text without any markup tags.\n    \"\"\"\n\n    return RE_MARKUP.sub(\"\", text)\n</code></pre>"},{"location":"reference/pytermgui/serialization/","title":"serialization","text":"<p><code>Serializer</code> class to allow dumping and loading <code>Widget</code>-s. This class uses <code>Widget.serialize</code> for each widget.</p>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer","title":"<code>Serializer</code>","text":"<p>A class to facilitate loading &amp; dumping widgets.</p> <p>By default it is only aware of pytermgui objects, however if needed it can be made aware of custom widgets using <code>Serializer.register</code>.</p> <p>It can dump any widget type, but can only load ones it knows.</p> <p>All styles (except for char styles) are converted to markup during the dump process. This is done to make the end-result more readable, as well as more universally usable. As a result, all widgets use <code>markup_style</code> for their affected styles.</p> Source code in <code>pytermgui/serialization.py</code> <pre><code>class Serializer:\n\"\"\"A class to facilitate loading &amp; dumping widgets.\n\n    By default it is only aware of pytermgui objects, however\n    if needed it can be made aware of custom widgets using\n    `Serializer.register`.\n\n    It can dump any widget type, but can only load ones it knows.\n\n    All styles (except for char styles) are converted to markup\n    during the dump process. This is done to make the end-result\n    more readable, as well as more universally usable. As a result,\n    all widgets use `markup_style` for their affected styles.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Sets up known widgets.\"\"\"\n\n        self.known_widgets = self.get_widgets()\n        self.known_boxes = vars(widgets.boxes)\n        self.register(Window)\n\n        self.bound_methods: dict[str, Callable[..., Any]] = {}\n\n    @staticmethod\n    def get_widgets() -&gt; WidgetDict:\n\"\"\"Gets all widgets from the module.\"\"\"\n\n        known = {}\n        for name, item in vars(widgets).items():\n            if not isinstance(item, type):\n                continue\n\n            if issubclass(item, Widget):\n                known[name] = item\n\n        return known\n\n    @staticmethod\n    def dump_to_dict(obj: Widget) -&gt; dict[str, Any]:\n\"\"\"Dump widget to a dict.\n\n        This is an alias for `obj.serialize`.\n\n        Args:\n            obj: The widget to dump.\n\n        Returns:\n            `obj.serialize()`.\n        \"\"\"\n\n        return obj.serialize()\n\n    def register_box(self, name: str, box: widgets.boxes.Box) -&gt; None:\n\"\"\"Registers a new Box type.\n\n        Args:\n            name: The name of the box.\n            box: The box instance.\n        \"\"\"\n\n        self.known_boxes[name] = box\n\n    def register(self, cls: Type[Widget]) -&gt; None:\n\"\"\"Makes object aware of a custom widget class, so\n        it can be serialized.\n\n        Args:\n            cls: The widget type to register.\n\n        Raises:\n            TypeError: The object is not a type.\n        \"\"\"\n\n        if not isinstance(cls, type):\n            raise TypeError(\"Registered object must be a type.\")\n\n        self.known_widgets[cls.__name__] = cls\n\n    def bind(self, name: str, method: Callable[..., Any]) -&gt; None:\n\"\"\"Binds a name to a method.\n\n        These method callables are substituted into all fields that follow\n        the `method:&lt;method_name&gt;` syntax. If `method_name` is not bound,\n        an exception will be raised during loading.\n\n        Args:\n            name: The name of the method, as referenced in the loaded\n                files.\n            method: The callable to bind.\n        \"\"\"\n\n        self.bound_methods[name] = method\n\n    def from_dict(  # pylint: disable=too-many-locals, too-many-branches\n        self, data: dict[str, Any], widget_type: str | None = None\n    ) -&gt; Widget:\n\"\"\"Loads a widget from a dictionary.\n\n        Args:\n            data: The data to load from.\n            widget_type: Substitute for when data has no `type` field.\n\n        Returns:\n            A widget from the given data.\n        \"\"\"\n\n        def _apply_markup(value: CharType) -&gt; CharType:\n\"\"\"Apply markup style to obj's key\"\"\"\n\n            formatted: CharType\n            if isinstance(value, list):\n                formatted = [tim.parse(val) for val in value]\n            else:\n                formatted = tim.parse(value)\n\n            return formatted\n\n        if widget_type is not None:\n            data[\"type\"] = widget_type\n\n        obj_class_name = data.get(\"type\")\n        if obj_class_name is None:\n            raise ValueError(\"Object with type None could not be loaded.\")\n\n        if obj_class_name not in self.known_widgets:\n            raise ValueError(\n                f'Object of type \"{obj_class_name}\" is not known!'\n                + f\" Register it with `serializer.register({obj_class_name})`.\"\n            )\n\n        del data[\"type\"]\n\n        obj_class = self.known_widgets.get(obj_class_name)\n        assert obj_class is not None\n\n        obj = obj_class()\n\n        for key, value in data.items():\n            if key.startswith(\"widgets\"):\n                for inner in value:\n                    name, widget = list(inner.items())[0]\n                    new = self.from_dict(widget, widget_type=name)\n                    assert hasattr(obj, \"__iadd__\")\n\n                    # this object can be added to, since\n                    # it has an __iadd__ method.\n                    obj += new  # type: ignore\n\n                continue\n\n            if isinstance(value, str) and value.startswith(\"method:\"):\n                name = value[7:]\n\n                if name not in self.bound_methods:\n                    raise KeyError(f'Reference to unbound method: \"{name}\".')\n\n                value = self.bound_methods[name]\n\n            if key == \"chars\":\n                chars: dict[str, CharType] = {}\n                for name, char in value.items():\n                    chars[name] = _apply_markup(char)\n\n                setattr(obj, \"chars\", chars)\n                continue\n\n            if key == \"styles\":\n                for name, markup_str in value.items():\n                    obj.styles[name] = markup_str\n\n                continue\n\n            setattr(obj, key, value)\n\n        return obj\n\n    def from_file(self, file: IO[str]) -&gt; Widget:\n\"\"\"Loads widget from a file object.\n\n        Args:\n            file: An IO object.\n\n        Returns:\n            The loaded widget.\n        \"\"\"\n\n        return self.from_dict(json.load(file))\n\n    def to_file(self, obj: Widget, file: IO[str], **json_args: dict[str, Any]) -&gt; None:\n\"\"\"Dumps widget to a file object.\n\n        Args:\n            obj: The widget to dump.\n            file: The file object it gets written to.\n            **json_args: Arguments passed to `json.dump`.\n        \"\"\"\n\n        data = self.dump_to_dict(obj)\n        if \"separators\" not in json_args:\n            # this is a sub-element of a dict[str, Any], so this\n            # should work.\n            json_args[\"separators\"] = (\",\", \":\")  # type: ignore\n\n        # ** is supposed to be a dict, not a positional arg\n        json.dump(data, file, **json_args)  # type: ignore\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.__init__","title":"<code>__init__()</code>","text":"<p>Sets up known widgets.</p> Source code in <code>pytermgui/serialization.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Sets up known widgets.\"\"\"\n\n    self.known_widgets = self.get_widgets()\n    self.known_boxes = vars(widgets.boxes)\n    self.register(Window)\n\n    self.bound_methods: dict[str, Callable[..., Any]] = {}\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.bind","title":"<code>bind(name, method)</code>","text":"<p>Binds a name to a method.</p> <p>These method callables are substituted into all fields that follow the <code>method:&lt;method_name&gt;</code> syntax. If <code>method_name</code> is not bound, an exception will be raised during loading.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the method, as referenced in the loaded files.</p> required <code>method</code> <code>Callable[..., Any]</code> <p>The callable to bind.</p> required Source code in <code>pytermgui/serialization.py</code> <pre><code>def bind(self, name: str, method: Callable[..., Any]) -&gt; None:\n\"\"\"Binds a name to a method.\n\n    These method callables are substituted into all fields that follow\n    the `method:&lt;method_name&gt;` syntax. If `method_name` is not bound,\n    an exception will be raised during loading.\n\n    Args:\n        name: The name of the method, as referenced in the loaded\n            files.\n        method: The callable to bind.\n    \"\"\"\n\n    self.bound_methods[name] = method\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.dump_to_dict","title":"<code>dump_to_dict(obj)</code>  <code>staticmethod</code>","text":"<p>Dump widget to a dict.</p> <p>This is an alias for <code>obj.serialize</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Widget</code> <p>The widget to dump.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p><code>obj.serialize()</code>.</p> Source code in <code>pytermgui/serialization.py</code> <pre><code>@staticmethod\ndef dump_to_dict(obj: Widget) -&gt; dict[str, Any]:\n\"\"\"Dump widget to a dict.\n\n    This is an alias for `obj.serialize`.\n\n    Args:\n        obj: The widget to dump.\n\n    Returns:\n        `obj.serialize()`.\n    \"\"\"\n\n    return obj.serialize()\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.from_dict","title":"<code>from_dict(data, widget_type=None)</code>","text":"<p>Loads a widget from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The data to load from.</p> required <code>widget_type</code> <code>str | None</code> <p>Substitute for when data has no <code>type</code> field.</p> <code>None</code> <p>Returns:</p> Type Description <code>Widget</code> <p>A widget from the given data.</p> Source code in <code>pytermgui/serialization.py</code> <pre><code>def from_dict(  # pylint: disable=too-many-locals, too-many-branches\n    self, data: dict[str, Any], widget_type: str | None = None\n) -&gt; Widget:\n\"\"\"Loads a widget from a dictionary.\n\n    Args:\n        data: The data to load from.\n        widget_type: Substitute for when data has no `type` field.\n\n    Returns:\n        A widget from the given data.\n    \"\"\"\n\n    def _apply_markup(value: CharType) -&gt; CharType:\n\"\"\"Apply markup style to obj's key\"\"\"\n\n        formatted: CharType\n        if isinstance(value, list):\n            formatted = [tim.parse(val) for val in value]\n        else:\n            formatted = tim.parse(value)\n\n        return formatted\n\n    if widget_type is not None:\n        data[\"type\"] = widget_type\n\n    obj_class_name = data.get(\"type\")\n    if obj_class_name is None:\n        raise ValueError(\"Object with type None could not be loaded.\")\n\n    if obj_class_name not in self.known_widgets:\n        raise ValueError(\n            f'Object of type \"{obj_class_name}\" is not known!'\n            + f\" Register it with `serializer.register({obj_class_name})`.\"\n        )\n\n    del data[\"type\"]\n\n    obj_class = self.known_widgets.get(obj_class_name)\n    assert obj_class is not None\n\n    obj = obj_class()\n\n    for key, value in data.items():\n        if key.startswith(\"widgets\"):\n            for inner in value:\n                name, widget = list(inner.items())[0]\n                new = self.from_dict(widget, widget_type=name)\n                assert hasattr(obj, \"__iadd__\")\n\n                # this object can be added to, since\n                # it has an __iadd__ method.\n                obj += new  # type: ignore\n\n            continue\n\n        if isinstance(value, str) and value.startswith(\"method:\"):\n            name = value[7:]\n\n            if name not in self.bound_methods:\n                raise KeyError(f'Reference to unbound method: \"{name}\".')\n\n            value = self.bound_methods[name]\n\n        if key == \"chars\":\n            chars: dict[str, CharType] = {}\n            for name, char in value.items():\n                chars[name] = _apply_markup(char)\n\n            setattr(obj, \"chars\", chars)\n            continue\n\n        if key == \"styles\":\n            for name, markup_str in value.items():\n                obj.styles[name] = markup_str\n\n            continue\n\n        setattr(obj, key, value)\n\n    return obj\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.from_file","title":"<code>from_file(file)</code>","text":"<p>Loads widget from a file object.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>IO[str]</code> <p>An IO object.</p> required <p>Returns:</p> Type Description <code>Widget</code> <p>The loaded widget.</p> Source code in <code>pytermgui/serialization.py</code> <pre><code>def from_file(self, file: IO[str]) -&gt; Widget:\n\"\"\"Loads widget from a file object.\n\n    Args:\n        file: An IO object.\n\n    Returns:\n        The loaded widget.\n    \"\"\"\n\n    return self.from_dict(json.load(file))\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.get_widgets","title":"<code>get_widgets()</code>  <code>staticmethod</code>","text":"<p>Gets all widgets from the module.</p> Source code in <code>pytermgui/serialization.py</code> <pre><code>@staticmethod\ndef get_widgets() -&gt; WidgetDict:\n\"\"\"Gets all widgets from the module.\"\"\"\n\n    known = {}\n    for name, item in vars(widgets).items():\n        if not isinstance(item, type):\n            continue\n\n        if issubclass(item, Widget):\n            known[name] = item\n\n    return known\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.register","title":"<code>register(cls)</code>","text":"<p>Makes object aware of a custom widget class, so it can be serialized.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[Widget]</code> <p>The widget type to register.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>The object is not a type.</p> Source code in <code>pytermgui/serialization.py</code> <pre><code>def register(self, cls: Type[Widget]) -&gt; None:\n\"\"\"Makes object aware of a custom widget class, so\n    it can be serialized.\n\n    Args:\n        cls: The widget type to register.\n\n    Raises:\n        TypeError: The object is not a type.\n    \"\"\"\n\n    if not isinstance(cls, type):\n        raise TypeError(\"Registered object must be a type.\")\n\n    self.known_widgets[cls.__name__] = cls\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.register_box","title":"<code>register_box(name, box)</code>","text":"<p>Registers a new Box type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the box.</p> required <code>box</code> <code>widgets.boxes.Box</code> <p>The box instance.</p> required Source code in <code>pytermgui/serialization.py</code> <pre><code>def register_box(self, name: str, box: widgets.boxes.Box) -&gt; None:\n\"\"\"Registers a new Box type.\n\n    Args:\n        name: The name of the box.\n        box: The box instance.\n    \"\"\"\n\n    self.known_boxes[name] = box\n</code></pre>"},{"location":"reference/pytermgui/serialization/#pytermgui.serialization.Serializer.to_file","title":"<code>to_file(obj, file, **json_args)</code>","text":"<p>Dumps widget to a file object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Widget</code> <p>The widget to dump.</p> required <code>file</code> <code>IO[str]</code> <p>The file object it gets written to.</p> required <code>**json_args</code> <code>dict[str, Any]</code> <p>Arguments passed to <code>json.dump</code>.</p> <code>{}</code> Source code in <code>pytermgui/serialization.py</code> <pre><code>def to_file(self, obj: Widget, file: IO[str], **json_args: dict[str, Any]) -&gt; None:\n\"\"\"Dumps widget to a file object.\n\n    Args:\n        obj: The widget to dump.\n        file: The file object it gets written to.\n        **json_args: Arguments passed to `json.dump`.\n    \"\"\"\n\n    data = self.dump_to_dict(obj)\n    if \"separators\" not in json_args:\n        # this is a sub-element of a dict[str, Any], so this\n        # should work.\n        json_args[\"separators\"] = (\",\", \":\")  # type: ignore\n\n    # ** is supposed to be a dict, not a positional arg\n    json.dump(data, file, **json_args)  # type: ignore\n</code></pre>"},{"location":"reference/pytermgui/term/","title":"term","text":"<p>This module houses the <code>Terminal</code> class, and its provided instance.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.terminal","title":"<code>terminal = Terminal()</code>  <code>module-attribute</code>","text":"<p>Terminal instance that should be used pretty much always.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem","title":"<code>ColorSystem</code>","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration of various terminal-supported colorsystems.</p> Source code in <code>pytermgui/term.py</code> <pre><code>class ColorSystem(Enum):\n\"\"\"An enumeration of various terminal-supported colorsystems.\"\"\"\n\n    NO_COLOR = -1\n\"\"\"No-color terminal. See https://no-color.org/.\"\"\"\n\n    STANDARD = 0\n\"\"\"Standard 3-bit colorsystem of the basic 16 colors.\"\"\"\n\n    EIGHT_BIT = 1\n\"\"\"xterm 8-bit colors, 0-256.\"\"\"\n\n    TRUE = 2\n\"\"\"'True' color, a.k.a. 24-bit RGB colors.\"\"\"\n\n    def __ge__(self, other):\n\"\"\"Comparison: self &gt;= other.\"\"\"\n\n        if self.__class__ is other.__class__:\n            return self.value &gt;= other.value\n\n        return NotImplemented\n\n    def __gt__(self, other):\n\"\"\"Comparison: self &gt; other.\"\"\"\n\n        if self.__class__ is other.__class__:\n            return self.value &gt; other.value\n\n        return NotImplemented\n\n    def __le__(self, other):\n\"\"\"Comparison: self &lt;= other.\"\"\"\n\n        if self.__class__ is other.__class__:\n            return self.value &lt;= other.value\n\n        return NotImplemented\n\n    def __lt__(self, other):\n\"\"\"Comparison: self &lt; other.\"\"\"\n\n        if self.__class__ is other.__class__:\n            return self.value &lt; other.value\n\n        return NotImplemented\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.EIGHT_BIT","title":"<code>EIGHT_BIT = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>xterm 8-bit colors, 0-256.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.NO_COLOR","title":"<code>NO_COLOR = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No-color terminal. See https://no-color.org/.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.STANDARD","title":"<code>STANDARD = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Standard 3-bit colorsystem of the basic 16 colors.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.TRUE","title":"<code>TRUE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>'True' color, a.k.a. 24-bit RGB colors.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Comparison: self &gt;= other.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def __ge__(self, other):\n\"\"\"Comparison: self &gt;= other.\"\"\"\n\n    if self.__class__ is other.__class__:\n        return self.value &gt;= other.value\n\n    return NotImplemented\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Comparison: self &gt; other.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def __gt__(self, other):\n\"\"\"Comparison: self &gt; other.\"\"\"\n\n    if self.__class__ is other.__class__:\n        return self.value &gt; other.value\n\n    return NotImplemented\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.__le__","title":"<code>__le__(other)</code>","text":"<p>Comparison: self &lt;= other.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def __le__(self, other):\n\"\"\"Comparison: self &lt;= other.\"\"\"\n\n    if self.__class__ is other.__class__:\n        return self.value &lt;= other.value\n\n    return NotImplemented\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.ColorSystem.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Comparison: self &lt; other.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def __lt__(self, other):\n\"\"\"Comparison: self &lt; other.\"\"\"\n\n    if self.__class__ is other.__class__:\n        return self.value &lt; other.value\n\n    return NotImplemented\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder","title":"<code>Recorder</code>","text":"<p>A class that records &amp; exports terminal content.</p> Source code in <code>pytermgui/term.py</code> <pre><code>class Recorder:\n\"\"\"A class that records &amp; exports terminal content.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initializes the Recorder.\"\"\"\n\n        self.recording: list[tuple[str, float]] = []\n        self._start_stamp = time.time()\n\n    @property\n    def _content(self) -&gt; str:\n\"\"\"Returns the str part of self._recording\"\"\"\n\n        return \"\".join(data for data, _ in self.recording)\n\n    def write(self, data: str) -&gt; None:\n\"\"\"Writes to the recorder.\"\"\"\n\n        self.recording.append((data, time.time() - self._start_stamp))\n\n    def export_text(self) -&gt; str:\n\"\"\"Exports current content as plain text.\"\"\"\n\n        return strip_ansi(self._content)\n\n    def export_html(\n        self, prefix: str | None = None, inline_styles: bool = False\n    ) -&gt; str:\n\"\"\"Exports current content as HTML.\n\n        For help on the arguments, see `pytermgui.html.to_html`.\n        \"\"\"\n\n        from .exporters import to_html  # pylint: disable=import-outside-toplevel\n\n        return to_html(self._content, prefix=prefix, inline_styles=inline_styles)\n\n    def export_svg(\n        self,\n        prefix: str | None = None,\n        inline_styles: bool = False,\n        title: str = \"PyTermGUI\",\n        chrome: bool = True,\n    ) -&gt; str:\n\"\"\"Exports current content as SVG.\n\n        For help on the arguments, see `pytermgui.html.to_svg`.\n        \"\"\"\n\n        from .exporters import to_svg  # pylint: disable=import-outside-toplevel\n\n        return to_svg(\n            self._content,\n            prefix=prefix,\n            inline_styles=inline_styles,\n            title=title,\n            chrome=chrome,\n        )\n\n    def save_plain(self, filename: str) -&gt; None:\n\"\"\"Exports plain text content to the given file.\n\n        Args:\n            filename: The file to save to.\n        \"\"\"\n\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            file.write(self.export_text())\n\n    def save_html(\n        self,\n        filename: str | None = None,\n        prefix: str | None = None,\n        inline_styles: bool = False,\n    ) -&gt; None:\n\"\"\"Exports HTML content to the given file.\n\n        For help on the arguments, see `pytermgui.exporters.to_html`.\n\n        Args:\n            filename: The file to save to. If the filename does not contain the '.html'\n                extension it will be appended to the end.\n        \"\"\"\n\n        if filename is None:\n            filename = f\"PTG_{time.time():%Y-%m-%d %H:%M:%S}.html\"\n\n        if not filename.endswith(\".html\"):\n            filename += \".html\"\n\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            file.write(self.export_html(prefix=prefix, inline_styles=inline_styles))\n\n    def save_svg(  # pylint: disable=too-many-arguments\n        self,\n        filename: str | None = None,\n        prefix: str | None = None,\n        chrome: bool = True,\n        inline_styles: bool = False,\n        title: str = \"PyTermGUI\",\n    ) -&gt; None:\n\"\"\"Exports SVG content to the given file.\n\n        For help on the arguments, see `pytermgui.exporters.to_svg`.\n\n        Args:\n            filename: The file to save to. If the filename does not contain the '.svg'\n                extension it will be appended to the end.\n        \"\"\"\n\n        if filename is None:\n            timeval = datetime.now()\n            filename = f\"PTG_{timeval:%Y-%m-%d_%H:%M:%S}.svg\"\n\n        if not filename.endswith(\".svg\"):\n            filename += \".svg\"\n\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            file.write(\n                self.export_svg(\n                    prefix=prefix,\n                    inline_styles=inline_styles,\n                    title=title,\n                    chrome=chrome,\n                )\n            )\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Recorder.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initializes the Recorder.\"\"\"\n\n    self.recording: list[tuple[str, float]] = []\n    self._start_stamp = time.time()\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.export_html","title":"<code>export_html(prefix=None, inline_styles=False)</code>","text":"<p>Exports current content as HTML.</p> <p>For help on the arguments, see <code>pytermgui.html.to_html</code>.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def export_html(\n    self, prefix: str | None = None, inline_styles: bool = False\n) -&gt; str:\n\"\"\"Exports current content as HTML.\n\n    For help on the arguments, see `pytermgui.html.to_html`.\n    \"\"\"\n\n    from .exporters import to_html  # pylint: disable=import-outside-toplevel\n\n    return to_html(self._content, prefix=prefix, inline_styles=inline_styles)\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.export_svg","title":"<code>export_svg(prefix=None, inline_styles=False, title='PyTermGUI', chrome=True)</code>","text":"<p>Exports current content as SVG.</p> <p>For help on the arguments, see <code>pytermgui.html.to_svg</code>.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def export_svg(\n    self,\n    prefix: str | None = None,\n    inline_styles: bool = False,\n    title: str = \"PyTermGUI\",\n    chrome: bool = True,\n) -&gt; str:\n\"\"\"Exports current content as SVG.\n\n    For help on the arguments, see `pytermgui.html.to_svg`.\n    \"\"\"\n\n    from .exporters import to_svg  # pylint: disable=import-outside-toplevel\n\n    return to_svg(\n        self._content,\n        prefix=prefix,\n        inline_styles=inline_styles,\n        title=title,\n        chrome=chrome,\n    )\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.export_text","title":"<code>export_text()</code>","text":"<p>Exports current content as plain text.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def export_text(self) -&gt; str:\n\"\"\"Exports current content as plain text.\"\"\"\n\n    return strip_ansi(self._content)\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.save_html","title":"<code>save_html(filename=None, prefix=None, inline_styles=False)</code>","text":"<p>Exports HTML content to the given file.</p> <p>For help on the arguments, see <code>pytermgui.exporters.to_html</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | None</code> <p>The file to save to. If the filename does not contain the '.html' extension it will be appended to the end.</p> <code>None</code> Source code in <code>pytermgui/term.py</code> <pre><code>def save_html(\n    self,\n    filename: str | None = None,\n    prefix: str | None = None,\n    inline_styles: bool = False,\n) -&gt; None:\n\"\"\"Exports HTML content to the given file.\n\n    For help on the arguments, see `pytermgui.exporters.to_html`.\n\n    Args:\n        filename: The file to save to. If the filename does not contain the '.html'\n            extension it will be appended to the end.\n    \"\"\"\n\n    if filename is None:\n        filename = f\"PTG_{time.time():%Y-%m-%d %H:%M:%S}.html\"\n\n    if not filename.endswith(\".html\"):\n        filename += \".html\"\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        file.write(self.export_html(prefix=prefix, inline_styles=inline_styles))\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.save_plain","title":"<code>save_plain(filename)</code>","text":"<p>Exports plain text content to the given file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file to save to.</p> required Source code in <code>pytermgui/term.py</code> <pre><code>def save_plain(self, filename: str) -&gt; None:\n\"\"\"Exports plain text content to the given file.\n\n    Args:\n        filename: The file to save to.\n    \"\"\"\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        file.write(self.export_text())\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.save_svg","title":"<code>save_svg(filename=None, prefix=None, chrome=True, inline_styles=False, title='PyTermGUI')</code>","text":"<p>Exports SVG content to the given file.</p> <p>For help on the arguments, see <code>pytermgui.exporters.to_svg</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | None</code> <p>The file to save to. If the filename does not contain the '.svg' extension it will be appended to the end.</p> <code>None</code> Source code in <code>pytermgui/term.py</code> <pre><code>def save_svg(  # pylint: disable=too-many-arguments\n    self,\n    filename: str | None = None,\n    prefix: str | None = None,\n    chrome: bool = True,\n    inline_styles: bool = False,\n    title: str = \"PyTermGUI\",\n) -&gt; None:\n\"\"\"Exports SVG content to the given file.\n\n    For help on the arguments, see `pytermgui.exporters.to_svg`.\n\n    Args:\n        filename: The file to save to. If the filename does not contain the '.svg'\n            extension it will be appended to the end.\n    \"\"\"\n\n    if filename is None:\n        timeval = datetime.now()\n        filename = f\"PTG_{timeval:%Y-%m-%d_%H:%M:%S}.svg\"\n\n    if not filename.endswith(\".svg\"):\n        filename += \".svg\"\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        file.write(\n            self.export_svg(\n                prefix=prefix,\n                inline_styles=inline_styles,\n                title=title,\n                chrome=chrome,\n            )\n        )\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Recorder.write","title":"<code>write(data)</code>","text":"<p>Writes to the recorder.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def write(self, data: str) -&gt; None:\n\"\"\"Writes to the recorder.\"\"\"\n\n    self.recording.append((data, time.time() - self._start_stamp))\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal","title":"<code>Terminal</code>","text":"<p>A class to store &amp; access data about a terminal.</p> Source code in <code>pytermgui/term.py</code> <pre><code>class Terminal:  # pylint: disable=too-many-instance-attributes\n\"\"\"A class to store &amp; access data about a terminal.\"\"\"\n\n    RESIZE = 0\n\"\"\"Event sent out when the terminal has been resized.\n\n    Arguments passed:\n    - New size: tuple[int, int]\n    \"\"\"\n\n    margins = [0, 0, 0, 0]\n\"\"\"Not quite sure what this does at the moment.\"\"\"\n\n    displayhook_installed: bool = False\n\"\"\"This is set to True when `pretty.install` is called.\"\"\"\n\n    origin: tuple[int, int] = (1, 1)\n\"\"\"Origin of the internal coordinate system.\"\"\"\n\n    def __init__(\n        self,\n        stream: TextIO | None = None,\n        *,\n        size: tuple[int, int] | None = None,\n    ) -&gt; None:\n\"\"\"Initialize `Terminal` class.\"\"\"\n\n        if stream is None:\n            stream = sys.stdout\n\n        self._size = size\n        self._stream = stream or sys.stdout\n\n        self._recorder: Recorder | None = None\n\n        self.size: tuple[int, int] = self._get_size()\n        self.forced_colorsystem: ColorSystem | None = _get_env_colorsys()\n\n        self._listeners: dict[int, list[Callable[..., Any]]] = {}\n\n        if hasattr(signal, \"SIGWINCH\"):\n            signal.signal(signal.SIGWINCH, self._update_size)\n        else:\n            from threading import Thread  # pylint: disable=import-outside-toplevel\n\n            Thread(\n                name=\"windows_terminal_resize\",\n                target=self._window_terminal_resize,\n                daemon=True,\n            ).start()\n\n        self._diff_buffer = [\n            [\"\" for _ in range(self.width)] for y in range(self.height)\n        ]\n\n    def _window_terminal_resize(self):\n        from time import sleep  # pylint: disable=import-outside-toplevel\n\n        _previous = get_terminal_size()\n        while True:\n            _next = get_terminal_size()\n            if _previous != _next:\n                self._update_size()\n                _previous = _next\n            sleep(0.001)\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Returns a cool looking repr.\"\"\"\n\n        name = type(self).__name__\n\n        yield f\"&lt;{name} stream={self._stream} size={self.size}&gt;\"\n\n    @cached_property\n    def resolution(self) -&gt; tuple[int, int]:\n\"\"\"Returns the terminal's pixel based resolution.\n\n        Only evaluated on demand.\n        \"\"\"\n\n        if self.isatty():\n            sys.stdout.write(\"\\x1b[14t\")\n            sys.stdout.flush()\n\n            # Some terminals may not respond to a pixel size query, so we send\n            # a timed-out getch call with a default response of 1280x720.\n            output = getch_timeout(0.1, default=\"\\x1b[4;720;1280t\")\n            match = RE_PIXEL_SIZE.match(output)\n\n            if match is not None:\n                return (int(match[2]), int(match[1]))\n\n        return (0, 0)\n\n    @property\n    def pixel_size(self) -&gt; tuple[int, int]:\n\"\"\"DEPRECATED: Returns the terminal's pixel resolution.\n\n        Prefer terminal.resolution.\n        \"\"\"\n\n        return self.resolution\n\n    def _call_listener(self, event: int, data: Any) -&gt; None:\n\"\"\"Calls callbacks for event.\n\n        Args:\n            event: A terminal event.\n            data: Arbitrary data passed to the callback.\n        \"\"\"\n\n        if event in self._listeners:\n            for callback in self._listeners[event]:\n                callback(data)\n\n    def _get_size(self) -&gt; tuple[int, int]:\n\"\"\"Gets the screen size with origin substracted.\"\"\"\n\n        if self._size is not None:\n            return self._size\n\n        size = get_terminal_size()\n        return (size[0], size[1])\n\n    def _update_size(self, *_: Any) -&gt; None:\n\"\"\"Resize terminal when SIGWINCH occurs, and call listeners.\"\"\"\n\n        if hasattr(self, \"resolution\"):\n            del self.resolution\n\n        self.size = self._get_size()\n\n        self._call_listener(self.RESIZE, self.size)\n\n        # Wipe the screen in case anything got messed up\n        self.write(\"\\x1b[2J\")\n\n    @property\n    def width(self) -&gt; int:\n\"\"\"Gets the current width of the terminal.\"\"\"\n\n        return self.size[0]\n\n    @property\n    def height(self) -&gt; int:\n\"\"\"Gets the current height of the terminal.\"\"\"\n\n        return self.size[1]\n\n    @staticmethod\n    def is_interactive() -&gt; bool:\n\"\"\"Determines whether shell is interactive.\n\n        A shell is interactive if it is run from `python3` or `python3 -i`.\n        \"\"\"\n\n        return hasattr(sys, \"ps1\")\n\n    @property\n    def forced_colorsystem(self) -&gt; ColorSystem | None:\n\"\"\"Forces a color system type on this terminal.\"\"\"\n\n        return self._forced_colorsystem\n\n    @forced_colorsystem.setter\n    def forced_colorsystem(self, new: ColorSystem | None) -&gt; None:\n\"\"\"Sets a colorsystem, clears colorsystem cache.\"\"\"\n\n        self._forced_colorsystem = new\n\n    @property\n    def colorsystem(self) -&gt; ColorSystem:\n\"\"\"Gets the current terminal's supported color system.\"\"\"\n\n        if self.forced_colorsystem is not None:\n            return self.forced_colorsystem\n\n        if os.getenv(\"NO_COLOR\") is not None:\n            return ColorSystem.NO_COLOR\n\n        term = os.getenv(\"TERM\", \"\")\n        color_term = os.getenv(\"COLORTERM\", \"\").strip().lower()\n\n        if color_term == \"\":\n            color_term = term.split(\"xterm-\")[-1]\n\n        if color_term in [\"24bit\", \"truecolor\"]:\n            return ColorSystem.TRUE\n\n        if color_term == \"256color\":\n            return ColorSystem.EIGHT_BIT\n\n        return ColorSystem.STANDARD\n\n    @contextmanager\n    def record(self) -&gt; Generator[Recorder, None, None]:\n\"\"\"Records the terminal's stream.\"\"\"\n\n        if self._recorder is not None:\n            raise RuntimeError(f\"{self!r} is already recording.\")\n\n        try:\n            self._recorder = Recorder()\n            yield self._recorder\n\n        finally:\n            self._recorder = None\n\n    @contextmanager\n    def no_record(self) -&gt; Generator[None, None, None]:\n\"\"\"Pauses recording for the duration of the context.\"\"\"\n\n        recorder = self._recorder\n\n        try:\n            self._recorder = None\n            yield\n\n        finally:\n            self._recorder = recorder\n\n    @contextmanager\n    def frame(self) -&gt; Generator[StringIO, None, None]:\n\"\"\"Notifies the emulator of the inner content being a single frame.\n\n        See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036!\n        \"\"\"\n\n        buffer = StringIO()\n\n        try:\n            with self.no_record():\n                self.write(\"\\x1b[?2026h\")\n            yield buffer\n\n        finally:\n            self.write(buffer.getvalue())\n            with self.no_record():\n                self.write(\"\\x1b[?2026l\")\n            self.flush()\n\n    @staticmethod\n    def isatty() -&gt; bool:\n\"\"\"Returns whether sys.stdin is a tty.\"\"\"\n\n        return sys.stdin.isatty()\n\n    def replay(self, recorder: Recorder) -&gt; None:\n\"\"\"Replays a recording.\"\"\"\n\n        last_time = 0.0\n        for data, delay in recorder.recording:\n            if last_time &gt; 0.0:\n                time.sleep(delay - last_time)\n\n            self.write(data, flush=True)\n            last_time = delay\n\n    def subscribe(self, event: int, callback: Callable[..., Any]) -&gt; None:\n\"\"\"Subcribes a callback to be called when event occurs.\n\n        Args:\n            event: The terminal event that calls callback.\n            callback: The callable to be called. The signature of this\n                callable is dependent on the event. See the documentation\n                of the specific event for more information.\n        \"\"\"\n\n        if not event in self._listeners:\n            self._listeners[event] = []\n\n        self._listeners[event].append(callback)\n\n    def write(\n        self,\n        data: str,\n        pos: tuple[int, int] | None = None,\n        flush: bool = False,\n        slice_too_long: bool = True,\n    ) -&gt; None:\n\"\"\"Writes the given data to the terminal's stream.\n\n        Args:\n            data: The data to write.\n            pos: Terminal-character space position to write the data to, (x, y).\n            flush: If set, `flush` will be called on the stream after reading.\n            slice_too_long: If set, lines that are outside of the terminal will be\n                sliced to fit. Involves a sizable performance hit.\n        \"\"\"\n\n        def _slice(line: str, maximum: int) -&gt; str:\n            length = 0\n            sliced = \"\"\n            for char in line:\n                sliced += char\n                if char == \"\\x1b\":\n                    continue\n\n                if (\n                    length &gt; maximum\n                    and real_length(sliced) &gt; maximum\n                    and not has_open_sequence(sliced)\n                ):\n                    break\n\n                length += 1\n\n            return sliced\n\n        if \"\\x1b[2J\" in data:\n            self.clear_stream()\n\n        if pos is not None:\n            xpos, ypos = pos\n            xpos += self.origin[0]\n            ypos += self.origin[1]\n\n            if slice_too_long:\n                if not self.height + self.origin[1] + 1 &gt; ypos &gt;= 0:\n                    return\n\n                maximum = self.width - xpos\n\n                if xpos &lt; self.origin[0]:\n                    xpos = self.origin[0]\n\n                sliced = _slice(data, maximum) if len(data) &gt; maximum else data\n\n                data = f\"\\x1b[{ypos};{xpos}H{sliced}\\x1b[0m\"\n\n            else:\n                data = f\"\\x1b[{ypos};{xpos}H{data}\"\n\n        self._stream.write(data)\n\n        if self._recorder is not None:\n            self._recorder.write(data)\n\n        if flush:\n            self._stream.flush()\n\n    def clear_stream(self) -&gt; None:\n\"\"\"Clears (truncates) the terminal's stream.\"\"\"\n\n        try:\n            self._stream.truncate(0)\n\n        except OSError as error:\n            if error.errno != errno.EINVAL and os.name != \"nt\":\n                raise\n\n        self._stream.write(\"\\x1b[2J\")\n\n    def print(\n        self,\n        *items,\n        pos: tuple[int, int] | None = None,\n        sep: str = \" \",\n        end=\"\\n\",\n        flush: bool = True,\n    ) -&gt; None:\n\"\"\"Prints items to the stream.\n\n        All arguments not mentioned here are analogous to `print`.\n\n        Args:\n            pos: Terminal-character space position to write the data to, (x, y).\n\n        \"\"\"\n\n        self.write(sep.join(map(str, items)) + end, pos=pos, flush=flush)\n\n    def flush(self) -&gt; None:\n\"\"\"Flushes self._stream.\"\"\"\n\n        self._stream.flush()\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.RESIZE","title":"<code>RESIZE = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Event sent out when the terminal has been resized.</p> <p>Arguments passed: - New size: tuple[int, int]</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.colorsystem","title":"<code>colorsystem: ColorSystem</code>  <code>property</code>","text":"<p>Gets the current terminal's supported color system.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.displayhook_installed","title":"<code>displayhook_installed: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>This is set to True when <code>pretty.install</code> is called.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.forced_colorsystem","title":"<code>forced_colorsystem: ColorSystem | None</code>  <code>property</code> <code>writable</code>","text":"<p>Forces a color system type on this terminal.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.height","title":"<code>height: int</code>  <code>property</code>","text":"<p>Gets the current height of the terminal.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.margins","title":"<code>margins = [0, 0, 0, 0]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Not quite sure what this does at the moment.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.origin","title":"<code>origin: tuple[int, int] = (1, 1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Origin of the internal coordinate system.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.pixel_size","title":"<code>pixel_size: tuple[int, int]</code>  <code>property</code>","text":"<p>DEPRECATED: Returns the terminal's pixel resolution.</p> <p>Prefer terminal.resolution.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.resolution","title":"<code>resolution: tuple[int, int]</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the terminal's pixel based resolution.</p> <p>Only evaluated on demand.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.width","title":"<code>width: int</code>  <code>property</code>","text":"<p>Gets the current width of the terminal.</p>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.__fancy_repr__","title":"<code>__fancy_repr__()</code>","text":"<p>Returns a cool looking repr.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Returns a cool looking repr.\"\"\"\n\n    name = type(self).__name__\n\n    yield f\"&lt;{name} stream={self._stream} size={self.size}&gt;\"\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.__init__","title":"<code>__init__(stream=None, *, size=None)</code>","text":"<p>Initialize <code>Terminal</code> class.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def __init__(\n    self,\n    stream: TextIO | None = None,\n    *,\n    size: tuple[int, int] | None = None,\n) -&gt; None:\n\"\"\"Initialize `Terminal` class.\"\"\"\n\n    if stream is None:\n        stream = sys.stdout\n\n    self._size = size\n    self._stream = stream or sys.stdout\n\n    self._recorder: Recorder | None = None\n\n    self.size: tuple[int, int] = self._get_size()\n    self.forced_colorsystem: ColorSystem | None = _get_env_colorsys()\n\n    self._listeners: dict[int, list[Callable[..., Any]]] = {}\n\n    if hasattr(signal, \"SIGWINCH\"):\n        signal.signal(signal.SIGWINCH, self._update_size)\n    else:\n        from threading import Thread  # pylint: disable=import-outside-toplevel\n\n        Thread(\n            name=\"windows_terminal_resize\",\n            target=self._window_terminal_resize,\n            daemon=True,\n        ).start()\n\n    self._diff_buffer = [\n        [\"\" for _ in range(self.width)] for y in range(self.height)\n    ]\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.clear_stream","title":"<code>clear_stream()</code>","text":"<p>Clears (truncates) the terminal's stream.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def clear_stream(self) -&gt; None:\n\"\"\"Clears (truncates) the terminal's stream.\"\"\"\n\n    try:\n        self._stream.truncate(0)\n\n    except OSError as error:\n        if error.errno != errno.EINVAL and os.name != \"nt\":\n            raise\n\n    self._stream.write(\"\\x1b[2J\")\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.flush","title":"<code>flush()</code>","text":"<p>Flushes self._stream.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def flush(self) -&gt; None:\n\"\"\"Flushes self._stream.\"\"\"\n\n    self._stream.flush()\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.frame","title":"<code>frame()</code>","text":"<p>Notifies the emulator of the inner content being a single frame.</p> <p>See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036!</p> Source code in <code>pytermgui/term.py</code> <pre><code>@contextmanager\ndef frame(self) -&gt; Generator[StringIO, None, None]:\n\"\"\"Notifies the emulator of the inner content being a single frame.\n\n    See https://gist.github.com/christianparpart/d8a62cc1ab659194337d73e399004036!\n    \"\"\"\n\n    buffer = StringIO()\n\n    try:\n        with self.no_record():\n            self.write(\"\\x1b[?2026h\")\n        yield buffer\n\n    finally:\n        self.write(buffer.getvalue())\n        with self.no_record():\n            self.write(\"\\x1b[?2026l\")\n        self.flush()\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.is_interactive","title":"<code>is_interactive()</code>  <code>staticmethod</code>","text":"<p>Determines whether shell is interactive.</p> <p>A shell is interactive if it is run from <code>python3</code> or <code>python3 -i</code>.</p> Source code in <code>pytermgui/term.py</code> <pre><code>@staticmethod\ndef is_interactive() -&gt; bool:\n\"\"\"Determines whether shell is interactive.\n\n    A shell is interactive if it is run from `python3` or `python3 -i`.\n    \"\"\"\n\n    return hasattr(sys, \"ps1\")\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.isatty","title":"<code>isatty()</code>  <code>staticmethod</code>","text":"<p>Returns whether sys.stdin is a tty.</p> Source code in <code>pytermgui/term.py</code> <pre><code>@staticmethod\ndef isatty() -&gt; bool:\n\"\"\"Returns whether sys.stdin is a tty.\"\"\"\n\n    return sys.stdin.isatty()\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.no_record","title":"<code>no_record()</code>","text":"<p>Pauses recording for the duration of the context.</p> Source code in <code>pytermgui/term.py</code> <pre><code>@contextmanager\ndef no_record(self) -&gt; Generator[None, None, None]:\n\"\"\"Pauses recording for the duration of the context.\"\"\"\n\n    recorder = self._recorder\n\n    try:\n        self._recorder = None\n        yield\n\n    finally:\n        self._recorder = recorder\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.print","title":"<code>print(*items, pos=None, sep=' ', end='\\n', flush=True)</code>","text":"<p>Prints items to the stream.</p> <p>All arguments not mentioned here are analogous to <code>print</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int] | None</code> <p>Terminal-character space position to write the data to, (x, y).</p> <code>None</code> Source code in <code>pytermgui/term.py</code> <pre><code>def print(\n    self,\n    *items,\n    pos: tuple[int, int] | None = None,\n    sep: str = \" \",\n    end=\"\\n\",\n    flush: bool = True,\n) -&gt; None:\n\"\"\"Prints items to the stream.\n\n    All arguments not mentioned here are analogous to `print`.\n\n    Args:\n        pos: Terminal-character space position to write the data to, (x, y).\n\n    \"\"\"\n\n    self.write(sep.join(map(str, items)) + end, pos=pos, flush=flush)\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.record","title":"<code>record()</code>","text":"<p>Records the terminal's stream.</p> Source code in <code>pytermgui/term.py</code> <pre><code>@contextmanager\ndef record(self) -&gt; Generator[Recorder, None, None]:\n\"\"\"Records the terminal's stream.\"\"\"\n\n    if self._recorder is not None:\n        raise RuntimeError(f\"{self!r} is already recording.\")\n\n    try:\n        self._recorder = Recorder()\n        yield self._recorder\n\n    finally:\n        self._recorder = None\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.replay","title":"<code>replay(recorder)</code>","text":"<p>Replays a recording.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def replay(self, recorder: Recorder) -&gt; None:\n\"\"\"Replays a recording.\"\"\"\n\n    last_time = 0.0\n    for data, delay in recorder.recording:\n        if last_time &gt; 0.0:\n            time.sleep(delay - last_time)\n\n        self.write(data, flush=True)\n        last_time = delay\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.subscribe","title":"<code>subscribe(event, callback)</code>","text":"<p>Subcribes a callback to be called when event occurs.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>int</code> <p>The terminal event that calls callback.</p> required <code>callback</code> <code>Callable[..., Any]</code> <p>The callable to be called. The signature of this callable is dependent on the event. See the documentation of the specific event for more information.</p> required Source code in <code>pytermgui/term.py</code> <pre><code>def subscribe(self, event: int, callback: Callable[..., Any]) -&gt; None:\n\"\"\"Subcribes a callback to be called when event occurs.\n\n    Args:\n        event: The terminal event that calls callback.\n        callback: The callable to be called. The signature of this\n            callable is dependent on the event. See the documentation\n            of the specific event for more information.\n    \"\"\"\n\n    if not event in self._listeners:\n        self._listeners[event] = []\n\n    self._listeners[event].append(callback)\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.Terminal.write","title":"<code>write(data, pos=None, flush=False, slice_too_long=True)</code>","text":"<p>Writes the given data to the terminal's stream.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to write.</p> required <code>pos</code> <code>tuple[int, int] | None</code> <p>Terminal-character space position to write the data to, (x, y).</p> <code>None</code> <code>flush</code> <code>bool</code> <p>If set, <code>flush</code> will be called on the stream after reading.</p> <code>False</code> <code>slice_too_long</code> <code>bool</code> <p>If set, lines that are outside of the terminal will be sliced to fit. Involves a sizable performance hit.</p> <code>True</code> Source code in <code>pytermgui/term.py</code> <pre><code>def write(\n    self,\n    data: str,\n    pos: tuple[int, int] | None = None,\n    flush: bool = False,\n    slice_too_long: bool = True,\n) -&gt; None:\n\"\"\"Writes the given data to the terminal's stream.\n\n    Args:\n        data: The data to write.\n        pos: Terminal-character space position to write the data to, (x, y).\n        flush: If set, `flush` will be called on the stream after reading.\n        slice_too_long: If set, lines that are outside of the terminal will be\n            sliced to fit. Involves a sizable performance hit.\n    \"\"\"\n\n    def _slice(line: str, maximum: int) -&gt; str:\n        length = 0\n        sliced = \"\"\n        for char in line:\n            sliced += char\n            if char == \"\\x1b\":\n                continue\n\n            if (\n                length &gt; maximum\n                and real_length(sliced) &gt; maximum\n                and not has_open_sequence(sliced)\n            ):\n                break\n\n            length += 1\n\n        return sliced\n\n    if \"\\x1b[2J\" in data:\n        self.clear_stream()\n\n    if pos is not None:\n        xpos, ypos = pos\n        xpos += self.origin[0]\n        ypos += self.origin[1]\n\n        if slice_too_long:\n            if not self.height + self.origin[1] + 1 &gt; ypos &gt;= 0:\n                return\n\n            maximum = self.width - xpos\n\n            if xpos &lt; self.origin[0]:\n                xpos = self.origin[0]\n\n            sliced = _slice(data, maximum) if len(data) &gt; maximum else data\n\n            data = f\"\\x1b[{ypos};{xpos}H{sliced}\\x1b[0m\"\n\n        else:\n            data = f\"\\x1b[{ypos};{xpos}H{data}\"\n\n    self._stream.write(data)\n\n    if self._recorder is not None:\n        self._recorder.write(data)\n\n    if flush:\n        self._stream.flush()\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.get_terminal","title":"<code>get_terminal()</code>","text":"<p>Gets the default terminal instance used by the module.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def get_terminal() -&gt; Terminal:\n\"\"\"Gets the default terminal instance used by the module.\"\"\"\n\n    return terminal\n</code></pre>"},{"location":"reference/pytermgui/term/#pytermgui.term.set_global_terminal","title":"<code>set_global_terminal(new)</code>","text":"<p>Sets the terminal instance to be used by the module.</p> Source code in <code>pytermgui/term.py</code> <pre><code>def set_global_terminal(new: Terminal) -&gt; None:\n\"\"\"Sets the terminal instance to be used by the module.\"\"\"\n\n    globals()[\"terminal\"] = new\n</code></pre>"},{"location":"reference/pytermgui/win32console/","title":"win32console","text":"<p>Interface for interacting with windows api console functions.</p> <p>The core export is the <code>enable_virtual_processing</code> context manager that redirects console input events and inputs them as ascii codes; this includes mouse input.</p> Credits <ul> <li>Implementation: Tired-Fox (Zachary)</li> </ul>"},{"location":"reference/pytermgui/win32console/#pytermgui.win32console.StdDevice","title":"<code>StdDevice</code>","text":"<p>             Bases: <code>Enum</code></p> <p>The available standard devices for windows.</p> Source code in <code>pytermgui/win32console.py</code> <pre><code>class StdDevice(Enum):\n\"\"\"The available standard devices for windows.\"\"\"\n\n    IN = -10\n    OUT = -11\n    ERR = -12\n</code></pre>"},{"location":"reference/pytermgui/win32console/#pytermgui.win32console.enable_virtual_processing","title":"<code>enable_virtual_processing()</code>","text":"<p>Dummy context manager for non windows systems</p> Source code in <code>pytermgui/win32console.py</code> <pre><code>@contextmanager\ndef enable_virtual_processing():\n\"\"\"Dummy context manager for non windows systems\"\"\"\n    try:\n        yield\n    finally:\n        pass\n</code></pre>"},{"location":"reference/pytermgui/win32console/#pytermgui.win32console.get_console_mode","title":"<code>get_console_mode(std)</code>","text":"<p>Get the console mode for the given standard device.</p> <p>Parameters:</p> Name Type Description Default <code>std</code> <code>HANDLE</code> <p>The handle to the standard device to get the settings from</p> required <p>Returns:</p> Name Type Description <code>False</code> <code>DWORD</code> <p>when setting the mode fails</p> Source code in <code>pytermgui/win32console.py</code> <pre><code>def get_console_mode(std: HANDLE) -&gt; DWORD:\n\"\"\"Get the console mode for the given standard device.\n\n    Args:\n        std (HANDLE): The handle to the standard device to get\n            the settings from\n\n    Returns:\n        False: when setting the mode fails\n    \"\"\"\n    mode = DWORD()\n    _GetConsoleMode(std, byref(mode))\n    return mode\n</code></pre>"},{"location":"reference/pytermgui/win32console/#pytermgui.win32console.get_std_handle","title":"<code>get_std_handle(handle=StdDevice.OUT)</code>","text":"<p>Retrieves a handle to the specified standard device (stdin, stdout, stderr)</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int</code> <p>Indentifier for the standard device. Defaults to -11 (stdout).</p> <code>StdDevice.OUT</code> <p>Returns:</p> Type Description <code>HANDLE</code> <p>wintypes.HANDLE: Handle to the standard device</p> Source code in <code>pytermgui/win32console.py</code> <pre><code>def get_std_handle(handle: StdDevice = StdDevice.OUT) -&gt; HANDLE:\n\"\"\"Retrieves a handle to the specified standard device (stdin, stdout, stderr)\n\n    Args:\n        handle (int): Indentifier for the standard device. Defaults to -11 (stdout).\n\n    Returns:\n        wintypes.HANDLE: Handle to the standard device\n    \"\"\"\n    return cast(HANDLE, _GetStdHandle(handle.value))\n</code></pre>"},{"location":"reference/pytermgui/win32console/#pytermgui.win32console.set_console_mode","title":"<code>set_console_mode(std, mode)</code>","text":"<p>Set the console mode for the given standard device.</p> <p>Parameters:</p> Name Type Description Default <code>std</code> <code>HANDLE</code> <p>The handle to the standard device</p> required <code>mode</code> <code>int</code> <p>The mode / setting flags to set to the device</p> required <p>Returns:</p> Type Description <code>bool</code> <p>False when setting the mode fails</p> Source code in <code>pytermgui/win32console.py</code> <pre><code>def set_console_mode(std: HANDLE, mode: int) -&gt; bool:\n\"\"\"Set the console mode for the given standard device.\n\n    Args:\n        std (HANDLE): The handle to the standard device\n        mode (int): The mode / setting flags to set to the device\n\n    Returns:\n        False when setting the mode fails\n    \"\"\"\n    return _SetConsoleMode(std, mode) != 0\n</code></pre>"},{"location":"reference/pytermgui/markup/","title":"Index","text":"<p>Everything related to the TIM language.</p>"},{"location":"reference/pytermgui/markup/aliases/","title":"aliases","text":"<p>All PTG-builtin TIM aliases.</p>"},{"location":"reference/pytermgui/markup/aliases/#pytermgui.markup.aliases.apply_default_aliases","title":"<code>apply_default_aliases(lang)</code>","text":"<p>Applies all aliases within <code>DEFAULT_ALIASES</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>MarkupLanguage</code> <p>The <code>MarkupLanguage</code> instance all aliases will be applied to.</p> required Source code in <code>pytermgui/markup/aliases.py</code> <pre><code>def apply_default_aliases(lang: MarkupLanguage) -&gt; None:\n\"\"\"Applies all aliases within `DEFAULT_ALIASES`.\n\n    Args:\n        lang: The `MarkupLanguage` instance all aliases will be\n            applied to.\n    \"\"\"\n\n    lang.alias_multiple(**DEFAULT_ALIASES)\n</code></pre>"},{"location":"reference/pytermgui/markup/language/","title":"language","text":"<p>Wrappers around the TIM parsing engine, implementing caching and context management.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage","title":"<code>MarkupLanguage</code>","text":"<p>A relatively simple object that binds context to TIM parsing functions.</p> <p>Most of the job this class has is to pass along a <code>ContextDict</code> to various \"lower level\" functions, in order to maintain a sort of state. It also exposes ways to modify this state, namely the <code>alias</code> and <code>define</code> methods.</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>class MarkupLanguage:\n\"\"\"A relatively simple object that binds context to TIM parsing functions.\n\n    Most of the job this class has is to pass along a `ContextDict` to various\n    \"lower level\" functions, in order to maintain a sort of state. It also exposes\n    ways to modify this state, namely the `alias` and `define` methods.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        strict: bool = False,\n        default_aliases: bool = True,\n        default_macros: bool = True,\n    ) -&gt; None:\n        self._cache: dict[tuple[str, bool, bool], tuple[str, list[Token], bool]] = {}\n\n        self.context = create_context_dict()\n        self._aliases = self.context[\"aliases\"]\n        self._macros = self.context[\"macros\"]\n\n        if default_aliases:\n            apply_default_aliases(self)\n\n        if default_macros:\n            apply_default_macros(self)\n\n        self.strict = strict or STRICT_MARKUP\n\n    @property\n    def aliases(self) -&gt; dict[str, str]:\n\"\"\"Returns a copy of the aliases defined in context.\"\"\"\n\n        return self._aliases.copy()\n\n    @property\n    def macros(self) -&gt; dict[str, MacroType]:\n\"\"\"Returns a copy of the macros defined in context.\"\"\"\n\n        return self._macros.copy()\n\n    def clear_cache(self) -&gt; None:\n\"\"\"Clears the internal cache.\n\n        Use this after re-defining aliases.\n        \"\"\"\n\n        self._cache.clear()\n\n    def define(self, name: str, method: MacroType) -&gt; None:\n\"\"\"Defines a markup macro.\n\n        Macros are essentially function bindings callable within markup. They can be\n        very useful to represent changing data and simplify TIM code.\n\n        Args:\n            name: The name that will be used within TIM to call the macro. Must start with\n                a bang (`!`).\n            method: The function bound to the name given above. This function will take\n                any number of strings as arguments, and return a terminal-ready (i.e. parsed)\n                string.\n        \"\"\"\n\n        if not name.startswith(\"!\"):\n            raise ValueError(\"TIM macro names must be prefixed by `!`.\")\n\n        self._macros[name] = method\n\n    def alias(self, name: str, value: str, *, generate_unsetter: bool = True) -&gt; None:\n\"\"\"Creates an alias from one custom name to a set of styles.\n\n        These can be used to store and reference a set of tags using only one name.\n\n        Aliases may reference other aliases, but only do this consciously, as it can become\n        a hard to follow trail of sorrow very quickly!\n\n        Args:\n            name: The name this alias will be referenced by.\n            value: The markup value that the alias will represent.\n            generate_unsetter: Disable generating clearer aliases.\n\n                For example:\n                    ```\n                    my-tag = 141 bold italic\n                    ```\n\n                will generate:\n                    ```\n                    /my-tag = /fg /bold /italic\n                    ```\n        \"\"\"\n\n        def _generate_unsetter() -&gt; str:\n            unsetter = \"\"\n            no_alias = eval_alias(value, self.context)\n\n            for tag in no_alias.split():\n                if \"(\" in tag and \")\" in tag:\n                    tag = tag[: tag.find(\"(\")]\n\n                if tag in self._aliases or tag in self._macros:\n                    unsetter += f\" /{tag}\"\n                    continue\n\n                try:\n                    color = str_to_color(tag)\n                    unsetter += f\" /{'bg' if color.background else 'fg'}\"\n\n                except ColorSyntaxError:\n                    unsetter += f\" /{tag}\"\n\n            return unsetter.lstrip(\" \")\n\n        self._aliases[name] = value\n\n        if generate_unsetter:\n            self._aliases[f\"/{name}\"] = _generate_unsetter()\n\n    def alias_multiple(self, *, generate_unsetter: bool = True, **items: str) -&gt; None:\n\"\"\"Runs `MarkupLanguage.alias` repeatedly for all arguments.\n\n        The same `generate_unsetter` value will be used for all calls.\n\n        You can use this in two forms:\n\n        - Traditional keyword arguments:\n\n            ```python\n            lang.alias_multiple(my-tag1=\"bold\", my-tag2=\"italic\")\n            ```\n\n        - Keyword argument unpacking:\n\n            ```python\n            my_aliases = {\"my-tag1\": \"bold\", \"my-tag2\": \"italic\"}\n            lang.alias_multiple(**my_aliases)\n            ```\n        \"\"\"\n\n        for name, value in items.items():\n            self.alias(name, value, generate_unsetter=generate_unsetter)\n\n    def parse(\n        self,\n        text: str,\n        optimize: bool = False,\n        append_reset: bool = True,\n    ) -&gt; str:\n\"\"\"Parses some markup text.\n\n        This is a thin wrapper around [markup.parsing.parse](/reference/\n        pytermgui/markup/parsing#pytermgui.markup.parsing.parse). The main additions\n        of this wrapper are a caching system, as well as state management.\n\n        Ignoring caching, all calls to this function would be equivalent to:\n\n        ```python3\n        def parse(self, *args, **kwargs) -&gt; str:\n            kwargs[\"context\"] = self.context\n\n            return parse(*args, **kwargs)\n        ```\n        \"\"\"\n\n        key = (text, optimize, append_reset)\n\n        cache_hit = self._cache.get(key)\n        if cache_hit is not None:\n            cached, tokens, has_macro = cache_hit\n\n            # Re-parse using known tokens when macro is present\n            #\n            # This saves a tiny fraction of time (around 0.2ms) when parsing\n            # macros, for a loss of an even smaller time for the general,\n            # non-macro usecase.\n            if has_macro:\n                output = parse_tokens(\n                    tokens,\n                    optimize=optimize,\n                    append_reset=append_reset,\n                    context=self.context,\n                    ignore_unknown_tags=not self.strict,\n                )\n\n                return output\n\n            return cached\n\n        tokens = list(tokenize_markup(text))\n\n        output = parse_tokens(\n            tokens,\n            optimize=optimize,\n            append_reset=append_reset,\n            context=self.context,\n            ignore_unknown_tags=not self.strict,\n        )\n\n        has_macro = any(token.is_macro() for token in tokens)\n\n        self._cache[key] = (output, tokens, has_macro)\n\n        return output\n\n    # TODO: This should be deprecated.\n    @staticmethod\n    def get_markup(text: str) -&gt; str:\n\"\"\"DEPRECATED: Convert ANSI text into markup.\n\n        This function does not use context, and thus is out of place here.\n        \"\"\"\n\n        return tokens_to_markup(list(tokenize_ansi(text)))\n\n    def group_styles(\n        self, text: str, tokenizer: Tokenizer = tokenize_ansi\n    ) -&gt; Generator[StyledText, None, None]:\n\"\"\"Generate StyledText-s from some text, using our context.\n\n        See `StyledText.group_styles` for arguments.\n        \"\"\"\n\n        yield from StyledText.group_styles(\n            text, tokenizer=tokenizer, context=self.context\n        )\n\n    def print(self, *args, **kwargs) -&gt; None:\n\"\"\"Parse all arguments and pass them through to print, along with kwargs.\"\"\"\n\n        parsed = []\n        for arg in args:\n            parsed.append(self.parse(str(arg)))\n\n        get_terminal().print(*parsed, **kwargs)\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.aliases","title":"<code>aliases: dict[str, str]</code>  <code>property</code>","text":"<p>Returns a copy of the aliases defined in context.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.macros","title":"<code>macros: dict[str, MacroType]</code>  <code>property</code>","text":"<p>Returns a copy of the macros defined in context.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.alias","title":"<code>alias(name, value, *, generate_unsetter=True)</code>","text":"<p>Creates an alias from one custom name to a set of styles.</p> <p>These can be used to store and reference a set of tags using only one name.</p> <p>Aliases may reference other aliases, but only do this consciously, as it can become a hard to follow trail of sorrow very quickly!</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name this alias will be referenced by.</p> required <code>value</code> <code>str</code> <p>The markup value that the alias will represent.</p> required <code>generate_unsetter</code> <code>bool</code> <p>Disable generating clearer aliases.</p> <p>For example:     <pre><code>my-tag = 141 bold italic\n</code></pre></p> <p>will generate:     <pre><code>/my-tag = /fg /bold /italic\n</code></pre></p> <code>True</code> Source code in <code>pytermgui/markup/language.py</code> <pre><code>def alias(self, name: str, value: str, *, generate_unsetter: bool = True) -&gt; None:\n\"\"\"Creates an alias from one custom name to a set of styles.\n\n    These can be used to store and reference a set of tags using only one name.\n\n    Aliases may reference other aliases, but only do this consciously, as it can become\n    a hard to follow trail of sorrow very quickly!\n\n    Args:\n        name: The name this alias will be referenced by.\n        value: The markup value that the alias will represent.\n        generate_unsetter: Disable generating clearer aliases.\n\n            For example:\n                ```\n                my-tag = 141 bold italic\n                ```\n\n            will generate:\n                ```\n                /my-tag = /fg /bold /italic\n                ```\n    \"\"\"\n\n    def _generate_unsetter() -&gt; str:\n        unsetter = \"\"\n        no_alias = eval_alias(value, self.context)\n\n        for tag in no_alias.split():\n            if \"(\" in tag and \")\" in tag:\n                tag = tag[: tag.find(\"(\")]\n\n            if tag in self._aliases or tag in self._macros:\n                unsetter += f\" /{tag}\"\n                continue\n\n            try:\n                color = str_to_color(tag)\n                unsetter += f\" /{'bg' if color.background else 'fg'}\"\n\n            except ColorSyntaxError:\n                unsetter += f\" /{tag}\"\n\n        return unsetter.lstrip(\" \")\n\n    self._aliases[name] = value\n\n    if generate_unsetter:\n        self._aliases[f\"/{name}\"] = _generate_unsetter()\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.alias_multiple","title":"<code>alias_multiple(*, generate_unsetter=True, **items)</code>","text":"<p>Runs <code>MarkupLanguage.alias</code> repeatedly for all arguments.</p> <p>The same <code>generate_unsetter</code> value will be used for all calls.</p> <p>You can use this in two forms:</p> <ul> <li> <p>Traditional keyword arguments:</p> <pre><code>lang.alias_multiple(my-tag1=\"bold\", my-tag2=\"italic\")\n</code></pre> </li> <li> <p>Keyword argument unpacking:</p> <pre><code>my_aliases = {\"my-tag1\": \"bold\", \"my-tag2\": \"italic\"}\nlang.alias_multiple(**my_aliases)\n</code></pre> </li> </ul> Source code in <code>pytermgui/markup/language.py</code> <pre><code>def alias_multiple(self, *, generate_unsetter: bool = True, **items: str) -&gt; None:\n\"\"\"Runs `MarkupLanguage.alias` repeatedly for all arguments.\n\n    The same `generate_unsetter` value will be used for all calls.\n\n    You can use this in two forms:\n\n    - Traditional keyword arguments:\n\n        ```python\n        lang.alias_multiple(my-tag1=\"bold\", my-tag2=\"italic\")\n        ```\n\n    - Keyword argument unpacking:\n\n        ```python\n        my_aliases = {\"my-tag1\": \"bold\", \"my-tag2\": \"italic\"}\n        lang.alias_multiple(**my_aliases)\n        ```\n    \"\"\"\n\n    for name, value in items.items():\n        self.alias(name, value, generate_unsetter=generate_unsetter)\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clears the internal cache.</p> <p>Use this after re-defining aliases.</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>def clear_cache(self) -&gt; None:\n\"\"\"Clears the internal cache.\n\n    Use this after re-defining aliases.\n    \"\"\"\n\n    self._cache.clear()\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.define","title":"<code>define(name, method)</code>","text":"<p>Defines a markup macro.</p> <p>Macros are essentially function bindings callable within markup. They can be very useful to represent changing data and simplify TIM code.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name that will be used within TIM to call the macro. Must start with a bang (<code>!</code>).</p> required <code>method</code> <code>MacroType</code> <p>The function bound to the name given above. This function will take any number of strings as arguments, and return a terminal-ready (i.e. parsed) string.</p> required Source code in <code>pytermgui/markup/language.py</code> <pre><code>def define(self, name: str, method: MacroType) -&gt; None:\n\"\"\"Defines a markup macro.\n\n    Macros are essentially function bindings callable within markup. They can be\n    very useful to represent changing data and simplify TIM code.\n\n    Args:\n        name: The name that will be used within TIM to call the macro. Must start with\n            a bang (`!`).\n        method: The function bound to the name given above. This function will take\n            any number of strings as arguments, and return a terminal-ready (i.e. parsed)\n            string.\n    \"\"\"\n\n    if not name.startswith(\"!\"):\n        raise ValueError(\"TIM macro names must be prefixed by `!`.\")\n\n    self._macros[name] = method\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.get_markup","title":"<code>get_markup(text)</code>  <code>staticmethod</code>","text":"<p>DEPRECATED: Convert ANSI text into markup.</p> <p>This function does not use context, and thus is out of place here.</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>@staticmethod\ndef get_markup(text: str) -&gt; str:\n\"\"\"DEPRECATED: Convert ANSI text into markup.\n\n    This function does not use context, and thus is out of place here.\n    \"\"\"\n\n    return tokens_to_markup(list(tokenize_ansi(text)))\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.group_styles","title":"<code>group_styles(text, tokenizer=tokenize_ansi)</code>","text":"<p>Generate StyledText-s from some text, using our context.</p> <p>See <code>StyledText.group_styles</code> for arguments.</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>def group_styles(\n    self, text: str, tokenizer: Tokenizer = tokenize_ansi\n) -&gt; Generator[StyledText, None, None]:\n\"\"\"Generate StyledText-s from some text, using our context.\n\n    See `StyledText.group_styles` for arguments.\n    \"\"\"\n\n    yield from StyledText.group_styles(\n        text, tokenizer=tokenizer, context=self.context\n    )\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.parse","title":"<code>parse(text, optimize=False, append_reset=True)</code>","text":"<p>Parses some markup text.</p> <p>This is a thin wrapper around markup.parsing.parse. The main additions of this wrapper are a caching system, as well as state management.</p> <p>Ignoring caching, all calls to this function would be equivalent to:</p> <pre><code>def parse(self, *args, **kwargs) -&gt; str:\n    kwargs[\"context\"] = self.context\n\n    return parse(*args, **kwargs)\n</code></pre> Source code in <code>pytermgui/markup/language.py</code> <pre><code>def parse(\n    self,\n    text: str,\n    optimize: bool = False,\n    append_reset: bool = True,\n) -&gt; str:\n\"\"\"Parses some markup text.\n\n    This is a thin wrapper around [markup.parsing.parse](/reference/\n    pytermgui/markup/parsing#pytermgui.markup.parsing.parse). The main additions\n    of this wrapper are a caching system, as well as state management.\n\n    Ignoring caching, all calls to this function would be equivalent to:\n\n    ```python3\n    def parse(self, *args, **kwargs) -&gt; str:\n        kwargs[\"context\"] = self.context\n\n        return parse(*args, **kwargs)\n    ```\n    \"\"\"\n\n    key = (text, optimize, append_reset)\n\n    cache_hit = self._cache.get(key)\n    if cache_hit is not None:\n        cached, tokens, has_macro = cache_hit\n\n        # Re-parse using known tokens when macro is present\n        #\n        # This saves a tiny fraction of time (around 0.2ms) when parsing\n        # macros, for a loss of an even smaller time for the general,\n        # non-macro usecase.\n        if has_macro:\n            output = parse_tokens(\n                tokens,\n                optimize=optimize,\n                append_reset=append_reset,\n                context=self.context,\n                ignore_unknown_tags=not self.strict,\n            )\n\n            return output\n\n        return cached\n\n    tokens = list(tokenize_markup(text))\n\n    output = parse_tokens(\n        tokens,\n        optimize=optimize,\n        append_reset=append_reset,\n        context=self.context,\n        ignore_unknown_tags=not self.strict,\n    )\n\n    has_macro = any(token.is_macro() for token in tokens)\n\n    self._cache[key] = (output, tokens, has_macro)\n\n    return output\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.MarkupLanguage.print","title":"<code>print(*args, **kwargs)</code>","text":"<p>Parse all arguments and pass them through to print, along with kwargs.</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>def print(self, *args, **kwargs) -&gt; None:\n\"\"\"Parse all arguments and pass them through to print, along with kwargs.\"\"\"\n\n    parsed = []\n    for arg in args:\n        parsed.append(self.parse(str(arg)))\n\n    get_terminal().print(*parsed, **kwargs)\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText","title":"<code>StyledText</code>  <code>dataclass</code>","text":"<p>An ANSI style-infused string.</p> <p>This is a sort of helper to handle ANSI texts in a more semantic manner. It keeps track of a sequence and a plain part.</p> <p>Calling <code>len()</code> will return the length of the printable, non-ANSI part, and indexing will return the characters at the given slice, but also include the sequences that are applied to them.</p> <p>To generate StyledText-s, it is recommended to use the <code>StyledText.group_styles</code> classmethod.</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>@dataclass(frozen=True)\nclass StyledText:\n\"\"\"An ANSI style-infused string.\n\n    This is a sort of helper to handle ANSI texts in a more semantic manner. It\n    keeps track of a sequence and a plain part.\n\n    Calling `len()` will return the length of the printable, non-ANSI part, and\n    indexing will return the characters at the given slice, but also include the\n    sequences that are applied to them.\n\n    To generate StyledText-s, it is recommended to use the `StyledText.group_styles`\n    classmethod.\n    \"\"\"\n\n    __slots__ = (\"plain\", \"sequences\", \"tokens\", \"link\", \"__dict__\")\n\n    sequences: str\n    plain: str\n    tokens: list[Token]\n    link: str | None\n\n    @cached_property\n    def foreground(self) -&gt; Color | None:\n\"\"\"Returns the foreground color of this object.\"\"\"\n\n        colors = [\n            tkn\n            for tkn in self.tokens\n            if Token.is_color(tkn) and not tkn.color.background\n        ]\n\n        if len(colors) == 0:\n            return None\n\n        return colors[-1].color\n\n    @cached_property\n    def background(self) -&gt; Color | None:\n\"\"\"Returns the background color of this object.\"\"\"\n\n        colors = [\n            tkn for tkn in self.tokens if Token.is_color(tkn) and tkn.color.background\n        ]\n\n        if len(colors) == 0:\n            return None\n\n        return colors[-1].color\n\n    @cached_property\n    def bold(self) -&gt; bool:\n\"\"\"Returns this text is bold.\"\"\"\n\n        return any(Token.is_style(tkn) and tkn.markup == \"bold\" for tkn in self.tokens)\n\n    @cached_property\n    def dim(self) -&gt; bool:\n\"\"\"Returns this text is dimmed.\"\"\"\n\n        return any(Token.is_style(tkn) and tkn.markup == \"dim\" for tkn in self.tokens)\n\n    @cached_property\n    def italic(self) -&gt; bool:\n\"\"\"Returns this text is italicized.\"\"\"\n\n        return any(\n            Token.is_style(tkn) and tkn.markup == \"italic\" for tkn in self.tokens\n        )\n\n    @cached_property\n    def underline(self) -&gt; bool:\n\"\"\"Returns this text is underlined.\"\"\"\n\n        return any(\n            Token.is_style(tkn) and tkn.markup == \"underline\" for tkn in self.tokens\n        )\n\n    @cached_property\n    def blink(self) -&gt; bool:\n\"\"\"Returns this text is blinking.\"\"\"\n\n        return any(Token.is_style(tkn) and tkn.markup == \"blink\" for tkn in self.tokens)\n\n    @cached_property\n    def blink2(self) -&gt; bool:\n\"\"\"Returns this text is alternate-blinking.\"\"\"\n\n        return any(\n            Token.is_style(tkn) and tkn.markup == \"blink2\" for tkn in self.tokens\n        )\n\n    @cached_property\n    def strikethrough(self) -&gt; bool:\n\"\"\"Returns this text is striked out.\"\"\"\n\n        return any(\n            Token.is_style(tkn) and tkn.markup == \"strikethrough\" for tkn in self.tokens\n        )\n\n    @cached_property\n    def inverse(self) -&gt; bool:\n\"\"\"Returns this text has its colors inversed.\"\"\"\n\n        return any(\n            Token.is_style(tkn) and tkn.markup == \"inverse\" for tkn in self.tokens\n        )\n\n    @cached_property\n    def overline(self) -&gt; bool:\n\"\"\"Returns this text is overlined.\"\"\"\n\n        return any(\n            Token.is_style(tkn) and tkn.markup == \"overline\" for tkn in self.tokens\n        )\n\n    @staticmethod\n    def group_styles(\n        text: str,\n        tokenizer: Tokenizer = tokenize_ansi,\n        context: ContextDict | None = None,\n    ) -&gt; Generator[StyledText, None, None]:\n\"\"\"Yields StyledTexts from an ANSI coded string.\n\n        A new StyledText will be created each time a non-plain token follows a\n        plain token, thus all texts will represent a single (ANSI)PLAIN group\n        of characters.\n        \"\"\"\n\n        context = context if context is not None else create_context_dict()\n\n        parsers = PARSERS\n        link = None\n\n        def _parse(token: Token) -&gt; str:\n            nonlocal link\n\n            if token.is_macro():\n                return token.markup\n\n            if token.is_hyperlink():\n                link = token\n                return \"\"\n\n            if link is not None and Token.is_clear(token) and token.targets(link):\n                link = None\n\n            if token.is_clear() and token.value not in CLEARERS:\n                return token.markup\n\n            # The full text (last arg) is not relevant here, as ANSI parsing doesn't\n            # use any context-defined tags, so no errors will occur.\n            return parsers[type(token)](token, context, lambda: \"\")  # type: ignore\n\n        tokens: list[Token] = []\n        token: Token\n\n        for token in tokenizer(text):\n            if token.is_plain():\n                yield StyledText(\n                    \"\".join(_parse(tkn) for tkn in tokens),\n                    token.value,\n                    tokens + [token],\n                    link.value if link is not None else None,\n                )\n\n                tokens = [tkn for tkn in tokens if not tkn.is_cursor()]\n                continue\n\n            if Token.is_clear(token):\n                tokens = [tkn for tkn in tokens if not token.targets(tkn)]\n\n                if len(tokens) &gt; 0 and tokens[-1] == token:\n                    continue\n\n            if len(tokens) &gt; 0 and all(tkn.is_clear() for tkn in tokens):\n                tokens = []\n\n            tokens.append(token)\n\n        # if len(tokens) &gt; 0:\n        #     token = PlainToken(\"\")\n\n        #     yield StyledText(\n        #         \"\".join(_parse(tkn) for tkn in tokens),\n        #         token.value,\n        #         tokens + [token],\n        #         link.value if link is not None else None,\n        #     )\n\n    @classmethod\n    def first_of(cls, text: str) -&gt; StyledText | None:\n\"\"\"Returns the first element of cls.group_styles(text).\"\"\"\n\n        for item in cls.group_styles(text):\n            return item\n\n        return None\n\n    def __len__(self) -&gt; int:\n        return len(self.plain)\n\n    def __str__(self) -&gt; str:\n        return self.sequences + self.plain\n\n    def __getitem__(self, sli: int | slice) -&gt; str:\n        return self.sequences + self.plain[sli]\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.background","title":"<code>background: Color | None</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the background color of this object.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.blink","title":"<code>blink: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text is blinking.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.blink2","title":"<code>blink2: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text is alternate-blinking.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.bold","title":"<code>bold: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text is bold.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.dim","title":"<code>dim: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text is dimmed.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.foreground","title":"<code>foreground: Color | None</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the foreground color of this object.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.inverse","title":"<code>inverse: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text has its colors inversed.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.italic","title":"<code>italic: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text is italicized.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.overline","title":"<code>overline: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text is overlined.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.strikethrough","title":"<code>strikethrough: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text is striked out.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.underline","title":"<code>underline: bool</code>  <code>cached</code> <code>property</code>","text":"<p>Returns this text is underlined.</p>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.first_of","title":"<code>first_of(text)</code>  <code>classmethod</code>","text":"<p>Returns the first element of cls.group_styles(text).</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>@classmethod\ndef first_of(cls, text: str) -&gt; StyledText | None:\n\"\"\"Returns the first element of cls.group_styles(text).\"\"\"\n\n    for item in cls.group_styles(text):\n        return item\n\n    return None\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.StyledText.group_styles","title":"<code>group_styles(text, tokenizer=tokenize_ansi, context=None)</code>  <code>staticmethod</code>","text":"<p>Yields StyledTexts from an ANSI coded string.</p> <p>A new StyledText will be created each time a non-plain token follows a plain token, thus all texts will represent a single (ANSI)PLAIN group of characters.</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>@staticmethod\ndef group_styles(\n    text: str,\n    tokenizer: Tokenizer = tokenize_ansi,\n    context: ContextDict | None = None,\n) -&gt; Generator[StyledText, None, None]:\n\"\"\"Yields StyledTexts from an ANSI coded string.\n\n    A new StyledText will be created each time a non-plain token follows a\n    plain token, thus all texts will represent a single (ANSI)PLAIN group\n    of characters.\n    \"\"\"\n\n    context = context if context is not None else create_context_dict()\n\n    parsers = PARSERS\n    link = None\n\n    def _parse(token: Token) -&gt; str:\n        nonlocal link\n\n        if token.is_macro():\n            return token.markup\n\n        if token.is_hyperlink():\n            link = token\n            return \"\"\n\n        if link is not None and Token.is_clear(token) and token.targets(link):\n            link = None\n\n        if token.is_clear() and token.value not in CLEARERS:\n            return token.markup\n\n        # The full text (last arg) is not relevant here, as ANSI parsing doesn't\n        # use any context-defined tags, so no errors will occur.\n        return parsers[type(token)](token, context, lambda: \"\")  # type: ignore\n\n    tokens: list[Token] = []\n    token: Token\n\n    for token in tokenizer(text):\n        if token.is_plain():\n            yield StyledText(\n                \"\".join(_parse(tkn) for tkn in tokens),\n                token.value,\n                tokens + [token],\n                link.value if link is not None else None,\n            )\n\n            tokens = [tkn for tkn in tokens if not tkn.is_cursor()]\n            continue\n\n        if Token.is_clear(token):\n            tokens = [tkn for tkn in tokens if not token.targets(tkn)]\n\n            if len(tokens) &gt; 0 and tokens[-1] == token:\n                continue\n\n        if len(tokens) &gt; 0 and all(tkn.is_clear() for tkn in tokens):\n            tokens = []\n\n        tokens.append(token)\n</code></pre>"},{"location":"reference/pytermgui/markup/language/#pytermgui.markup.language.escape","title":"<code>escape(text)</code>","text":"<p>Escapes any markup found within the given text.</p> Source code in <code>pytermgui/markup/language.py</code> <pre><code>def escape(text: str) -&gt; str:\n\"\"\"Escapes any markup found within the given text.\"\"\"\n\n    def _repl(matchobj: Match) -&gt; str:\n        full, *_ = matchobj.groups()\n\n        return f\"\\\\{full}\"\n\n    return RE_MARKUP.sub(_repl, text)\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/","title":"macros","text":"<p>All PTG-builtin TIM macros.</p>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.apply_default_macros","title":"<code>apply_default_macros(lang)</code>","text":"<p>Applies all macros in <code>DEFAULT_MACROS</code>.</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>MarkupLanguage</code> <p>The language to apply the macros to.</p> required Source code in <code>pytermgui/markup/macros.py</code> <pre><code>def apply_default_macros(lang: MarkupLanguage) -&gt; None:\n\"\"\"Applies all macros in `DEFAULT_MACROS`.\n\n    Args:\n        lang: The language to apply the macros to.\n    \"\"\"\n\n    for name, value in DEFAULT_MACROS.items():\n        lang.define(name, value)\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.export_macro","title":"<code>export_macro(func)</code>","text":"<p>A decorator to add a function to <code>DEFAULT_MACROS</code>.</p> Source code in <code>pytermgui/markup/macros.py</code> <pre><code>def export_macro(func: MacroTemplate) -&gt; MacroTemplate:\n\"\"\"A decorator to add a function to `DEFAULT_MACROS`.\"\"\"\n\n    name = \"_\".join(func.__name__.split(\"_\")[1:])  # type: ignore\n\n    DEFAULT_MACROS[f\"!{name}\"] = func\n\n    return func\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_align","title":"<code>macro_align(width, alignment, content)</code>","text":"<p>Aligns given text using fstrings.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>The width to align to.</p> required <code>alignment</code> <code>str</code> <p>One of \"left\", \"center\", \"right\".</p> required <code>content</code> <code>str</code> <p>The content to align; implicit argument.</p> required Source code in <code>pytermgui/markup/macros.py</code> <pre><code>@export_macro\ndef macro_align(width: str, alignment: str, content: str) -&gt; str:\n\"\"\"Aligns given text using fstrings.\n\n    Args:\n        width: The width to align to.\n        alignment: One of \"left\", \"center\", \"right\".\n        content: The content to align; implicit argument.\n    \"\"\"\n\n    aligner = \"&lt;\" if alignment == \"left\" else (\"&gt;\" if alignment == \"right\" else \"^\")\n    return f\"{content:{aligner}{width}}\"\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_expand","title":"<code>macro_expand(lang, tag)</code>","text":"<p>Expands a tag alias.</p> Source code in <code>pytermgui/markup/macros.py</code> <pre><code>@export_macro\ndef macro_expand(lang: MarkupLanguage, tag: str) -&gt; str:\n\"\"\"Expands a tag alias.\"\"\"\n\n    if not tag in lang.user_tags:\n        return tag\n\n    return lang.get_markup(f\"\\x1b[{lang.user_tags[tag]}m \")[:-1]\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_gradient","title":"<code>macro_gradient(base_str, item)</code>","text":"<p>Creates an xterm-256 gradient from a base color.</p> <p>This exploits the way the colors are arranged in the xterm color table; every 36th color is the next item of a single gradient.</p> <p>The start of this given gradient is calculated by decreasing the given base by 36 on every iteration as long as the point is a valid gradient start.</p> <p>After that, the 6 colors of this gradient are calculated and applied.</p> Source code in <code>pytermgui/markup/macros.py</code> <pre><code>@export_macro\ndef macro_gradient(base_str: str, item: str) -&gt; str:\n\"\"\"Creates an xterm-256 gradient from a base color.\n\n    This exploits the way the colors are arranged in the xterm color table; every\n    36th color is the next item of a single gradient.\n\n    The start of this given gradient is calculated by decreasing the given base by 36 on\n    every iteration as long as the point is a valid gradient start.\n\n    After that, the 6 colors of this gradient are calculated and applied.\n    \"\"\"\n\n    if not base_str.isdigit():\n        raise ValueError(f\"Gradient base has to be a digit, got {base_str}.\")\n\n    base = int(base_str)\n    if base &lt; 16 or base &gt; 231:\n        raise ValueError(\"Gradient base must be between 16 and 232\")\n\n    while base &gt; 52:\n        base -= 36\n\n    colors = []\n    for i in range(6):\n        colors.append(base + 36 * i)\n\n    return _apply_colors(colors, item)\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_lower","title":"<code>macro_lower(text)</code>","text":"<p>Turns the text into lowercase.</p> Source code in <code>pytermgui/markup/macros.py</code> <pre><code>@export_macro\ndef macro_lower(text: str) -&gt; str:\n\"\"\"Turns the text into lowercase.\"\"\"\n\n    return text.lower()\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_rainbow","title":"<code>macro_rainbow(item)</code>","text":"<p>Creates rainbow-colored text.</p> Source code in <code>pytermgui/markup/macros.py</code> <pre><code>@export_macro\ndef macro_rainbow(item: str) -&gt; str:\n\"\"\"Creates rainbow-colored text.\"\"\"\n\n    colors = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"indigo\", \"violet\"]\n\n    return _apply_colors(colors, item)\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_shuffle","title":"<code>macro_shuffle(item)</code>","text":"<p>Shuffles a string using shuffle.shuffle on its list cast.</p> Source code in <code>pytermgui/markup/macros.py</code> <pre><code>@export_macro\ndef macro_shuffle(item: str) -&gt; str:\n\"\"\"Shuffles a string using shuffle.shuffle on its list cast.\"\"\"\n\n    shuffled = list(item)\n    shuffle(shuffled)\n\n    return \"\".join(shuffled)\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_title","title":"<code>macro_title(text)</code>","text":"<p>Turns the text into titlecase.</p> Source code in <code>pytermgui/markup/macros.py</code> <pre><code>@export_macro\ndef macro_title(text: str) -&gt; str:\n\"\"\"Turns the text into titlecase.\"\"\"\n\n    return text.title()\n</code></pre>"},{"location":"reference/pytermgui/markup/macros/#pytermgui.markup.macros.macro_upper","title":"<code>macro_upper(text)</code>","text":"<p>Turns the text into uppercase.</p> Source code in <code>pytermgui/markup/macros.py</code> <pre><code>@export_macro\ndef macro_upper(text: str) -&gt; str:\n\"\"\"Turns the text into uppercase.\"\"\"\n\n    return text.upper()\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/","title":"parsing","text":"<p>The internals of the TIM engine.</p>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.ContextDict","title":"<code>ContextDict</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary to hold context about a markup language's environment.</p> <p>It has two sub-dicts:</p> <ul> <li>aliases</li> <li>macros</li> </ul> <p>For information about what they do and contain, see the MarkupLanguage docs.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>class ContextDict(TypedDict):\n\"\"\"A dictionary to hold context about a markup language's environment.\n\n    It has two sub-dicts:\n\n    - aliases\n    - macros\n\n    For information about what they do and contain, see the\n    [MarkupLanguage docs](/reference/pytermgui/markup/\n    language#pytermgui.markup.language.MarkupLanguage).\n    \"\"\"\n\n    aliases: dict[str, str]\n    macros: dict[str, MacroType]\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.MacroType","title":"<code>MacroType</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol for TIM macros.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>class MacroType(Protocol):  # pylint: disable=too-few-public-methods\n\"\"\"A protocol for TIM macros.\"\"\"\n\n    def __call__(  # pylint: disable=no-method-argument, no-self-argument\n        *args: str,\n    ) -&gt; str:\n\"\"\"Applies the macro.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.MacroType.__call__","title":"<code>__call__(*args)</code>","text":"<p>Applies the macro.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def __call__(  # pylint: disable=no-method-argument, no-self-argument\n    *args: str,\n) -&gt; str:\n\"\"\"Applies the macro.\"\"\"\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.consume_tag","title":"<code>consume_tag(tag)</code>","text":"<p>Consumes a tag text, returns the associated Token.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def consume_tag(tag: str) -&gt; Token:  # pylint: disable=too-many-return-statements\n\"\"\"Consumes a tag text, returns the associated Token.\"\"\"\n\n    if tag in STYLES:\n        return StyleToken(tag)\n\n    if tag.startswith(\"/\"):\n        return ClearToken(tag)\n\n    if tag.startswith(\"!\"):\n        matchobj = RE_MACRO.match(tag)\n\n        if matchobj is not None:\n            name, args = matchobj.groups()\n\n            if args is None:\n                return MacroToken(name, tuple())\n\n            return MacroToken(name, tuple(args.split(\":\")))\n\n    if tag.startswith(\"~\"):\n        return HLinkToken(tag[1:])\n\n    if tag.startswith(\"(\") and tag.endswith(\")\"):\n        values = tag[1:-1].split(\";\")\n        if len(values) != 2:\n            raise MarkupSyntaxError(\n                tag,\n                f\"should have exactly 2 values separated by `;`, not {len(values)}\",\n                \"\",\n            )\n\n        return CursorToken(tag[1:-1], *map(int, values))\n\n    if tag in PSEUDO_TOKENS:\n        return PseudoToken(tag)\n\n    token: Token\n    try:\n        token = ColorToken(tag, Color.parse(tag, localize=False))\n\n    except ColorSyntaxError:\n        token = AliasToken(tag)\n\n    finally:\n        return token  # pylint: disable=lost-exception\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.create_context_dict","title":"<code>create_context_dict()</code>","text":"<p>Creates a new context dictionary, initializing its sub-dicts.</p> <p>Returns:</p> Type Description <code>ContextDict</code> <p>A dictionary with <code>aliases</code> and <code>macros</code> defined as empty sub-dicts.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def create_context_dict() -&gt; ContextDict:\n\"\"\"Creates a new context dictionary, initializing its sub-dicts.\n\n    Returns:\n        A dictionary with `aliases` and `macros` defined as empty sub-dicts.\n    \"\"\"\n\n    return {\"aliases\": {}, \"macros\": {}}\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.eval_alias","title":"<code>eval_alias(text, context)</code>","text":"<p>Evaluates a space-delimited string of alias tags into their underlying value.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>A space-separated string containing the aliases.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The space-separated string that the input aliases represent.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def eval_alias(text: str, context: ContextDict) -&gt; str:\n\"\"\"Evaluates a space-delimited string of alias tags into their underlying value.\n\n    Args:\n        text: A space-separated string containing the aliases.\n\n    Returns:\n        The space-separated string that the input aliases represent.\n    \"\"\"\n\n    aliases = context[\"aliases\"]\n\n    evaluated = \"\"\n    for tag in text.split():\n        if tag not in aliases:\n            evaluated += tag + \" \"\n            continue\n\n        evaluated += eval_alias(aliases[tag], context) + \" \"\n\n    return evaluated.rstrip(\" \")\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.get_markup","title":"<code>get_markup(text)</code>","text":"<p>Gets the markup representing an ANSI-coded string.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def get_markup(text: str) -&gt; str:\n\"\"\"Gets the markup representing an ANSI-coded string.\"\"\"\n\n    return tokens_to_markup(list(tokenize_ansi(text)))\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.optimize_markup","title":"<code>optimize_markup(markup)</code>","text":"<p>Optimizes markup by tokenizing it, optimizing the tokens and converting it back to markup.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def optimize_markup(markup: str) -&gt; str:\n\"\"\"Optimizes markup by tokenizing it, optimizing the tokens and converting it back to markup.\"\"\"\n\n    return tokens_to_markup(list(optimize_tokens(list(tokenize_markup(markup)))))\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.optimize_tokens","title":"<code>optimize_tokens(tokens)</code>","text":"<p>Optimizes a stream of tokens, only yielding functionally relevant ones.</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>list[Token]</code> <p>Any list of Token objects. Usually obtained from <code>tokenize_markup</code> or <code>tokenize_ansi</code>.</p> required <p>Yields:</p> Type Description <code>Token</code> <p>All those tokens within the input iterator that are functionally relevant, keeping their order.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def optimize_tokens(tokens: list[Token]) -&gt; Iterator[Token]:\n\"\"\"Optimizes a stream of tokens, only yielding functionally relevant ones.\n\n    Args:\n        tokens: Any list of Token objects. Usually obtained from `tokenize_markup`\n            or `tokenize_ansi`.\n\n    Yields:\n        All those tokens within the input iterator that are functionally relevant,\n            keeping their order.\n    \"\"\"\n\n    previous: list[Token] = []\n    current_tag_group: list[Token] = []\n\n    def _diff_previous() -&gt; Iterator[Token]:\n\"\"\"Find difference from the previously active list of tokens.\"\"\"\n\n        applied = previous.copy()\n\n        for tkn in current_tag_group:\n            targets = []\n\n            clearer = Token.is_clear(tkn)\n            if Token.is_clear(tkn):\n                targets = [tkn.targets(tag) for tag in applied]\n\n            if tkn in previous and not clearer:\n                continue\n\n            if clearer and not any(targets):\n                continue\n\n            applied.append(tkn)\n            yield tkn\n\n    def _remove_redundant_color(token: Token) -&gt; None:\n\"\"\"Removes non-functional colors.\n\n        These happen in the following ways:\n        - Multiple colors of the same channel (fg/bg) are present.\n        - A color is applied, then a clearer clears it.\n        \"\"\"\n\n        for applied in current_tag_group.copy():\n            if Token.is_clear(applied) and applied.targets(token):\n                current_tag_group.remove(applied)\n\n            if not Token.is_color(applied):\n                continue\n\n            old = applied.color\n\n            if old.background == new.background:\n                current_tag_group.remove(applied)\n\n    for token in tokens:\n        if Token.is_plain(token):\n            yield from _diff_previous()\n            yield token\n\n            previous = current_tag_group.copy()\n\n            continue\n\n        if Token.is_color(token):\n            new = token.color\n\n            _remove_redundant_color(token)\n\n            if not any(token.markup == applied.markup for applied in current_tag_group):\n                current_tag_group.append(token)\n\n            continue\n\n        if token.is_style():\n            if not any(token == tag for tag in current_tag_group):\n                current_tag_group.append(token)\n\n            continue\n\n        if Token.is_clear(token):\n            applied = False\n            for tag in current_tag_group.copy():\n                if token.targets(tag) or token == tag:\n                    current_tag_group.remove(tag)\n                    applied = True\n\n            if not applied:\n                continue\n\n        current_tag_group.append(token)\n\n    yield from _diff_previous()\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse","title":"<code>parse(text, optimize=False, context=None, append_reset=True, ignore_unknown_tags=True)</code>","text":"<p>Parses markup into the ANSI-coded string it represents.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Any valid markup.</p> required <code>optimize</code> <code>bool</code> <p>If set, <code>optimize_tokens</code> will optimize the tokens found within the input markup before usage. This will incur a (minor) performance hit.</p> <code>False</code> <code>context</code> <code>ContextDict | None</code> <p>The context that aliases and macros found within the markup will be searched in.</p> <code>None</code> <code>append_reset</code> <code>bool</code> <p>If set, <code>[/]</code> will be appended to the token iterator, clearing all styles.</p> <code>True</code> <code>ignore_unknown_tags</code> <code>bool</code> <p>If set, the <code>MarkupSyntaxError</code> coming from unknown tags will be silenced.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The ANSI-coded string that the markup represents.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse(\n    text: str,\n    optimize: bool = False,\n    context: ContextDict | None = None,\n    append_reset: bool = True,\n    ignore_unknown_tags: bool = True,\n) -&gt; str:\n\"\"\"Parses markup into the ANSI-coded string it represents.\n\n    Args:\n        text: Any valid markup.\n        optimize: If set, `optimize_tokens` will optimize the tokens found within the\n            input markup before usage. This will incur a (minor) performance hit.\n        context: The context that aliases and macros found within the markup will be\n            searched in.\n        append_reset: If set, `[/]` will be appended to the token iterator, clearing all\n            styles.\n        ignore_unknown_tags: If set, the `MarkupSyntaxError` coming from unknown tags\n            will be silenced.\n\n    Returns:\n        The ANSI-coded string that the markup represents.\n    \"\"\"\n\n    if context is None:\n        context = create_context_dict()\n\n    if append_reset and not text.endswith(\"/]\"):\n        text += \"[/]\"\n\n    tokens = list(tokenize_markup(text))\n\n    return parse_tokens(\n        tokens,\n        optimize=optimize,\n        context=context,\n        append_reset=append_reset,\n        ignore_unknown_tags=ignore_unknown_tags,\n    )\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_alias","title":"<code>parse_alias(token, context, get_full)</code>","text":"<p>Parses an alias token.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_alias(\n    token: AliasToken, context: ContextDict, get_full: Callable[[], str]\n) -&gt; str:\n\"\"\"Parses an alias token.\"\"\"\n\n    if token.value not in context[\"aliases\"]:\n        dump = json.dumps(context[\"aliases\"], indent=2, default=str)\n\n        raise MarkupSyntaxError(\n            token.value, f\"not defined in alias context: {dump}\", get_full()\n        )\n\n    meaning = context[\"aliases\"][token.value]\n\n    return eval_alias(meaning, context).rstrip(\" \")\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_clear","title":"<code>parse_clear(token, _, get_full)</code>","text":"<p>Parses a clearer token.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_clear(token: ClearToken, _: ContextDict, get_full: Callable[[], str]) -&gt; str:\n\"\"\"Parses a clearer token.\"\"\"\n\n    if token.value == \"/~\":\n        return \"\\x1b]8;;\\x1b\\\\\"\n\n    index = CLEARERS.get(token.value)\n    if index is None:\n        raise MarkupSyntaxError(\n            token.value, \"not a recognized clearer or alias\", get_full()\n        )\n\n    return f\"\\x1b[{index}m\"\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_color","title":"<code>parse_color(token, _, __)</code>","text":"<p>Parses a color token.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_color(token: ColorToken, _: ContextDict, __: Callable[[], str]) -&gt; str:\n\"\"\"Parses a color token.\"\"\"\n\n    return token.color.get_localized().sequence\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_cursor","title":"<code>parse_cursor(token, _, __)</code>","text":"<p>Parses a cursor token.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_cursor(token: CursorToken, _: ContextDict, __: Callable[[], str]) -&gt; str:\n\"\"\"Parses a cursor token.\"\"\"\n\n    ypos, xpos = map(lambda i: \"\" if i is None else i, token)\n\n    return f\"\\x1b[{ypos};{xpos}H\"\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_macro","title":"<code>parse_macro(token, context, get_full)</code>","text":"<p>Parses a macro token.</p> <p>Returns:</p> Type Description <code>MacroType</code> <p>A tuple containing the callable bound to the name, as well as the arguments</p> <code>tuple[str, ...]</code> <p>passed to it.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_macro(\n    token: MacroToken, context: ContextDict, get_full: Callable[[], str]\n) -&gt; tuple[MacroType, tuple[str, ...]]:\n\"\"\"Parses a macro token.\n\n    Returns:\n        A tuple containing the callable bound to the name, as well as the arguments\n        passed to it.\n    \"\"\"\n\n    func = context[\"macros\"].get(token.value)\n\n    if func is None:\n        dump = json.dumps(context[\"macros\"], indent=2, default=str)\n\n        raise MarkupSyntaxError(\n            token.value, f\"not defined in macro context: {dump}\", get_full()\n        )\n\n    return func, token.arguments\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_plain","title":"<code>parse_plain(token, _, __)</code>","text":"<p>Parses a plain token.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_plain(token: PlainToken, _: ContextDict, __: Callable[[], str]) -&gt; str:\n\"\"\"Parses a plain token.\"\"\"\n\n    return token.value\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_state_pseudo","title":"<code>parse_state_pseudo(token, tokens, index, save_state, context)</code>","text":"<p>Parses a state pseudo tokens</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_state_pseudo(\n    token: PseudoToken,\n    tokens: list[Token],\n    index: int,\n    save_state: list[Token],\n    context: ContextDict,\n) -&gt; str:\n\"\"\"Parses a state pseudo tokens\"\"\"\n\n    tag = token.value\n\n    parsed = \"\"\n\n    if tag.startswith(STATE_CUT):\n        save_state.clear()\n        save_state.extend(filter(lambda tkn: not tkn.is_plain(), tokens[:index]))\n\n        if not tag == STATE_COPY:\n            parsed += \"\\x1b[0m\"\n\n    # Restore\n    else:\n        local_state = save_state.copy()\n\n        if tag == STATE_REPLACE:\n            local_state.insert(0, ClearToken(\"/\"))\n\n        parsed = parse_tokens(\n            local_state,\n            context=context,\n            optimize=False,\n            append_reset=False,\n        )\n\n    return parsed\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_style","title":"<code>parse_style(token, _, __)</code>","text":"<p>Parses a style token.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_style(token: StyleToken, _: ContextDict, __: Callable[[], str]) -&gt; str:\n\"\"\"Parses a style token.\"\"\"\n\n    index = STYLES[token.value]\n\n    return f\"\\x1b[{index}m\"\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.parse_tokens","title":"<code>parse_tokens(tokens, *, optimize=False, context=None, append_reset=True, ignore_unknown_tags=True)</code>","text":"<p>Parses a stream of tokens into the ANSI-coded string they represent.</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>list[Token]</code> <p>Any list of Tokens, usually obtained from either <code>tokenize_ansi</code> or <code>tokenize_markup</code>.</p> required <code>optimize</code> <code>bool</code> <p>If set, <code>optimize_tokens</code> will optimize the input iterator before usage. This will incur a (minor) performance hit.</p> <code>False</code> <code>context</code> <code>ContextDict | None</code> <p>The context that aliases and macros found within the tokens will be searched in.</p> <code>None</code> <code>append_reset</code> <code>bool</code> <p>If set, <code>ClearToken(\"/\")</code> will be appended to the token iterator, clearing all styles.</p> <code>True</code> <code>ignore_unknown_tags</code> <code>bool</code> <p>If set, the <code>MarkupSyntaxError</code> coming from unknown tags will be silenced.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The ANSI-coded string that the token stream represents.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def parse_tokens(  # pylint: disable=too-many-branches, too-many-locals, too-many-statements\n    tokens: list[Token],\n    *,\n    optimize: bool = False,\n    context: ContextDict | None = None,\n    append_reset: bool = True,\n    ignore_unknown_tags: bool = True,\n) -&gt; str:\n\"\"\"Parses a stream of tokens into the ANSI-coded string they represent.\n\n    Args:\n        tokens: Any list of Tokens, usually obtained from either `tokenize_ansi` or\n            `tokenize_markup`.\n        optimize: If set, `optimize_tokens` will optimize the input iterator before\n            usage. This will incur a (minor) performance hit.\n        context: The context that aliases and macros found within the tokens will be\n            searched in.\n        append_reset: If set, `ClearToken(\"/\")` will be appended to the token iterator,\n            clearing all styles.\n        ignore_unknown_tags: If set, the `MarkupSyntaxError` coming from unknown tags\n            will be silenced.\n\n    Returns:\n        The ANSI-coded string that the token stream represents.\n    \"\"\"\n\n    if context is None:\n        context = create_context_dict()\n\n    token_list = _sub_aliases(tokens, context)\n\n    # It's more computationally efficient to create this lambda once and reuse it\n    # every time. There is no need to define a full function, as it just returns\n    # a function return.\n    get_full = (\n        lambda: tokens_to_markup(  # pylint: disable=unnecessary-lambda-assignment\n            token_list\n        )\n    )\n\n    if optimize:\n        token_list = list(optimize_tokens(token_list))\n\n    if append_reset:\n        token_list.append(ClearToken(\"/\"))\n\n    link = None\n    output = \"\"\n    segment = \"\"\n    background = Color.parse(\"#000000\")\n    macros: list[MacroToken] = []\n    unknown_aliases: list[Token] = []\n\n    save_state: list[Token] = []\n\n    for i, token in enumerate(token_list):\n        if token.is_plain():\n            value = _apply_macros(\n                token.value, (parse_macro(macro, context, get_full) for macro in macros)\n            )\n\n            if len(unknown_aliases) &gt; 0:\n                output += f\"[{' '.join(tkn.value for tkn in unknown_aliases)}]\"\n                unknown_aliases = []\n\n            output += segment + (\n                value if link is None else LINK_TEMPLATE.format(uri=link, label=value)\n            )\n\n            segment = \"\"\n            continue\n\n        if token.is_hyperlink():\n            link = token.value\n            continue\n\n        if Token.is_macro(token):\n            macros.append(token)\n            continue\n\n        if Token.is_clear(token):\n            if token.value in (\"/\", \"/~\"):\n                link = None\n\n                if token.value == \"/~\":\n                    continue\n\n            found = False\n            for macro in macros.copy():\n                if token.targets(macro):\n                    macros.remove(macro)\n                    found = True\n                    break\n\n            if found and token.value != \"/\":\n                continue\n\n            if token.value.startswith(\"/!\"):\n                raise MarkupSyntaxError(\n                    token.value, \"has nothing to target\", get_full()\n                )\n\n        if Token.is_color(token) and token.color.background:\n            background = token.color\n\n        if Token.is_pseudo(token):\n            if token.value in STATE_PSEUDOS:\n                segment += parse_state_pseudo(token, tokens, i, save_state, context)\n                continue\n\n            if token.value == \"#auto\":\n                token = ColorToken(\"#auto\", background.contrast)\n\n        try:\n            segment += PARSERS[type(token)](token, context, get_full)  # type: ignore\n\n        except MarkupSyntaxError:\n            if not ignore_unknown_tags:\n                raise\n\n            unknown_aliases.append(token)\n\n    if len(unknown_aliases) &gt; 0:\n        output += f\"[{' '.join(tkn.value for tkn in unknown_aliases)}]\"\n\n    output += segment\n\n    return output\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.tokenize_ansi","title":"<code>tokenize_ansi(text)</code>","text":"<p>Converts some ANSI-coded text into a stream of tokens.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Any valid ANSI-coded text.</p> required <p>Yields:</p> Type Description <code>Token</code> <p>The generated tokens, in the order they occur within the text.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def tokenize_ansi(  # pylint: disable=too-many-locals, too-many-branches, too-many-statements\n    text: str,\n) -&gt; Iterator[Token]:\n\"\"\"Converts some ANSI-coded text into a stream of tokens.\n\n    Args:\n        text: Any valid ANSI-coded text.\n\n    Yields:\n        The generated tokens, in the order they occur within the text.\n    \"\"\"\n\n    cursor = 0\n\n    for matchobj in RE_ANSI.finditer(text):\n        start, end = matchobj.span()\n\n        csi = matchobj.groups()[0:2]\n        link_osc = matchobj.groups()[2:4]\n\n        if cursor &lt; start:\n            yield PlainToken(text[cursor:start])\n\n        if link_osc != (None, None):\n            cursor = end\n            uri, label = link_osc\n\n            yield HLinkToken(uri)\n            yield PlainToken(label)\n            yield ClearToken(\"/~\")\n\n            continue\n\n        full, content = csi\n\n        cursor = end\n\n        code = \"\"\n\n        # Position\n        posmatch = RE_POSITION.match(full)\n\n        if posmatch is not None:\n            ypos, xpos = posmatch.groups()\n            if not ypos and not xpos:\n                raise ValueError(\n                    f\"Cannot parse cursor when no position is supplied. Match: {posmatch!r}\"\n                )\n\n            yield CursorToken(content, int(ypos) or None, int(xpos) or None)\n            continue\n\n        parts = content.split(\";\")\n\n        state = None\n        color_code = \"\"\n        for part in parts:\n            if state is None:\n                if part in REVERSE_STYLES:\n                    yield StyleToken(REVERSE_STYLES[part])\n                    continue\n\n                if part in REVERSE_CLEARERS:\n                    yield ClearToken(REVERSE_CLEARERS[part])\n                    continue\n\n                if part in (\"38\", \"48\"):\n                    state = \"COLOR\"\n                    color_code += part + \";\"\n                    continue\n\n                # standard colors\n                try:\n                    yield ColorToken(part, Color.parse(part, localize=False))\n                    continue\n\n                except ColorSyntaxError as exc:\n                    raise ValueError(f\"Could not parse color tag {part!r}.\") from exc\n\n            if state != \"COLOR\":\n                continue\n\n            color_code += part + \";\"\n\n            # Ignore incomplete RGB colors\n            if (\n                color_code.startswith((\"38;2;\", \"48;2;\"))\n                and len(color_code.split(\";\")) != 6\n            ):\n                continue\n\n            try:\n                code = color_code\n\n                if code.startswith((\"38;2;\", \"48;2;\", \"38;5;\", \"48;5;\")):\n                    stripped = code[5:-1]\n\n                    if code.startswith(\"4\"):\n                        stripped = \"@\" + stripped\n\n                    code = stripped\n\n                yield ColorToken(code, Color.parse(code, localize=False))\n\n            except ColorSyntaxError:\n                continue\n\n            state = None\n            color_code = \"\"\n\n    remaining = text[cursor:]\n    if len(remaining) &gt; 0:\n        yield PlainToken(remaining)\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.tokenize_markup","title":"<code>tokenize_markup(text)</code>","text":"<p>Converts some markup text into a stream of tokens.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Any valid markup.</p> required <p>Yields:</p> Type Description <code>Token</code> <p>The generated tokens, in the order they occur within the markup.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def tokenize_markup(text: str) -&gt; Iterator[Token]:\n\"\"\"Converts some markup text into a stream of tokens.\n\n    Args:\n        text: Any valid markup.\n\n    Yields:\n        The generated tokens, in the order they occur within the markup.\n    \"\"\"\n\n    cursor = 0\n    length = len(text)\n    has_inverse = False\n    for matchobj in RE_MARKUP.finditer(text):\n        full, escapes, content = matchobj.groups()\n        start, end = matchobj.span()\n\n        if cursor &lt; start:\n            yield PlainToken(text[cursor:start])\n\n        if not escapes == \"\":\n            _, remaining = divmod(len(escapes), 2)\n\n            yield PlainToken(full[max(1 - remaining, 1) :])\n            cursor = end\n\n            continue\n\n        for tag in content.split():\n            if tag == \"inverse\":\n                has_inverse = True\n\n            if tag == \"/inverse\":\n                has_inverse = False\n\n            consumed = consume_tag(tag)\n            if has_inverse:\n                if consumed.markup == \"/fg\":\n                    consumed = ClearToken(\"/fg\")\n\n                elif consumed.markup == \"/bg\":\n                    consumed = ClearToken(\"/bg\")\n\n            yield consumed\n\n        cursor = end\n\n    if cursor &lt; length:\n        yield PlainToken(text[cursor:length])\n</code></pre>"},{"location":"reference/pytermgui/markup/parsing/#pytermgui.markup.parsing.tokens_to_markup","title":"<code>tokens_to_markup(tokens)</code>","text":"<p>Converts a token stream into the markup of its tokens.</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>list[Token]</code> <p>Any list of Token objects. Usually obtained from <code>tokenize_markup</code> or <code>tokenize_ansi</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The markup the given tokens represent.</p> Source code in <code>pytermgui/markup/parsing.py</code> <pre><code>def tokens_to_markup(tokens: list[Token]) -&gt; str:\n\"\"\"Converts a token stream into the markup of its tokens.\n\n    Args:\n        tokens: Any list of Token objects. Usually obtained from `tokenize_markup` or\n            `tokenize_ansi`.\n\n    Returns:\n        The markup the given tokens represent.\n    \"\"\"\n\n    tags: list[Token] = []\n    markup = \"\"\n\n    for token in tokens:\n        if token.is_plain():\n            if len(tags) &gt; 0:\n                markup += f\"[{' '.join(tag.markup for tag in tags)}]\"\n\n            markup += token.value\n\n            tags = []\n\n        else:\n            tags.append(token)\n\n    if len(tags) &gt; 0:\n        markup += f\"[{' '.join(tag.markup for tag in tags)}]\"\n\n    return markup\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/","title":"tokens","text":"<p>The building blocks of the TIM language,</p> <p>Use <code>pytermgui.markup.parsing.tokenize_markup</code> and <code>pytermgui.markup.parsing.tokenize_ansi</code> to generate.</p>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.AliasToken","title":"<code>AliasToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A way to reference a set of tags from one central name.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass AliasToken(Token):\n\"\"\"A way to reference a set of tags from one central name.\"\"\"\n\n    __slots__ = (\"value\",)\n\n    value: str\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.ClearToken","title":"<code>ClearToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A tag-clearer.</p> <p>These tokens are prefixed by <code>/</code>, and followed by the name of the tag they target.</p> <p>To reset color information in the current text, use the <code>/fg</code> and <code>/bg</code> special tags. We cannot unset a specific color due to how the terminal works; all these do is \"reset\" the current stroke color to the default of the terminal.</p> <p>Additionally, there are some other special identifiers:</p> <ul> <li><code>/</code>:  Clears all tags, including styles, colors, macros, links and more.</li> <li><code>/!</code>: Clears all currently applied macros.</li> <li><code>/~</code>: Clears all currently applied links.</li> </ul> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass ClearToken(Token):\n\"\"\"A tag-clearer.\n\n    These tokens are prefixed by `/`, and followed by the name of the tag they target.\n\n    To reset color information in the current text, use the `/fg` and `/bg` special\n    tags. We cannot unset a specific color due to how the terminal works; all these do\n    is \"reset\" the current stroke color to the default of the terminal.\n\n    Additionally, there are some other special identifiers:\n\n    - `/`:  Clears all tags, including styles, colors, macros, links and more.\n    - `/!`: Clears all currently applied macros.\n    - `/~`: Clears all currently applied links.\n    \"\"\"\n\n    __slots__ = (\"value\",)\n\n    value: str\n\n    @cached_property\n    def prettified_markup(self) -&gt; str:\n        target = self.markup[1:]\n\n        return f\"[210 strikethrough]/[/fg]{target}[/]\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Token):\n            return False\n\n        return super().__eq__(other) or all(\n            obj.markup in [\"/dim\", \"/bold\"] for obj in [self, other]\n        )\n\n    def targets(  # pylint: disable=too-many-return-statements\n        self, token: Token\n    ) -&gt; bool:\n\"\"\"Returns True if this token targets the one given as an argument.\"\"\"\n\n        if token.is_clear() or token.is_cursor():\n            return False\n\n        if self.value in (\"/\", f\"/{token.value}\"):\n            return True\n\n        if token.is_hyperlink() and self.value == \"/~\":\n            return True\n\n        if token.is_macro() and self.value == \"/!\":\n            return True\n\n        if not Token.is_color(token):\n            return False\n\n        if self.value == \"/fg\" and not token.color.background:\n            return True\n\n        return self.value == \"/bg\" and token.color.background\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.ClearToken.targets","title":"<code>targets(token)</code>","text":"<p>Returns True if this token targets the one given as an argument.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def targets(  # pylint: disable=too-many-return-statements\n    self, token: Token\n) -&gt; bool:\n\"\"\"Returns True if this token targets the one given as an argument.\"\"\"\n\n    if token.is_clear() or token.is_cursor():\n        return False\n\n    if self.value in (\"/\", f\"/{token.value}\"):\n        return True\n\n    if token.is_hyperlink() and self.value == \"/~\":\n        return True\n\n    if token.is_macro() and self.value == \"/!\":\n        return True\n\n    if not Token.is_color(token):\n        return False\n\n    if self.value == \"/fg\" and not token.color.background:\n        return True\n\n    return self.value == \"/bg\" and token.color.background\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.ColorToken","title":"<code>ColorToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A color identifier.</p> <p>It stores the markup that created it, as well as the <code>pytermgui.colors.Color</code> object that it represents.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass ColorToken(Token):\n\"\"\"A color identifier.\n\n    It stores the markup that created it, as well as the `pytermgui.colors.Color` object\n    that it represents.\n    \"\"\"\n\n    __slots__ = (\"value\",)\n\n    value: str\n    color: Color\n\n    @cached_property\n    def markup(self) -&gt; str:\n        return self.color.markup\n\n    @cached_property\n    def prettified_markup(self) -&gt; str:\n        clearer = \"bg\" if self.color.background else \"fg\"\n\n        return f\"[{self.markup}]{self.markup}[/{clearer}]\"\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.CursorToken","title":"<code>CursorToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A cursor location.</p> <p>These can be used to move the terminal's cursor.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass CursorToken(Token):\n\"\"\"A cursor location.\n\n    These can be used to move the terminal's cursor.\n    \"\"\"\n\n    __slots__ = (\"value\", \"y\", \"x\")\n\n    value: str\n    y: int | None\n    x: int | None\n\n    def __iter__(self) -&gt; Iterator[int | None]:\n        return iter((self.y, self.x))\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{type(self).__name__} position: {(';'.join(map(str, self)))}&gt;\"\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n        yield self.__repr__()\n\n    @cached_property\n    def markup(self) -&gt; str:\n        return f\"({self.value})\"\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.HLinkToken","title":"<code>HLinkToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A terminal hyperlink.</p> <p>See https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass HLinkToken(Token):\n\"\"\"A terminal hyperlink.\n\n    See https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda.\n    \"\"\"\n\n    __slots__ = (\"value\",)\n\n    value: str\n\n    @cached_property\n    def markup(self) -&gt; str:\n        return f\"~{self.value}\"\n\n    @cached_property\n    def prettified_markup(self) -&gt; str:\n        return f\"[{self.markup}]~[blue underline]{self.value}[/fg /underline /~]\"\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.MacroToken","title":"<code>MacroToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A binding of a Python function to a markup name.</p> <p>See the docs on information about syntax &amp; semantics.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass MacroToken(Token):\n\"\"\"A binding of a Python function to a markup name.\n\n    See the docs on information about syntax &amp; semantics.\n    \"\"\"\n\n    __slots__ = (\"value\", \"arguments\")\n\n    value: str\n    arguments: tuple[str, ...]\n\n    def __iter__(self) -&gt; Iterator[Any]:\n        return iter((self.value, self.arguments))\n\n    @cached_property\n    def prettified_markup(self) -&gt; str:\n        target = self.markup[1:]\n\n        return f\"[210 bold]![/]{target}\"\n\n    @cached_property\n    def markup(self) -&gt; str:\n        return f\"{self.value}\" + (\n            f\"({':'.join(self.arguments)})\" if len(self.arguments) &gt; 0 else \"\"\n        )\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.PlainToken","title":"<code>PlainToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A plain piece of text.</p> <p>These are the parts of data in-between markup tag groups.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass PlainToken(Token):\n\"\"\"A plain piece of text.\n\n    These are the parts of data in-between markup tag groups.\n    \"\"\"\n\n    __slots__ = (\"value\",)\n\n    value: str\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{type(self).__name__} markup: {self.markup!r}&gt;\"\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n        yield f\"&lt;{type(self).__name__} markup: {self.markup!r}&gt;\"\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.PseudoToken","title":"<code>PseudoToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A token that can modify it's context, but doesn't hold information of its own.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass PseudoToken(Token):\n\"\"\"A token that can modify it's context, but doesn't hold information of its own.\"\"\"\n\n    value: str\n\n    @cached_property\n    def prettified_markup(self) -&gt; str:\n        return f\"[245 italic]{self.markup}[/]\"\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.StyleToken","title":"<code>StyleToken</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Token</code></p> <p>A terminal-style identifier.</p> <p>Most terminals support a set of 9 styles:</p> <ul> <li>bold</li> <li>dim</li> <li>italic</li> <li>underline</li> <li>blink</li> <li>blink2</li> <li>inverse</li> <li>invisible</li> <li>strikethrough</li> </ul> <p>This token will store the style it represents by its name in the <code>value</code> field. Note that other, less widely supported styles may be available; for an up-to-date list, run <code>ptg -i pytermgui.markup.style_maps.STYLES</code>. ```</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass StyleToken(Token):\n\"\"\"A terminal-style identifier.\n\n    Most terminals support a set of 9 styles:\n\n    - bold\n    - dim\n    - italic\n    - underline\n    - blink\n    - blink2\n    - inverse\n    - invisible\n    - strikethrough\n\n    This token will store the style it represents by its name in the `value` field. Note\n    that other, less widely supported styles *may* be available; for an up-to-date list,\n    run `ptg -i pytermgui.markup.style_maps.STYLES`.\n    ```\n\n    \"\"\"\n\n    __slots__ = (\"value\",)\n\n    value: str\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token","title":"<code>Token</code>","text":"<p>A piece of markup information.</p> <p>All tokens must have at least a <code>value</code> field, and have <code>markup</code> and <code>prettified_markup</code> properties derived from it in some manner.</p> <p>They are meant to be immutable (frozen), and generated by some tokenization. They are also static representations of the data in its pre-parsed form.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>class Token:\n\"\"\"A piece of markup information.\n\n    All tokens must have at least a `value` field, and have `markup` and `prettified_markup`\n    properties derived from it in some manner.\n\n    They are meant to be immutable (frozen), and generated by some tokenization. They are also\n    static representations of the data in its pre-parsed form.\n    \"\"\"\n\n    value: str\n\n    @cached_property\n    def markup(self) -&gt; str:\n\"\"\"Returns markup representing this token.\"\"\"\n\n        return self.value\n\n    @cached_property\n    def prettified_markup(self) -&gt; str:\n\"\"\"Returns syntax-highlighted markup representing this token.\"\"\"\n\n        return f\"[{self.markup}]{self.markup}[/{self.markup}]\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        return isinstance(other, type(self)) and other.value == self.value\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{type(self).__name__} markup: '{self.markup}'&gt;\"\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n        yield f\"&lt;{type(self).__name__} markup: \"\n        yield {\n            \"text\": self.prettified_markup,\n            \"highlight\": False,\n        }\n        yield \"&gt;\"\n\n    def is_plain(self) -&gt; TypeGuard[\"PlainToken\"]:\n\"\"\"Returns True if this token is an instance of PlainToken.\"\"\"\n\n        return isinstance(self, PlainToken)\n\n    def is_pseudo(self) -&gt; TypeGuard[\"PseudoToken\"]:\n\"\"\"Returns True if this token is an instance of PseudoToken.\"\"\"\n\n        return isinstance(self, PseudoToken)\n\n    def is_color(self) -&gt; TypeGuard[\"ColorToken\"]:\n\"\"\"Returns True if this token is an instance of ColorToken.\"\"\"\n\n        return isinstance(self, ColorToken)\n\n    def is_style(self) -&gt; TypeGuard[\"StyleToken\"]:\n\"\"\"Returns True if this token is an instance of StyleToken.\"\"\"\n\n        return isinstance(self, StyleToken)\n\n    def is_alias(self) -&gt; TypeGuard[\"AliasToken\"]:\n\"\"\"Returns True if this token is an instance of AliasToken.\"\"\"\n\n        return isinstance(self, AliasToken)\n\n    def is_macro(self) -&gt; TypeGuard[\"MacroToken\"]:\n\"\"\"Returns True if this token is an instance of MacroToken.\"\"\"\n\n        return isinstance(self, MacroToken)\n\n    def is_clear(self) -&gt; TypeGuard[\"ClearToken\"]:\n\"\"\"Returns True if this token is an instance of ClearToken.\"\"\"\n\n        return isinstance(self, ClearToken)\n\n    def is_hyperlink(self) -&gt; TypeGuard[\"HLinkToken\"]:\n\"\"\"Returns True if this token is an instance of HLinkToken.\"\"\"\n\n        return isinstance(self, HLinkToken)\n\n    def is_cursor(self) -&gt; TypeGuard[\"CursorToken\"]:\n\"\"\"Returns True if this token is an instance of CursorToken.\"\"\"\n\n        return isinstance(self, CursorToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.markup","title":"<code>markup: str</code>  <code>cached</code> <code>property</code>","text":"<p>Returns markup representing this token.</p>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.prettified_markup","title":"<code>prettified_markup: str</code>  <code>cached</code> <code>property</code>","text":"<p>Returns syntax-highlighted markup representing this token.</p>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_alias","title":"<code>is_alias()</code>","text":"<p>Returns True if this token is an instance of AliasToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_alias(self) -&gt; TypeGuard[\"AliasToken\"]:\n\"\"\"Returns True if this token is an instance of AliasToken.\"\"\"\n\n    return isinstance(self, AliasToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_clear","title":"<code>is_clear()</code>","text":"<p>Returns True if this token is an instance of ClearToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_clear(self) -&gt; TypeGuard[\"ClearToken\"]:\n\"\"\"Returns True if this token is an instance of ClearToken.\"\"\"\n\n    return isinstance(self, ClearToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_color","title":"<code>is_color()</code>","text":"<p>Returns True if this token is an instance of ColorToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_color(self) -&gt; TypeGuard[\"ColorToken\"]:\n\"\"\"Returns True if this token is an instance of ColorToken.\"\"\"\n\n    return isinstance(self, ColorToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_cursor","title":"<code>is_cursor()</code>","text":"<p>Returns True if this token is an instance of CursorToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_cursor(self) -&gt; TypeGuard[\"CursorToken\"]:\n\"\"\"Returns True if this token is an instance of CursorToken.\"\"\"\n\n    return isinstance(self, CursorToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_hyperlink","title":"<code>is_hyperlink()</code>","text":"<p>Returns True if this token is an instance of HLinkToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_hyperlink(self) -&gt; TypeGuard[\"HLinkToken\"]:\n\"\"\"Returns True if this token is an instance of HLinkToken.\"\"\"\n\n    return isinstance(self, HLinkToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_macro","title":"<code>is_macro()</code>","text":"<p>Returns True if this token is an instance of MacroToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_macro(self) -&gt; TypeGuard[\"MacroToken\"]:\n\"\"\"Returns True if this token is an instance of MacroToken.\"\"\"\n\n    return isinstance(self, MacroToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_plain","title":"<code>is_plain()</code>","text":"<p>Returns True if this token is an instance of PlainToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_plain(self) -&gt; TypeGuard[\"PlainToken\"]:\n\"\"\"Returns True if this token is an instance of PlainToken.\"\"\"\n\n    return isinstance(self, PlainToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_pseudo","title":"<code>is_pseudo()</code>","text":"<p>Returns True if this token is an instance of PseudoToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_pseudo(self) -&gt; TypeGuard[\"PseudoToken\"]:\n\"\"\"Returns True if this token is an instance of PseudoToken.\"\"\"\n\n    return isinstance(self, PseudoToken)\n</code></pre>"},{"location":"reference/pytermgui/markup/tokens/#pytermgui.markup.tokens.Token.is_style","title":"<code>is_style()</code>","text":"<p>Returns True if this token is an instance of StyleToken.</p> Source code in <code>pytermgui/markup/tokens.py</code> <pre><code>def is_style(self) -&gt; TypeGuard[\"StyleToken\"]:\n\"\"\"Returns True if this token is an instance of StyleToken.\"\"\"\n\n    return isinstance(self, StyleToken)\n</code></pre>"},{"location":"reference/pytermgui/widgets/","title":"Index","text":"<p>The widget system.</p>"},{"location":"reference/pytermgui/widgets/base/","title":"base","text":"<p>The basic building blocks making up the Widget system.</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Label","title":"<code>Label</code>","text":"<p>             Bases: <code>Widget</code></p> <p>A Widget to display a string</p> <p>By default, this widget uses <code>pytermgui.widgets.styles.MARKUP</code>. This allows it to house markup text that is parsed before display, such as:</p> <pre><code>print(\"hello world\")\n</code></pre> <pre><code>import pytermgui as ptg\n\nwith ptg.alt_buffer():\n    root = ptg.Container(\n        ptg.Label(\"[italic 141 bold]This is some [green]fancy [white inverse]text!\")\n    )\n    root.print()\n    ptg.getch()\n</code></pre> <p> </p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>class Label(Widget):\n\"\"\"A Widget to display a string\n\n    By default, this widget uses `pytermgui.widgets.styles.MARKUP`. This\n    allows it to house markup text that is parsed before display, such as:\n\n    ```termage-svg\n    print(\"hello world\")\n    ```\n\n    ```python3\n    import pytermgui as ptg\n\n    with ptg.alt_buffer():\n        root = ptg.Container(\n            ptg.Label(\"[italic 141 bold]This is some [green]fancy [white inverse]text!\")\n        )\n        root.print()\n        ptg.getch()\n    ```\n\n    &lt;p style=\"text-align: center\"&gt;\n     &lt;img\n      src=\"https://github.com/bczsalba/pytermgui/blob/master/assets/docs/widgets/label.png?raw=true\"\n      width=100%&gt;\n    &lt;/p&gt;\n    \"\"\"\n\n    serialized = Widget.serialized + [\"*value\", \"align\", \"padding\"]\n    styles = w_styles.StyleManager(value=\"\")\n\n    def __init__(\n        self,\n        value: str = \"\",\n        style: str | w_styles.StyleValue = \"\",\n        padding: int = 0,\n        non_first_padding: int = 0,\n        **attrs: Any,\n    ) -&gt; None:\n\"\"\"Initializes a Label.\n\n        Args:\n            value: The value of this string. Using the default value style\n                (`pytermgui.widgets.styles.MARKUP`),\n            style: A pre-set value for self.styles.value.\n            padding: The number of space (\" \") characters to prepend to every line after\n                line breaking.\n            non_first_padding: The number of space characters to prepend to every\n                non-first line of `get_lines`. This is applied on top of `padding`.\n        \"\"\"\n\n        super().__init__(**attrs)\n\n        self.value = value\n        self.padding = padding\n        self.non_first_padding = non_first_padding\n        self.width = real_length(value) + self.padding\n\n        if style != \"\":\n            self.styles.value = style\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Get lines representing this Label, breaking lines as necessary\"\"\"\n\n        lines = []\n        limit = self.width - self.padding\n        broken = break_line(\n            self.styles.value(self.value),\n            limit=limit,\n            non_first_limit=limit - self.non_first_padding,\n        )\n\n        for i, line in enumerate(broken):\n            if i == 0:\n                lines.append(self.padding * \" \" + line)\n                continue\n\n            lines.append(self.padding * \" \" + self.non_first_padding * \" \" + line)\n\n        return lines or [\"\"]\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Label.__init__","title":"<code>__init__(value='', style='', padding=0, non_first_padding=0, **attrs)</code>","text":"<p>Initializes a Label.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The value of this string. Using the default value style (<code>pytermgui.widgets.styles.MARKUP</code>),</p> <code>''</code> <code>style</code> <code>str | w_styles.StyleValue</code> <p>A pre-set value for self.styles.value.</p> <code>''</code> <code>padding</code> <code>int</code> <p>The number of space (\" \") characters to prepend to every line after line breaking.</p> <code>0</code> <code>non_first_padding</code> <code>int</code> <p>The number of space characters to prepend to every non-first line of <code>get_lines</code>. This is applied on top of <code>padding</code>.</p> <code>0</code> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def __init__(\n    self,\n    value: str = \"\",\n    style: str | w_styles.StyleValue = \"\",\n    padding: int = 0,\n    non_first_padding: int = 0,\n    **attrs: Any,\n) -&gt; None:\n\"\"\"Initializes a Label.\n\n    Args:\n        value: The value of this string. Using the default value style\n            (`pytermgui.widgets.styles.MARKUP`),\n        style: A pre-set value for self.styles.value.\n        padding: The number of space (\" \") characters to prepend to every line after\n            line breaking.\n        non_first_padding: The number of space characters to prepend to every\n            non-first line of `get_lines`. This is applied on top of `padding`.\n    \"\"\"\n\n    super().__init__(**attrs)\n\n    self.value = value\n    self.padding = padding\n    self.non_first_padding = non_first_padding\n    self.width = real_length(value) + self.padding\n\n    if style != \"\":\n        self.styles.value = style\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Label.get_lines","title":"<code>get_lines()</code>","text":"<p>Get lines representing this Label, breaking lines as necessary</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Get lines representing this Label, breaking lines as necessary\"\"\"\n\n    lines = []\n    limit = self.width - self.padding\n    broken = break_line(\n        self.styles.value(self.value),\n        limit=limit,\n        non_first_limit=limit - self.non_first_padding,\n    )\n\n    for i, line in enumerate(broken):\n        if i == 0:\n            lines.append(self.padding * \" \" + line)\n            continue\n\n        lines.append(self.padding * \" \" + self.non_first_padding * \" \" + line)\n\n    return lines or [\"\"]\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.ScrollableWidget","title":"<code>ScrollableWidget</code>","text":"<p>             Bases: <code>Widget</code></p> <p>A widget with some scrolling helper methods.</p> <p>This is not an implementation of the scrolling behaviour itself, just the user-facing API for it.</p> <p>It provides a <code>_scroll_offset</code> attribute, which is an integer describing the current scroll state offset from the top, as well as some methods to modify the state.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>class ScrollableWidget(Widget):\n\"\"\"A widget with some scrolling helper methods.\n\n    This is not an implementation of the scrolling behaviour itself, just the\n    user-facing API for it.\n\n    It provides a `_scroll_offset` attribute, which is an integer describing the current\n    scroll state offset from the top, as well as some methods to modify the state.\"\"\"\n\n    def __init__(self, **attrs: Any) -&gt; None:\n\"\"\"Initializes the scrollable widget.\"\"\"\n\n        super().__init__(**attrs)\n\n        self._max_scroll = 0\n        self._scroll_offset = 0\n\n    def scroll(self, offset: int) -&gt; bool:\n\"\"\"Scrolls to given offset, returns the new scroll_offset.\n\n        Args:\n            offset: The amount to scroll by. Positive offsets scroll down,\n                negative up.\n\n        Returns:\n            True if the scroll offset changed, False otherwise.\n        \"\"\"\n\n        base = self._scroll_offset\n\n        self._scroll_offset = min(\n            max(0, self._scroll_offset + offset), self._max_scroll\n        )\n\n        return base != self._scroll_offset\n\n    def scroll_end(self, end: int) -&gt; int:\n\"\"\"Scrolls to either top or bottom end of this object.\n\n        Args:\n            end: The offset to scroll to. 0 goes to the very top, -1 to the\n                very bottom.\n\n        Returns:\n            True if the scroll offset changed, False otherwise.\n        \"\"\"\n\n        base = self._scroll_offset\n\n        if end == 0:\n            self._scroll_offset = 0\n\n        elif end == -1:\n            self._scroll_offset = self._max_scroll\n\n        return base != self._scroll_offset\n\n    def get_lines(self) -&gt; list[str]:\n        ...\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.ScrollableWidget.__init__","title":"<code>__init__(**attrs)</code>","text":"<p>Initializes the scrollable widget.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def __init__(self, **attrs: Any) -&gt; None:\n\"\"\"Initializes the scrollable widget.\"\"\"\n\n    super().__init__(**attrs)\n\n    self._max_scroll = 0\n    self._scroll_offset = 0\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.ScrollableWidget.scroll","title":"<code>scroll(offset)</code>","text":"<p>Scrolls to given offset, returns the new scroll_offset.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The amount to scroll by. Positive offsets scroll down, negative up.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the scroll offset changed, False otherwise.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def scroll(self, offset: int) -&gt; bool:\n\"\"\"Scrolls to given offset, returns the new scroll_offset.\n\n    Args:\n        offset: The amount to scroll by. Positive offsets scroll down,\n            negative up.\n\n    Returns:\n        True if the scroll offset changed, False otherwise.\n    \"\"\"\n\n    base = self._scroll_offset\n\n    self._scroll_offset = min(\n        max(0, self._scroll_offset + offset), self._max_scroll\n    )\n\n    return base != self._scroll_offset\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.ScrollableWidget.scroll_end","title":"<code>scroll_end(end)</code>","text":"<p>Scrolls to either top or bottom end of this object.</p> <p>Parameters:</p> Name Type Description Default <code>end</code> <code>int</code> <p>The offset to scroll to. 0 goes to the very top, -1 to the very bottom.</p> required <p>Returns:</p> Type Description <code>int</code> <p>True if the scroll offset changed, False otherwise.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def scroll_end(self, end: int) -&gt; int:\n\"\"\"Scrolls to either top or bottom end of this object.\n\n    Args:\n        end: The offset to scroll to. 0 goes to the very top, -1 to the\n            very bottom.\n\n    Returns:\n        True if the scroll offset changed, False otherwise.\n    \"\"\"\n\n    base = self._scroll_offset\n\n    if end == 0:\n        self._scroll_offset = 0\n\n    elif end == -1:\n        self._scroll_offset = self._max_scroll\n\n    return base != self._scroll_offset\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget","title":"<code>Widget</code>","text":"<p>The base of the Widget system</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>class Widget:  # pylint: disable=too-many-public-methods\n\"\"\"The base of the Widget system\"\"\"\n\n    set_style = classmethod(_set_obj_or_cls_style)\n    set_char = classmethod(_set_obj_or_cls_char)\n\n    styles = w_styles.StyleManager()\n\"\"\"Default styles for this class\"\"\"\n\n    chars: dict[str, w_styles.CharType] = {}\n\"\"\"Default characters for this class\"\"\"\n\n    keys: dict[str, set[str]] = {}\n\"\"\"Groups of keys that are used in `handle_key`\"\"\"\n\n    serialized: list[str] = [\n        \"id\",\n        \"pos\",\n        \"depth\",\n        \"width\",\n        \"height\",\n        \"selected_index\",\n        \"selectables_length\",\n    ]\n\"\"\"Fields of widget that shall be serialized by `pytermgui.serializer.Serializer`\"\"\"\n\n    # This class is loaded after this module,\n    # and thus mypy doesn't see its existence.\n    _id_manager: Optional[\"_IDManager\"] = None  # type: ignore\n\n    size_policy = SizePolicy.get_default()\n\"\"\"`pytermgui.enums.SizePolicy` to set widget's width according to\"\"\"\n\n    parent_align = HorizontalAlignment.get_default()\n\"\"\"`pytermgui.enums.HorizontalAlignment` to align widget by\"\"\"\n\n    from_data: Callable[..., Widget | list[Widget] | None]\n\n    # We cannot import boxes here due to cyclic imports.\n    box: Any\n\n    def __init__(self, **attrs: Any) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n        self.set_style = lambda key, value: _set_obj_or_cls_style(self, key, value)\n        self.set_char = lambda key, value: _set_obj_or_cls_char(self, key, value)\n\n        self.width = 1\n        self.height = 1\n        self.pos = self.terminal.origin\n\n        self.depth = 0\n\n        self.styles = type(self).styles.branch(self)\n        self.chars = type(self).chars.copy()\n\n        self.parent: Widget | None = None\n        self.selected_index: int | None = None\n\n        self._selectables_length = 0\n        self._id: Optional[str] = None\n        self._serialized_fields = type(self).serialized\n        self._bindings: dict[str | Type[MouseEvent], tuple[BoundCallback, str]] = {}\n        self._relative_width: float | None = None\n        self._previous_state: tuple[tuple[int, int], list[str]] | None = None\n\n        self.positioned_line_buffer: list[tuple[tuple[int, int], str]] = []\n\n        for attr, value in attrs.items():\n            setattr(self, attr, value)\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return repr string of this widget.\n\n        Returns:\n            Whatever this widget's `debug` method gives.\n        \"\"\"\n\n        return self.debug()\n\n    def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields the repr of this object, then a preview of it.\"\"\"\n\n        yield self.debug()\n        yield \"\\n\\n\"\n        yield {\n            \"text\": \"\\n\".join((line + reset() for line in self.get_lines())),\n            \"highlight\": False,\n        }\n\n    def __iter__(self) -&gt; Iterator[Widget]:\n\"\"\"Return self for iteration\"\"\"\n\n        yield self\n\n    @property\n    def bindings(self) -&gt; dict[str | Type[MouseEvent], tuple[BoundCallback, str]]:\n\"\"\"Gets a copy of the bindings internal dictionary.\n\n        Returns:\n            A copy of the internal bindings dictionary, such as:\n\n            ```\n            {\n                \"*\": (star_callback, \"This is a callback activated when '*' is pressed.\")\n            }\n            ```\n        \"\"\"\n\n        return self._bindings.copy()\n\n    @property\n    def id(self) -&gt; Optional[str]:  # pylint: disable=invalid-name\n\"\"\"Gets this widget's id property\n\n        Returns:\n            The id string if one is present, None otherwise.\n        \"\"\"\n\n        return self._id\n\n    @id.setter\n    def id(self, value: str) -&gt; None:  # pylint: disable=invalid-name\n\"\"\"Registers a widget to the Widget._id_manager.\n\n        If this widget already had an id, the old value is deregistered\n        before the new one is assigned.\n\n        Args:\n            value: The new id this widget will be registered as.\n        \"\"\"\n\n        if self._id == value:\n            return\n\n        manager = Widget._id_manager\n        assert manager is not None\n\n        old = manager.get_id(self)\n        if old is not None:\n            manager.deregister(old)\n\n        self._id = value\n        manager.register(self)\n\n    @property\n    def selectables_length(self) -&gt; int:\n\"\"\"Gets how many selectables this widget contains.\n\n        Returns:\n            An integer describing the amount of selectables in this widget.\n        \"\"\"\n\n        return self._selectables_length\n\n    @property\n    def selectables(self) -&gt; list[tuple[Widget, int]]:\n\"\"\"Gets a list of all selectables within this widget\n\n        Returns:\n            A list of tuples. In the default implementation this will be\n            a list of one tuple, containing a reference to `self`, as well\n            as the lowest index, 0.\n        \"\"\"\n\n        return [(self, 0)]\n\n    @property\n    def is_selectable(self) -&gt; bool:\n\"\"\"Determines whether this widget has any selectables.\n\n        Returns:\n            A boolean, representing `self.selectables_length != 0`.\n        \"\"\"\n\n        return self.selectables_length != 0\n\n    @property\n    def static_width(self) -&gt; int:\n\"\"\"Allows for a shorter way of setting a width, and SizePolicy.STATIC.\n\n        Args:\n            value: The new width integer.\n\n        Returns:\n            None, as this is setter only.\n        \"\"\"\n\n        return None  # type: ignore\n\n    @static_width.setter\n    def static_width(self, value: int) -&gt; None:\n\"\"\"See the static_width getter.\"\"\"\n\n        self.width = value\n        self.size_policy = SizePolicy.STATIC\n\n    @property\n    def relative_width(self) -&gt; float | None:\n\"\"\"Sets this widget's relative width, and changes size_policy to RELATIVE.\n\n        The value is clamped to 1.0.\n\n        If a Container holds a width of 30, and it has a subwidget with a relative\n        width of 0.5, it will be resized to 15.\n\n        Args:\n            value: The multiplier to apply to the parent's width.\n\n        Returns:\n            The current relative_width.\n        \"\"\"\n\n        return self._relative_width\n\n    @relative_width.setter\n    def relative_width(self, value: float) -&gt; None:\n\"\"\"See the relative_width getter.\"\"\"\n\n        self.size_policy = SizePolicy.RELATIVE\n        self._relative_width = min(1.0, value)\n\n    @property\n    def terminal(self) -&gt; Terminal:\n\"\"\"Returns the current global terminal instance.\"\"\"\n\n        return get_terminal()\n\n    def _align(self, lines: list[str]) -&gt; list[str]:\n\"\"\"Aligns the given lines based on this widget's `parent_align` attribute.\"\"\"\n\n        width = self.width\n\n        def _align_left(line: str) -&gt; str:\n            return line + (width - real_length(line)) * \" \"\n\n        def _align_center(line: str) -&gt; str:\n            right, extra = divmod(width - real_length(line), 2)\n            left = right + extra\n\n            return left * \" \" + line + right * \" \"\n\n        def _align_right(line: str) -&gt; str:\n            return (width - real_length(line)) * \" \" + line\n\n        if self.parent_align is None:\n            raise TypeError(\"Horizontal alignment cannot be None.\")\n\n        assert isinstance(self.parent_align, HorizontalAlignment)\n\n        aligner = {\n            HorizontalAlignment.LEFT: _align_left,\n            HorizontalAlignment.CENTER: _align_center,\n            HorizontalAlignment.RIGHT: _align_right,\n        }[self.parent_align]\n\n        aligned = []\n\n        for line in lines:\n            aligned.append(aligner(line))\n\n        return aligned\n\n    def get_change(self) -&gt; WidgetChange | None:\n\"\"\"Determines whether widget lines changed since the last call to this function.\"\"\"\n\n        lines = self.get_lines()\n\n        if self._previous_state is None:\n            self._previous_state = (self.width, self.height), lines\n            return WidgetChange.LINES\n\n        lines = self.get_lines()\n        (old_width, old_height), old_lines = self._previous_state\n\n        self._previous_state = (self.width, self.height), lines\n\n        if old_width != self.width and old_height != self.height:\n            return WidgetChange.SIZE\n\n        if old_width != self.width:\n            return WidgetChange.WIDTH\n\n        if old_height != self.height:\n            return WidgetChange.HEIGHT\n\n        if old_lines != lines:\n            return WidgetChange.LINES\n\n        return None\n\n    def contains(self, pos: tuple[int, int]) -&gt; bool:\n\"\"\"Determines whether widget contains `pos`.\n\n        Args:\n            pos: Position to compare.\n\n        Returns:\n            Boolean describing whether the position is inside\n                this widget.\n        \"\"\"\n\n        rect = self.pos, (\n            self.pos[0] + self.width,\n            self.pos[1] + self.height,\n        )\n\n        (left, top), (right, bottom) = rect\n\n        return left &lt;= pos[0] &lt; right and top &lt;= pos[1] &lt; bottom\n\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Tries to call the most specific mouse handler function available.\n\n        This function looks for a set of mouse action handlers. Each handler follows\n        the format\n\n            on_{event_name}\n\n        For example, the handler triggered on MouseAction.LEFT_CLICK would be\n        `on_left_click`. If no handler is found nothing is done.\n\n        You can also define more general handlers, for example to group left &amp; right\n        clicks you can use `on_click`, and to catch both up and down scroll you can use\n        `on_scroll`. General handlers are only used if they are the most specific ones,\n        i.e. there is no \"specific\" handler.\n\n        Args:\n            event: The event to handle.\n\n        Returns:\n            Whether the parent of this widget should treat it as one to \"stick\" events\n            to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by\n            returning False in the handler.\n        \"\"\"\n\n        def _get_names(action: MouseAction) -&gt; tuple[str, ...]:\n            if action.value in [\"hover\", \"release\"]:\n                return (action.value,)\n\n            parts = action.value.split(\"_\")\n\n            # left click &amp; right click\n            if parts[0] in [\"left\", \"right\"]:\n                return (action.value, parts[1])\n\n            if parts[0] == \"shift\":\n                return (action.value, f\"shift_{parts[1]}\", parts[1])\n\n            # scroll up &amp; down\n            return (action.value, parts[0])\n\n        possible_names = _get_names(event.action)\n        for name in possible_names:\n            if hasattr(self, f\"on_{name}\"):\n                handle = getattr(self, f\"on_{name}\")\n\n                return handle(event)\n\n        return False\n\n    def handle_key(self, key: str) -&gt; bool:\n\"\"\"Handles a mouse event, returning its success.\n\n        Args:\n            key: String representation of input string.\n                The `pytermgui.input.keys` object can be\n                used to retrieve special keys.\n\n        Returns:\n            A boolean describing whether the key was handled.\n        \"\"\"\n\n        return False and hasattr(self, key)\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serializes a widget.\n\n        The fields looked at are defined `Widget.serialized`. Note that\n        this method is not very commonly used at the moment, so it might\n        not have full functionality in non-nuclear widgets.\n\n        Returns:\n            Dictionary of widget attributes. The dictionary will always\n            have a `type` field. Any styles are converted into markup\n            strings during serialization, so they can be loaded again in\n            their original form.\n\n            Example return:\n            ```\n                {\n                    \"type\": \"Label\",\n                    \"value\": \"[210 bold]I am a title\",\n                    \"parent_align\": 0,\n                    ...\n                }\n            ```\n        \"\"\"\n\n        fields = self._serialized_fields\n\n        out: dict[str, Any] = {\"type\": type(self).__name__}\n        for key in fields:\n            # Detect styled values\n            if key.startswith(\"*\"):\n                style = True\n                key = key[1:]\n            else:\n                style = False\n\n            value = getattr(self, key)\n\n            # Convert styled value into markup\n            if style:\n                style_call = self._get_style(key)\n                if isinstance(value, list):\n                    out[key] = [get_markup(style_call(char)) for char in value]\n                else:\n                    out[key] = get_markup(style_call(value))\n\n                continue\n\n            out[key] = value\n\n        # The chars need to be handled separately\n        out[\"chars\"] = {}\n        for key, value in self.chars.items():\n            style_call = self._get_style(key)\n\n            if isinstance(value, list):\n                out[\"chars\"][key] = [get_markup(style_call(char)) for char in value]\n            else:\n                out[\"chars\"][key] = get_markup(style_call(value))\n\n        return out\n\n    def copy(self) -&gt; Widget:\n\"\"\"Creates a deep copy of this widget\"\"\"\n\n        return deepcopy(self)\n\n    def _get_style(self, key: str) -&gt; w_styles.DepthlessStyleType:\n\"\"\"Gets style call from its key.\n\n        This is analogous to using `self.styles.{key}`\n\n        Args:\n            key: A key into the widget's style manager.\n\n        Returns:\n            A `pytermgui.styles.StyleCall` object containing the referenced\n            style. StyleCall objects should only be used internally inside a\n            widget.\n\n        Raises:\n            KeyError: Style key is invalid.\n        \"\"\"\n\n        return self.styles[key]\n\n    def _get_char(self, key: str) -&gt; w_styles.CharType:\n\"\"\"Gets character from its key.\n\n        Args:\n            key: A key into the widget's chars dictionary.\n\n        Returns:\n            Either a `list[str]` or a simple `str`, depending on the character.\n\n        Raises:\n            KeyError: Style key is invalid.\n        \"\"\"\n\n        chars = self.chars[key]\n\n        if isinstance(chars, str):\n            if chars.startswith(\"u:\"):\n                identifier = \" \".join(chars[2:].split(\"_\"))\n                chars = u_lookup(identifier)\n\n            return chars\n\n        return chars.copy()\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Gets lines representing this widget.\n\n        These lines have to be equal to the widget in length. All\n        widgets must provide this method. Make sure to keep it performant,\n        as it will be called very often, often multiple times per WindowManager frame.\n\n        Any longer actions should be done outside of this method, and only their\n        result should be looked up here.\n\n        Returns:\n            Nothing by default.\n\n        Raises:\n            NotImplementedError: As this method is required for **all** widgets, not\n                having it defined will raise NotImplementedError.\n        \"\"\"\n\n        raise NotImplementedError(f\"get_lines() is not defined for type {type(self)}.\")\n\n    def move(self, diff_x: int, diff_y: int) -&gt; None:\n\"\"\"Moves the widget by the given x and y changes.\"\"\"\n\n        self.pos = (self.pos[0] + diff_x, self.pos[1] + diff_y)\n\n        adjusted = []\n        for pos, line in self.positioned_line_buffer:\n            adjusted.append(((pos[0] + diff_x, pos[1] + diff_y), line))\n\n        self.positioned_line_buffer = adjusted\n\n    def bind(\n        self, key: str, action: BoundCallback, description: Optional[str] = None\n    ) -&gt; None:\n\"\"\"Binds an action to a keypress.\n\n        This function is only called by implementations above this layer. To use this\n        functionality use `pytermgui.window_manager.WindowManager`, or write your own\n        custom layer.\n\n        Special keys:\n        - keys.ANY_KEY: Any and all keypresses execute this binding.\n        - keys.MouseAction: Any and all mouse inputs execute this binding.\n\n        Args:\n            key: The key that the action will be bound to.\n            action: The action executed when the key is pressed.\n            description: An optional description for this binding. It is not really\n                used anywhere, but you can provide a helper menu and display them.\n        \"\"\"\n\n        if description is None:\n            description = f\"Binding of {key} to {action}\"\n\n        self._bindings[key] = (action, description)\n\n    def unbind(self, key: str) -&gt; None:\n\"\"\"Unbinds the given key.\"\"\"\n\n        del self._bindings[key]\n\n    def execute_binding(self, key: Any, ignore_any: bool = False) -&gt; bool:\n\"\"\"Executes a binding belonging to key, when present.\n\n        Use this method inside custom widget `handle_keys` methods, or to run a callback\n        without its corresponding key having been pressed.\n\n        Args:\n            key: Usually a string, indexing into the `_bindings` dictionary. These are the\n                same strings as defined in `Widget.bind`.\n            ignore_any: If set, `keys.ANY_KEY` bindings will not be executed.\n\n        Returns:\n            True if the binding was found, False otherwise. Bindings will always be\n                executed if they are found.\n        \"\"\"\n\n        # Execute special binding\n        if not ignore_any and keys.ANY_KEY in self._bindings:\n            method, _ = self._bindings[keys.ANY_KEY]\n            method(self, key)\n\n        if key in self._bindings:\n            method, _ = self._bindings[key]\n            method(self, key)\n\n            return True\n\n        return False\n\n    def select(self, index: int | None = None) -&gt; None:\n\"\"\"Selects a part of this Widget.\n\n        Args:\n            index: The index to select.\n\n        Raises:\n            TypeError: This widget has no selectables, i.e. widget.is_selectable == False.\n        \"\"\"\n\n        if not self.is_selectable:\n            raise TypeError(f\"Object of type {type(self)} has no selectables.\")\n\n        if index is not None:\n            index = min(max(0, index), self.selectables_length - 1)\n        self.selected_index = index\n\n    def print(self) -&gt; None:\n\"\"\"Prints this widget\"\"\"\n\n        for line in self.get_lines():\n            print(line)\n\n    def debug(self) -&gt; str:\n\"\"\"Returns identifiable information about this widget.\n\n        This method is used to easily differentiate between widgets. By default, all widget's\n        __repr__ method is an alias to this. The signature of each widget is used to generate\n        the return value.\n\n        Returns:\n            A string almost exactly matching the line of code that could have defined the widget.\n\n            Example return:\n\n            ```\n            Container(Label(value=\"This is a label\", padding=0),\n            Button(label=\"This is a button\", padding=0), **attrs)\n            ```\n\n        \"\"\"\n\n        constructor = \"(\"\n        for name in signature(getattr(self, \"__init__\")).parameters:\n            current = \"\"\n            if name == \"attrs\":\n                current += \"**attrs\"\n                continue\n\n            if len(constructor) &gt; 1:\n                current += \", \"\n\n            current += name\n\n            attr = getattr(self, name, None)\n            if attr is None:\n                continue\n\n            current += \"=\"\n\n            if isinstance(attr, str):\n                current += f'\"{attr}\"'\n            else:\n                current += str(attr)\n\n            constructor += current\n\n        constructor += \")\"\n\n        return type(self).__name__ + constructor\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.bindings","title":"<code>bindings: dict[str | Type[MouseEvent], tuple[BoundCallback, str]]</code>  <code>property</code>","text":"<p>Gets a copy of the bindings internal dictionary.</p> <p>Returns:</p> Type Description <code>dict[str | Type[MouseEvent], tuple[BoundCallback, str]]</code> <p>A copy of the internal bindings dictionary, such as:</p> <code>dict[str | Type[MouseEvent], tuple[BoundCallback, str]]</code> <p>```</p> <code>dict[str | Type[MouseEvent], tuple[BoundCallback, str]]</code> <p>{ \"\": (star_callback, \"This is a callback activated when '' is pressed.\")</p> <code>dict[str | Type[MouseEvent], tuple[BoundCallback, str]]</code> <p>}</p> <code>dict[str | Type[MouseEvent], tuple[BoundCallback, str]]</code> <p>```</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.chars","title":"<code>chars: dict[str, w_styles.CharType] = type(self).chars.copy()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default characters for this class</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.id","title":"<code>id: Optional[str]</code>  <code>property</code> <code>writable</code>","text":"<p>Gets this widget's id property</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The id string if one is present, None otherwise.</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.is_selectable","title":"<code>is_selectable: bool</code>  <code>property</code>","text":"<p>Determines whether this widget has any selectables.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean, representing <code>self.selectables_length != 0</code>.</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.keys","title":"<code>keys: dict[str, set[str]] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Groups of keys that are used in <code>handle_key</code></p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.parent_align","title":"<code>parent_align = HorizontalAlignment.get_default()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p><code>pytermgui.enums.HorizontalAlignment</code> to align widget by</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.relative_width","title":"<code>relative_width: float | None</code>  <code>property</code> <code>writable</code>","text":"<p>Sets this widget's relative width, and changes size_policy to RELATIVE.</p> <p>The value is clamped to 1.0.</p> <p>If a Container holds a width of 30, and it has a subwidget with a relative width of 0.5, it will be resized to 15.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The multiplier to apply to the parent's width.</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>The current relative_width.</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.selectables","title":"<code>selectables: list[tuple[Widget, int]]</code>  <code>property</code>","text":"<p>Gets a list of all selectables within this widget</p> <p>Returns:</p> Type Description <code>list[tuple[Widget, int]]</code> <p>A list of tuples. In the default implementation this will be</p> <code>list[tuple[Widget, int]]</code> <p>a list of one tuple, containing a reference to <code>self</code>, as well</p> <code>list[tuple[Widget, int]]</code> <p>as the lowest index, 0.</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.selectables_length","title":"<code>selectables_length: int</code>  <code>property</code>","text":"<p>Gets how many selectables this widget contains.</p> <p>Returns:</p> Type Description <code>int</code> <p>An integer describing the amount of selectables in this widget.</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.serialized","title":"<code>serialized: list[str] = ['id', 'pos', 'depth', 'width', 'height', 'selected_index', 'selectables_length']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fields of widget that shall be serialized by <code>pytermgui.serializer.Serializer</code></p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.size_policy","title":"<code>size_policy = SizePolicy.get_default()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p><code>pytermgui.enums.SizePolicy</code> to set widget's width according to</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.static_width","title":"<code>static_width: int</code>  <code>property</code> <code>writable</code>","text":"<p>Allows for a shorter way of setting a width, and SizePolicy.STATIC.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The new width integer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>None, as this is setter only.</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.styles","title":"<code>styles = type(self).styles.branch(self)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default styles for this class</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.terminal","title":"<code>terminal: Terminal</code>  <code>property</code>","text":"<p>Returns the current global terminal instance.</p>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.__fancy_repr__","title":"<code>__fancy_repr__()</code>","text":"<p>Yields the repr of this object, then a preview of it.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def __fancy_repr__(self) -&gt; Generator[FancyYield, None, None]:\n\"\"\"Yields the repr of this object, then a preview of it.\"\"\"\n\n    yield self.debug()\n    yield \"\\n\\n\"\n    yield {\n        \"text\": \"\\n\".join((line + reset() for line in self.get_lines())),\n        \"highlight\": False,\n    }\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.__init__","title":"<code>__init__(**attrs)</code>","text":"<p>Initialize object</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def __init__(self, **attrs: Any) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n    self.set_style = lambda key, value: _set_obj_or_cls_style(self, key, value)\n    self.set_char = lambda key, value: _set_obj_or_cls_char(self, key, value)\n\n    self.width = 1\n    self.height = 1\n    self.pos = self.terminal.origin\n\n    self.depth = 0\n\n    self.styles = type(self).styles.branch(self)\n    self.chars = type(self).chars.copy()\n\n    self.parent: Widget | None = None\n    self.selected_index: int | None = None\n\n    self._selectables_length = 0\n    self._id: Optional[str] = None\n    self._serialized_fields = type(self).serialized\n    self._bindings: dict[str | Type[MouseEvent], tuple[BoundCallback, str]] = {}\n    self._relative_width: float | None = None\n    self._previous_state: tuple[tuple[int, int], list[str]] | None = None\n\n    self.positioned_line_buffer: list[tuple[tuple[int, int], str]] = []\n\n    for attr, value in attrs.items():\n        setattr(self, attr, value)\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.__iter__","title":"<code>__iter__()</code>","text":"<p>Return self for iteration</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Widget]:\n\"\"\"Return self for iteration\"\"\"\n\n    yield self\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.__repr__","title":"<code>__repr__()</code>","text":"<p>Return repr string of this widget.</p> <p>Returns:</p> Type Description <code>str</code> <p>Whatever this widget's <code>debug</code> method gives.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return repr string of this widget.\n\n    Returns:\n        Whatever this widget's `debug` method gives.\n    \"\"\"\n\n    return self.debug()\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.bind","title":"<code>bind(key, action, description=None)</code>","text":"<p>Binds an action to a keypress.</p> <p>This function is only called by implementations above this layer. To use this functionality use <code>pytermgui.window_manager.WindowManager</code>, or write your own custom layer.</p> <p>Special keys: - keys.ANY_KEY: Any and all keypresses execute this binding. - keys.MouseAction: Any and all mouse inputs execute this binding.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key that the action will be bound to.</p> required <code>action</code> <code>BoundCallback</code> <p>The action executed when the key is pressed.</p> required <code>description</code> <code>Optional[str]</code> <p>An optional description for this binding. It is not really used anywhere, but you can provide a helper menu and display them.</p> <code>None</code> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def bind(\n    self, key: str, action: BoundCallback, description: Optional[str] = None\n) -&gt; None:\n\"\"\"Binds an action to a keypress.\n\n    This function is only called by implementations above this layer. To use this\n    functionality use `pytermgui.window_manager.WindowManager`, or write your own\n    custom layer.\n\n    Special keys:\n    - keys.ANY_KEY: Any and all keypresses execute this binding.\n    - keys.MouseAction: Any and all mouse inputs execute this binding.\n\n    Args:\n        key: The key that the action will be bound to.\n        action: The action executed when the key is pressed.\n        description: An optional description for this binding. It is not really\n            used anywhere, but you can provide a helper menu and display them.\n    \"\"\"\n\n    if description is None:\n        description = f\"Binding of {key} to {action}\"\n\n    self._bindings[key] = (action, description)\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.contains","title":"<code>contains(pos)</code>","text":"<p>Determines whether widget contains <code>pos</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>Position to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean describing whether the position is inside this widget.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def contains(self, pos: tuple[int, int]) -&gt; bool:\n\"\"\"Determines whether widget contains `pos`.\n\n    Args:\n        pos: Position to compare.\n\n    Returns:\n        Boolean describing whether the position is inside\n            this widget.\n    \"\"\"\n\n    rect = self.pos, (\n        self.pos[0] + self.width,\n        self.pos[1] + self.height,\n    )\n\n    (left, top), (right, bottom) = rect\n\n    return left &lt;= pos[0] &lt; right and top &lt;= pos[1] &lt; bottom\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.copy","title":"<code>copy()</code>","text":"<p>Creates a deep copy of this widget</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def copy(self) -&gt; Widget:\n\"\"\"Creates a deep copy of this widget\"\"\"\n\n    return deepcopy(self)\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.debug","title":"<code>debug()</code>","text":"<p>Returns identifiable information about this widget.</p> <p>This method is used to easily differentiate between widgets. By default, all widget's repr method is an alias to this. The signature of each widget is used to generate the return value.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string almost exactly matching the line of code that could have defined the widget.</p> <code>str</code> <p>Example return:</p> <code>str</code> <p>```</p> <code>str</code> <p>Container(Label(value=\"This is a label\", padding=0),</p> <code>str</code> <p>Button(label=\"This is a button\", padding=0), **attrs)</p> <code>str</code> <p>```</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def debug(self) -&gt; str:\n\"\"\"Returns identifiable information about this widget.\n\n    This method is used to easily differentiate between widgets. By default, all widget's\n    __repr__ method is an alias to this. The signature of each widget is used to generate\n    the return value.\n\n    Returns:\n        A string almost exactly matching the line of code that could have defined the widget.\n\n        Example return:\n\n        ```\n        Container(Label(value=\"This is a label\", padding=0),\n        Button(label=\"This is a button\", padding=0), **attrs)\n        ```\n\n    \"\"\"\n\n    constructor = \"(\"\n    for name in signature(getattr(self, \"__init__\")).parameters:\n        current = \"\"\n        if name == \"attrs\":\n            current += \"**attrs\"\n            continue\n\n        if len(constructor) &gt; 1:\n            current += \", \"\n\n        current += name\n\n        attr = getattr(self, name, None)\n        if attr is None:\n            continue\n\n        current += \"=\"\n\n        if isinstance(attr, str):\n            current += f'\"{attr}\"'\n        else:\n            current += str(attr)\n\n        constructor += current\n\n    constructor += \")\"\n\n    return type(self).__name__ + constructor\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.execute_binding","title":"<code>execute_binding(key, ignore_any=False)</code>","text":"<p>Executes a binding belonging to key, when present.</p> <p>Use this method inside custom widget <code>handle_keys</code> methods, or to run a callback without its corresponding key having been pressed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>Usually a string, indexing into the <code>_bindings</code> dictionary. These are the same strings as defined in <code>Widget.bind</code>.</p> required <code>ignore_any</code> <code>bool</code> <p>If set, <code>keys.ANY_KEY</code> bindings will not be executed.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the binding was found, False otherwise. Bindings will always be executed if they are found.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def execute_binding(self, key: Any, ignore_any: bool = False) -&gt; bool:\n\"\"\"Executes a binding belonging to key, when present.\n\n    Use this method inside custom widget `handle_keys` methods, or to run a callback\n    without its corresponding key having been pressed.\n\n    Args:\n        key: Usually a string, indexing into the `_bindings` dictionary. These are the\n            same strings as defined in `Widget.bind`.\n        ignore_any: If set, `keys.ANY_KEY` bindings will not be executed.\n\n    Returns:\n        True if the binding was found, False otherwise. Bindings will always be\n            executed if they are found.\n    \"\"\"\n\n    # Execute special binding\n    if not ignore_any and keys.ANY_KEY in self._bindings:\n        method, _ = self._bindings[keys.ANY_KEY]\n        method(self, key)\n\n    if key in self._bindings:\n        method, _ = self._bindings[key]\n        method(self, key)\n\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.get_change","title":"<code>get_change()</code>","text":"<p>Determines whether widget lines changed since the last call to this function.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def get_change(self) -&gt; WidgetChange | None:\n\"\"\"Determines whether widget lines changed since the last call to this function.\"\"\"\n\n    lines = self.get_lines()\n\n    if self._previous_state is None:\n        self._previous_state = (self.width, self.height), lines\n        return WidgetChange.LINES\n\n    lines = self.get_lines()\n    (old_width, old_height), old_lines = self._previous_state\n\n    self._previous_state = (self.width, self.height), lines\n\n    if old_width != self.width and old_height != self.height:\n        return WidgetChange.SIZE\n\n    if old_width != self.width:\n        return WidgetChange.WIDTH\n\n    if old_height != self.height:\n        return WidgetChange.HEIGHT\n\n    if old_lines != lines:\n        return WidgetChange.LINES\n\n    return None\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.get_lines","title":"<code>get_lines()</code>","text":"<p>Gets lines representing this widget.</p> <p>These lines have to be equal to the widget in length. All widgets must provide this method. Make sure to keep it performant, as it will be called very often, often multiple times per WindowManager frame.</p> <p>Any longer actions should be done outside of this method, and only their result should be looked up here.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Nothing by default.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>As this method is required for all widgets, not having it defined will raise NotImplementedError.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Gets lines representing this widget.\n\n    These lines have to be equal to the widget in length. All\n    widgets must provide this method. Make sure to keep it performant,\n    as it will be called very often, often multiple times per WindowManager frame.\n\n    Any longer actions should be done outside of this method, and only their\n    result should be looked up here.\n\n    Returns:\n        Nothing by default.\n\n    Raises:\n        NotImplementedError: As this method is required for **all** widgets, not\n            having it defined will raise NotImplementedError.\n    \"\"\"\n\n    raise NotImplementedError(f\"get_lines() is not defined for type {type(self)}.\")\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.handle_key","title":"<code>handle_key(key)</code>","text":"<p>Handles a mouse event, returning its success.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>String representation of input string. The <code>pytermgui.input.keys</code> object can be used to retrieve special keys.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean describing whether the key was handled.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def handle_key(self, key: str) -&gt; bool:\n\"\"\"Handles a mouse event, returning its success.\n\n    Args:\n        key: String representation of input string.\n            The `pytermgui.input.keys` object can be\n            used to retrieve special keys.\n\n    Returns:\n        A boolean describing whether the key was handled.\n    \"\"\"\n\n    return False and hasattr(self, key)\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.handle_mouse","title":"<code>handle_mouse(event)</code>","text":"<p>Tries to call the most specific mouse handler function available.</p> <p>This function looks for a set of mouse action handlers. Each handler follows the format</p> <pre><code>on_{event_name}\n</code></pre> <p>For example, the handler triggered on MouseAction.LEFT_CLICK would be <code>on_left_click</code>. If no handler is found nothing is done.</p> <p>You can also define more general handlers, for example to group left &amp; right clicks you can use <code>on_click</code>, and to catch both up and down scroll you can use <code>on_scroll</code>. General handlers are only used if they are the most specific ones, i.e. there is no \"specific\" handler.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseEvent</code> <p>The event to handle.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the parent of this widget should treat it as one to \"stick\" events</p> <code>bool</code> <p>to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by</p> <code>bool</code> <p>returning False in the handler.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Tries to call the most specific mouse handler function available.\n\n    This function looks for a set of mouse action handlers. Each handler follows\n    the format\n\n        on_{event_name}\n\n    For example, the handler triggered on MouseAction.LEFT_CLICK would be\n    `on_left_click`. If no handler is found nothing is done.\n\n    You can also define more general handlers, for example to group left &amp; right\n    clicks you can use `on_click`, and to catch both up and down scroll you can use\n    `on_scroll`. General handlers are only used if they are the most specific ones,\n    i.e. there is no \"specific\" handler.\n\n    Args:\n        event: The event to handle.\n\n    Returns:\n        Whether the parent of this widget should treat it as one to \"stick\" events\n        to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by\n        returning False in the handler.\n    \"\"\"\n\n    def _get_names(action: MouseAction) -&gt; tuple[str, ...]:\n        if action.value in [\"hover\", \"release\"]:\n            return (action.value,)\n\n        parts = action.value.split(\"_\")\n\n        # left click &amp; right click\n        if parts[0] in [\"left\", \"right\"]:\n            return (action.value, parts[1])\n\n        if parts[0] == \"shift\":\n            return (action.value, f\"shift_{parts[1]}\", parts[1])\n\n        # scroll up &amp; down\n        return (action.value, parts[0])\n\n    possible_names = _get_names(event.action)\n    for name in possible_names:\n        if hasattr(self, f\"on_{name}\"):\n            handle = getattr(self, f\"on_{name}\")\n\n            return handle(event)\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.move","title":"<code>move(diff_x, diff_y)</code>","text":"<p>Moves the widget by the given x and y changes.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def move(self, diff_x: int, diff_y: int) -&gt; None:\n\"\"\"Moves the widget by the given x and y changes.\"\"\"\n\n    self.pos = (self.pos[0] + diff_x, self.pos[1] + diff_y)\n\n    adjusted = []\n    for pos, line in self.positioned_line_buffer:\n        adjusted.append(((pos[0] + diff_x, pos[1] + diff_y), line))\n\n    self.positioned_line_buffer = adjusted\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.print","title":"<code>print()</code>","text":"<p>Prints this widget</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def print(self) -&gt; None:\n\"\"\"Prints this widget\"\"\"\n\n    for line in self.get_lines():\n        print(line)\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.select","title":"<code>select(index=None)</code>","text":"<p>Selects a part of this Widget.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | None</code> <p>The index to select.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>This widget has no selectables, i.e. widget.is_selectable == False.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def select(self, index: int | None = None) -&gt; None:\n\"\"\"Selects a part of this Widget.\n\n    Args:\n        index: The index to select.\n\n    Raises:\n        TypeError: This widget has no selectables, i.e. widget.is_selectable == False.\n    \"\"\"\n\n    if not self.is_selectable:\n        raise TypeError(f\"Object of type {type(self)} has no selectables.\")\n\n    if index is not None:\n        index = min(max(0, index), self.selectables_length - 1)\n    self.selected_index = index\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.serialize","title":"<code>serialize()</code>","text":"<p>Serializes a widget.</p> <p>The fields looked at are defined <code>Widget.serialized</code>. Note that this method is not very commonly used at the moment, so it might not have full functionality in non-nuclear widgets.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of widget attributes. The dictionary will always</p> <code>dict[str, Any]</code> <p>have a <code>type</code> field. Any styles are converted into markup</p> <code>dict[str, Any]</code> <p>strings during serialization, so they can be loaded again in</p> <code>dict[str, Any]</code> <p>their original form.</p> <code>dict[str, Any]</code> <p>Example return:</p> <code>dict[str, Any]</code> <p>``` {     \"type\": \"Label\",     \"value\": \"[210 bold]I am a title\",     \"parent_align\": 0,     ... }</p> <code>dict[str, Any]</code> <p>```</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serializes a widget.\n\n    The fields looked at are defined `Widget.serialized`. Note that\n    this method is not very commonly used at the moment, so it might\n    not have full functionality in non-nuclear widgets.\n\n    Returns:\n        Dictionary of widget attributes. The dictionary will always\n        have a `type` field. Any styles are converted into markup\n        strings during serialization, so they can be loaded again in\n        their original form.\n\n        Example return:\n        ```\n            {\n                \"type\": \"Label\",\n                \"value\": \"[210 bold]I am a title\",\n                \"parent_align\": 0,\n                ...\n            }\n        ```\n    \"\"\"\n\n    fields = self._serialized_fields\n\n    out: dict[str, Any] = {\"type\": type(self).__name__}\n    for key in fields:\n        # Detect styled values\n        if key.startswith(\"*\"):\n            style = True\n            key = key[1:]\n        else:\n            style = False\n\n        value = getattr(self, key)\n\n        # Convert styled value into markup\n        if style:\n            style_call = self._get_style(key)\n            if isinstance(value, list):\n                out[key] = [get_markup(style_call(char)) for char in value]\n            else:\n                out[key] = get_markup(style_call(value))\n\n            continue\n\n        out[key] = value\n\n    # The chars need to be handled separately\n    out[\"chars\"] = {}\n    for key, value in self.chars.items():\n        style_call = self._get_style(key)\n\n        if isinstance(value, list):\n            out[\"chars\"][key] = [get_markup(style_call(char)) for char in value]\n        else:\n            out[\"chars\"][key] = get_markup(style_call(value))\n\n    return out\n</code></pre>"},{"location":"reference/pytermgui/widgets/base/#pytermgui.widgets.base.Widget.unbind","title":"<code>unbind(key)</code>","text":"<p>Unbinds the given key.</p> Source code in <code>pytermgui/widgets/base.py</code> <pre><code>def unbind(self, key: str) -&gt; None:\n\"\"\"Unbinds the given key.\"\"\"\n\n    del self._bindings[key]\n</code></pre>"},{"location":"reference/pytermgui/widgets/boxes/","title":"boxes","text":"<p>Convenience objects for Container corner &amp; border styles.</p> <p>They can be used as: <pre><code>from pytermgui import Container, boxes\n\nboxes.DOUBLE_TOP.set_chars_of(Container)\nc = Container() # this will now use the style chosen\n</code></pre></p> <p>Boxes are also settable as a property of <code>pytermgui.widgets.Container</code>, and can be referenced &amp; defined in markup file definitions. For more info, check out <code>pytermgui.file_loaders</code>.</p>"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box","title":"<code>Box</code>","text":"<p>Class for defining border &amp; corner styles</p> <p><code>lines</code> should be <code>list[str]</code> of length 3, such as:</p> <pre><code>lines = [\n    \".---.\",\n    \"| x |\",\n    \"`---`\",\n]\n</code></pre> <p>The length of individual lines is arbitrary, only limitation is that the top &amp; bottom border characters should occur most often in their respective lines.</p> <p>You can set corners to be of any length, their end is calculated by finding the index of the most often occuring character, which is assumed to be the border character.</p> <p>Top &amp; bottom borders are currently limited in length to 1, but sides operate similarly to corners. They are separated by finding the index of the fill char from the start or end. The content char is \"x\" by default, however it can be set to anything else by giving the \"content_char\" construction parameter.</p> <p>As such, this:</p> <pre><code>boxes.Box(\n   [\n       \"corner1 ________________ corner2\",\n       \"xleft   ################ rightxx\",\n       \"corner3 ---------------- corner4\",\n   ],\n   content_char=\"#\",\n)\n</code></pre> <p>Will result in:</p> <pre><code>Box(\n    borders=['xleft   ', '_', ' rightxx', '-'],\n    corners=['corner1 ', ' corner2', ' corner4', 'corner3 ']\n)\n</code></pre> Source code in <code>pytermgui/widgets/boxes.py</code> <pre><code>class Box:\n\"\"\"Class for defining border &amp; corner styles\n\n    `lines` should be `list[str]` of length 3, such as:\n\n    ```python3\n    lines = [\n        \".---.\",\n        \"| x |\",\n        \"`---`\",\n    ]\n    ```\n\n    The length of individual lines is arbitrary, only limitation is\n    that the top &amp; bottom border characters should occur most often in\n    their respective lines.\n\n    You can set corners to be of any length, their end is calculated by\n    finding the index of the most often occuring character, which is assumed\n    to be the border character.\n\n    Top &amp; bottom borders are currently limited in length to 1, but sides\n    operate similarly to corners. They are separated by finding the index\n    of the fill char from the start or end. The content char is \"x\" by\n    default, however it can be set to anything else by giving the \"content_char\"\n    construction parameter.\n\n    As such, this:\n\n    ```python3\n    boxes.Box(\n       [\n           \"corner1 ________________ corner2\",\n           \"xleft   ################ rightxx\",\n           \"corner3 ---------------- corner4\",\n       ],\n       content_char=\"#\",\n    )\n    ```\n\n    Will result in:\n\n    ```python3\n    Box(\n        borders=['xleft   ', '_', ' rightxx', '-'],\n        corners=['corner1 ', ' corner2', ' corner4', 'corner3 ']\n    )\n    ```\n    \"\"\"\n\n    CharType = Tuple[str, str, str, str]\n\n    def __init__(self, lines: list[str], content_char: str = \"x\"):\n\"\"\"Set instance attributes\"\"\"\n\n        super().__init__()\n        self.content_char = content_char\n\n        top, _, bottom = lines\n        top_left, top_right = self._get_corners(top)\n        bottom_left, bottom_right = self._get_corners(bottom)\n\n        self.borders = list(self._get_borders(lines))\n        self.corners = [\n            top_left,\n            top_right,\n            bottom_right,\n            bottom_left,\n        ]\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return string of self\"\"\"\n\n        return self.debug()\n\n    @staticmethod\n    def _find_mode_char(line: str) -&gt; str:\n\"\"\"Find most often consecutively occuring character in string\"\"\"\n\n        instances = 0\n        current_char = \"\"\n\n        results: list[tuple[str, int]] = []\n        for char in line:\n            if current_char == char:\n                instances += 1\n            else:\n                if len(current_char) &gt; 0:\n                    results.append((current_char, instances))\n\n                instances = 1\n                current_char = char\n\n        results.append((current_char, instances))\n\n        results.sort(key=lambda item: item[1])\n        if len(results) == 0:\n            print(line, instances, current_char)\n\n        return results[-1][0]\n\n    def _get_corners(self, line: str) -&gt; tuple[str, str]:\n\"\"\"Get corners from a line\"\"\"\n\n        mode_char = self._find_mode_char(line)\n        left = line[: line.index(mode_char)]\n        right = line[real_length(line) - (line[::-1].index(mode_char)) :]\n\n        return left, right\n\n    def _get_borders(self, lines: list[str]) -&gt; tuple[str, str, str, str]:\n\"\"\"Get borders from all lines\"\"\"\n\n        top, middle, bottom = lines\n        middle_reversed = middle[::-1]\n\n        top_border = self._find_mode_char(top)\n        left_border = middle[: middle.index(self.content_char)]\n\n        right_border = middle[\n            real_length(middle) - middle_reversed.index(self.content_char) :\n        ]\n        bottom_border = self._find_mode_char(bottom)\n\n        # return top_border, left_border, right_border, bottom_border\n        return left_border, top_border, right_border, bottom_border\n\n    def set_chars_of(self, cls_or_obj: WidgetType) -&gt; WidgetType:\n\"\"\"Set border &amp; corner chars of cls_or_obj to self values\"\"\"\n\n        # We cannot import any widgets into here due to cyclic imports,\n        # so we have to \"hack\" around it.\n        if not hasattr(cls_or_obj, \"set_char\"):\n            raise NotImplementedError(\n                f\"Object of type {cls_or_obj} does not support `set_char`\"\n            )\n\n        cls_or_obj.set_char(\"border\", self.borders)\n        cls_or_obj.set_char(\"corner\", self.corners)\n\n        return cls_or_obj\n\n    def debug(self) -&gt; str:\n\"\"\"Return identifiable information about object\"\"\"\n\n        return f\"Box(borders={self.borders}, corners={self.corners})\"\n</code></pre>"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box.__init__","title":"<code>__init__(lines, content_char='x')</code>","text":"<p>Set instance attributes</p> Source code in <code>pytermgui/widgets/boxes.py</code> <pre><code>def __init__(self, lines: list[str], content_char: str = \"x\"):\n\"\"\"Set instance attributes\"\"\"\n\n    super().__init__()\n    self.content_char = content_char\n\n    top, _, bottom = lines\n    top_left, top_right = self._get_corners(top)\n    bottom_left, bottom_right = self._get_corners(bottom)\n\n    self.borders = list(self._get_borders(lines))\n    self.corners = [\n        top_left,\n        top_right,\n        bottom_right,\n        bottom_left,\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box.__repr__","title":"<code>__repr__()</code>","text":"<p>Return string of self</p> Source code in <code>pytermgui/widgets/boxes.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return string of self\"\"\"\n\n    return self.debug()\n</code></pre>"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box.debug","title":"<code>debug()</code>","text":"<p>Return identifiable information about object</p> Source code in <code>pytermgui/widgets/boxes.py</code> <pre><code>def debug(self) -&gt; str:\n\"\"\"Return identifiable information about object\"\"\"\n\n    return f\"Box(borders={self.borders}, corners={self.corners})\"\n</code></pre>"},{"location":"reference/pytermgui/widgets/boxes/#pytermgui.widgets.boxes.Box.set_chars_of","title":"<code>set_chars_of(cls_or_obj)</code>","text":"<p>Set border &amp; corner chars of cls_or_obj to self values</p> Source code in <code>pytermgui/widgets/boxes.py</code> <pre><code>def set_chars_of(self, cls_or_obj: WidgetType) -&gt; WidgetType:\n\"\"\"Set border &amp; corner chars of cls_or_obj to self values\"\"\"\n\n    # We cannot import any widgets into here due to cyclic imports,\n    # so we have to \"hack\" around it.\n    if not hasattr(cls_or_obj, \"set_char\"):\n        raise NotImplementedError(\n            f\"Object of type {cls_or_obj} does not support `set_char`\"\n        )\n\n    cls_or_obj.set_char(\"border\", self.borders)\n    cls_or_obj.set_char(\"corner\", self.corners)\n\n    return cls_or_obj\n</code></pre>"},{"location":"reference/pytermgui/widgets/button/","title":"button","text":"<p>This module contains the <code>Button</code> class.</p>"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button","title":"<code>Button</code>","text":"<p>             Bases: <code>Widget</code></p> <p>A simple Widget representing a mouse-clickable button</p> Source code in <code>pytermgui/widgets/button.py</code> <pre><code>class Button(Widget):\n\"\"\"A simple Widget representing a mouse-clickable button\"\"\"\n\n    styles = w_styles.StyleManager(\n        label=\"@surface dim #auto\",\n        highlight=\"@surface+1 dim #auto\",\n        _current=None,\n    )\n\n    chars: dict[str, w_styles.CharType] = {\"delimiter\": [\"  \", \"  \"]}\n\n    def __init__(\n        self,\n        label: str = \"Button\",\n        onclick: Optional[Callable[[Button], Any]] = None,\n        padding: int = 0,\n        centered: bool = False,\n        **attrs: Any,\n    ) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n        super().__init__(**attrs)\n        self._selectables_length = 1\n\n        if not any(\"width\" in attr for attr in attrs):\n            self.width = len(label)\n\n        self.label = label\n        self.onclick = onclick\n        self.padding = padding\n        self.centered = centered\n\n        self.styles[\"_current\"] = self.styles.label\n\n    def on_hover(self, _) -&gt; bool:\n\"\"\"Sets highlight style when hovering.\"\"\"\n\n        self.styles[\"_current\"] = self.styles.highlight\n        return False\n\n    def on_release(self, _) -&gt; bool:\n\"\"\"Sets normal style when no longer hovering.\"\"\"\n\n        self.styles[\"_current\"] = self.styles.label\n        return False\n\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Handles a mouse event\"\"\"\n\n        if super().handle_mouse(event):\n            return True\n\n        if event.action == MouseAction.LEFT_CLICK:\n            self.selected_index = 0\n            if self.onclick is not None:\n                self.onclick(self)\n\n            return True\n\n        if event.action == MouseAction.RELEASE:\n            self.selected_index = None\n            return True\n\n        return False\n\n    def handle_key(self, key: str) -&gt; bool:\n\"\"\"Handles a keypress\"\"\"\n\n        if key == keys.RETURN and self.onclick is not None:\n            self.onclick(self)\n            return True\n\n        return False\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Get object lines\"\"\"\n\n        delimiters = self._get_char(\"delimiter\")\n        assert isinstance(delimiters, list) and len(delimiters) == 2\n\n        left, right = delimiters\n        left = left.replace(\"[\", r\"\\[\")\n\n        if self.selected_index is None:\n            style = self.styles[\"_current\"]\n        else:\n            style = self.styles.highlight\n\n        line = style(left + self.label + right + self.padding * \" \")\n\n        return [line]\n</code></pre>"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.__init__","title":"<code>__init__(label='Button', onclick=None, padding=0, centered=False, **attrs)</code>","text":"<p>Initialize object</p> Source code in <code>pytermgui/widgets/button.py</code> <pre><code>def __init__(\n    self,\n    label: str = \"Button\",\n    onclick: Optional[Callable[[Button], Any]] = None,\n    padding: int = 0,\n    centered: bool = False,\n    **attrs: Any,\n) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n    super().__init__(**attrs)\n    self._selectables_length = 1\n\n    if not any(\"width\" in attr for attr in attrs):\n        self.width = len(label)\n\n    self.label = label\n    self.onclick = onclick\n    self.padding = padding\n    self.centered = centered\n\n    self.styles[\"_current\"] = self.styles.label\n</code></pre>"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.get_lines","title":"<code>get_lines()</code>","text":"<p>Get object lines</p> Source code in <code>pytermgui/widgets/button.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Get object lines\"\"\"\n\n    delimiters = self._get_char(\"delimiter\")\n    assert isinstance(delimiters, list) and len(delimiters) == 2\n\n    left, right = delimiters\n    left = left.replace(\"[\", r\"\\[\")\n\n    if self.selected_index is None:\n        style = self.styles[\"_current\"]\n    else:\n        style = self.styles.highlight\n\n    line = style(left + self.label + right + self.padding * \" \")\n\n    return [line]\n</code></pre>"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.handle_key","title":"<code>handle_key(key)</code>","text":"<p>Handles a keypress</p> Source code in <code>pytermgui/widgets/button.py</code> <pre><code>def handle_key(self, key: str) -&gt; bool:\n\"\"\"Handles a keypress\"\"\"\n\n    if key == keys.RETURN and self.onclick is not None:\n        self.onclick(self)\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.handle_mouse","title":"<code>handle_mouse(event)</code>","text":"<p>Handles a mouse event</p> Source code in <code>pytermgui/widgets/button.py</code> <pre><code>def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Handles a mouse event\"\"\"\n\n    if super().handle_mouse(event):\n        return True\n\n    if event.action == MouseAction.LEFT_CLICK:\n        self.selected_index = 0\n        if self.onclick is not None:\n            self.onclick(self)\n\n        return True\n\n    if event.action == MouseAction.RELEASE:\n        self.selected_index = None\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.on_hover","title":"<code>on_hover(_)</code>","text":"<p>Sets highlight style when hovering.</p> Source code in <code>pytermgui/widgets/button.py</code> <pre><code>def on_hover(self, _) -&gt; bool:\n\"\"\"Sets highlight style when hovering.\"\"\"\n\n    self.styles[\"_current\"] = self.styles.highlight\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/button/#pytermgui.widgets.button.Button.on_release","title":"<code>on_release(_)</code>","text":"<p>Sets normal style when no longer hovering.</p> Source code in <code>pytermgui/widgets/button.py</code> <pre><code>def on_release(self, _) -&gt; bool:\n\"\"\"Sets normal style when no longer hovering.\"\"\"\n\n    self.styles[\"_current\"] = self.styles.label\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/checkbox/","title":"checkbox","text":"<p>This module contains the <code>Checkbox</code> class.</p>"},{"location":"reference/pytermgui/widgets/checkbox/#pytermgui.widgets.checkbox.Checkbox","title":"<code>Checkbox</code>","text":"<p>             Bases: <code>Button</code></p> <p>A simple checkbox</p> Source code in <code>pytermgui/widgets/checkbox.py</code> <pre><code>class Checkbox(Button):\n\"\"\"A simple checkbox\"\"\"\n\n    chars = {\n        **Button.chars,\n        **{\"delimiter\": [\" \", \" \"], \"checked\": \"\u25a3\", \"unchecked\": \"\u25a1\"},\n    }\n\n    def __init__(\n        self,\n        callback: Callable[[Any], Any] | None = None,\n        checked: bool = False,\n        **attrs: Any,\n    ) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n        unchecked = self._get_char(\"unchecked\")\n        assert isinstance(unchecked, str)\n\n        super().__init__(unchecked, onclick=self.toggle, **attrs)\n\n        self.callback = None\n        self.checked = False\n        if self.checked != checked:\n            self.toggle(run_callback=False)\n\n        self.callback = callback\n\n    def _run_callback(self) -&gt; None:\n\"\"\"Run the checkbox callback with the new checked flag as its argument\"\"\"\n\n        if self.callback is not None:\n            self.callback(self.checked)\n\n    def toggle(self, *_: Any, run_callback: bool = True) -&gt; None:\n\"\"\"Toggle state\"\"\"\n\n        chars = self._get_char(\"checked\"), self._get_char(\"unchecked\")\n        assert isinstance(chars[0], str) and isinstance(chars[1], str)\n\n        self.checked ^= True\n        if self.checked:\n            self.label = chars[0]\n        else:\n            self.label = chars[1]\n\n        self.get_lines()\n\n        if run_callback:\n            self._run_callback()\n</code></pre>"},{"location":"reference/pytermgui/widgets/checkbox/#pytermgui.widgets.checkbox.Checkbox.__init__","title":"<code>__init__(callback=None, checked=False, **attrs)</code>","text":"<p>Initialize object</p> Source code in <code>pytermgui/widgets/checkbox.py</code> <pre><code>def __init__(\n    self,\n    callback: Callable[[Any], Any] | None = None,\n    checked: bool = False,\n    **attrs: Any,\n) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n    unchecked = self._get_char(\"unchecked\")\n    assert isinstance(unchecked, str)\n\n    super().__init__(unchecked, onclick=self.toggle, **attrs)\n\n    self.callback = None\n    self.checked = False\n    if self.checked != checked:\n        self.toggle(run_callback=False)\n\n    self.callback = callback\n</code></pre>"},{"location":"reference/pytermgui/widgets/checkbox/#pytermgui.widgets.checkbox.Checkbox.toggle","title":"<code>toggle(*_, run_callback=True)</code>","text":"<p>Toggle state</p> Source code in <code>pytermgui/widgets/checkbox.py</code> <pre><code>def toggle(self, *_: Any, run_callback: bool = True) -&gt; None:\n\"\"\"Toggle state\"\"\"\n\n    chars = self._get_char(\"checked\"), self._get_char(\"unchecked\")\n    assert isinstance(chars[0], str) and isinstance(chars[1], str)\n\n    self.checked ^= True\n    if self.checked:\n        self.label = chars[0]\n    else:\n        self.label = chars[1]\n\n    self.get_lines()\n\n    if run_callback:\n        self._run_callback()\n</code></pre>"},{"location":"reference/pytermgui/widgets/collapsible/","title":"collapsible","text":"<p>The Collapsible widget type.</p>"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible","title":"<code>Collapsible</code>","text":"<p>             Bases: <code>Container</code></p> <p>A collapsible section of UI.</p> Source code in <code>pytermgui/widgets/collapsible.py</code> <pre><code>class Collapsible(Container):\n\"\"\"A collapsible section of UI.\"\"\"\n\n    def __init__(\n        self, label: str, *items: Any, keyboard: bool = False, **attrs: Any\n    ) -&gt; None:\n\"\"\"Initializes the widget.\n\n        Args:\n            label: The label for the trigger toggle.\n            *items: The items that will be hidden when the object is collapsed.\n            keyboard: If set, the first character of the label will be used as\n                a `CTRL_` binding to toggle the object.\n        \"\"\"\n\n        if keyboard:\n            bind = label[0]\n            self.trigger = Toggle(\n                (f\"\u25b6 ({bind}){label[1:]}\", f\"\u25bc ({bind}){label[1:]}\"),\n                lambda *_: self.toggle(),\n            )\n        else:\n            self.trigger = Toggle(\n                (f\"\u25b6 {label}\", f\"\u25bc {label}\"), lambda *_: self.toggle()\n            )\n\n        super().__init__(self.trigger, *items, box=\"EMPTY\", **attrs)\n\n        if keyboard:\n            self.bind(\n                getattr(keys, f\"CTRL_{bind}\"),\n                lambda *_: self.trigger.toggle(),\n                \"Open dropdown\",\n            )\n\n        self.collapsed_height = 1\n        self.overflow = Overflow.HIDE\n        self.height = self.collapsed_height\n\n        self._is_expanded = False\n\n    def toggle(self) -&gt; Collapsible:\n\"\"\"Toggles expanded state.\n\n        Returns:\n            This object.\n        \"\"\"\n\n        if self.trigger.checked != self._is_expanded:\n            self.trigger.toggle(run_callback=False)\n\n        self._is_expanded = not self._is_expanded\n\n        if self._is_expanded:\n            self.overflow = Overflow.RESIZE\n        else:\n            self.overflow = Overflow.HIDE\n            self.height = self.collapsed_height\n\n        return self\n\n    def collapse(self) -&gt; Collapsible:\n\"\"\"Collapses the dropdown.\n\n        Does nothing if already collapsed.\n\n        Returns:\n            This object.\n        \"\"\"\n\n        if self._is_expanded:\n            self.toggle()\n\n        return self\n\n    def expand(self) -&gt; Collapsible:\n\"\"\"Expands the dropdown.\n\n        Does nothing if already expanded.\n\n        Returns:\n            This object.\n        \"\"\"\n\n        if not self._is_expanded:\n            self.toggle()\n\n        return self\n</code></pre>"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible.__init__","title":"<code>__init__(label, *items, keyboard=False, **attrs)</code>","text":"<p>Initializes the widget.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label for the trigger toggle.</p> required <code>*items</code> <code>Any</code> <p>The items that will be hidden when the object is collapsed.</p> <code>()</code> <code>keyboard</code> <code>bool</code> <p>If set, the first character of the label will be used as a <code>CTRL_</code> binding to toggle the object.</p> <code>False</code> Source code in <code>pytermgui/widgets/collapsible.py</code> <pre><code>def __init__(\n    self, label: str, *items: Any, keyboard: bool = False, **attrs: Any\n) -&gt; None:\n\"\"\"Initializes the widget.\n\n    Args:\n        label: The label for the trigger toggle.\n        *items: The items that will be hidden when the object is collapsed.\n        keyboard: If set, the first character of the label will be used as\n            a `CTRL_` binding to toggle the object.\n    \"\"\"\n\n    if keyboard:\n        bind = label[0]\n        self.trigger = Toggle(\n            (f\"\u25b6 ({bind}){label[1:]}\", f\"\u25bc ({bind}){label[1:]}\"),\n            lambda *_: self.toggle(),\n        )\n    else:\n        self.trigger = Toggle(\n            (f\"\u25b6 {label}\", f\"\u25bc {label}\"), lambda *_: self.toggle()\n        )\n\n    super().__init__(self.trigger, *items, box=\"EMPTY\", **attrs)\n\n    if keyboard:\n        self.bind(\n            getattr(keys, f\"CTRL_{bind}\"),\n            lambda *_: self.trigger.toggle(),\n            \"Open dropdown\",\n        )\n\n    self.collapsed_height = 1\n    self.overflow = Overflow.HIDE\n    self.height = self.collapsed_height\n\n    self._is_expanded = False\n</code></pre>"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible.collapse","title":"<code>collapse()</code>","text":"<p>Collapses the dropdown.</p> <p>Does nothing if already collapsed.</p> <p>Returns:</p> Type Description <code>Collapsible</code> <p>This object.</p> Source code in <code>pytermgui/widgets/collapsible.py</code> <pre><code>def collapse(self) -&gt; Collapsible:\n\"\"\"Collapses the dropdown.\n\n    Does nothing if already collapsed.\n\n    Returns:\n        This object.\n    \"\"\"\n\n    if self._is_expanded:\n        self.toggle()\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible.expand","title":"<code>expand()</code>","text":"<p>Expands the dropdown.</p> <p>Does nothing if already expanded.</p> <p>Returns:</p> Type Description <code>Collapsible</code> <p>This object.</p> Source code in <code>pytermgui/widgets/collapsible.py</code> <pre><code>def expand(self) -&gt; Collapsible:\n\"\"\"Expands the dropdown.\n\n    Does nothing if already expanded.\n\n    Returns:\n        This object.\n    \"\"\"\n\n    if not self._is_expanded:\n        self.toggle()\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/widgets/collapsible/#pytermgui.widgets.collapsible.Collapsible.toggle","title":"<code>toggle()</code>","text":"<p>Toggles expanded state.</p> <p>Returns:</p> Type Description <code>Collapsible</code> <p>This object.</p> Source code in <code>pytermgui/widgets/collapsible.py</code> <pre><code>def toggle(self) -&gt; Collapsible:\n\"\"\"Toggles expanded state.\n\n    Returns:\n        This object.\n    \"\"\"\n\n    if self.trigger.checked != self._is_expanded:\n        self.trigger.toggle(run_callback=False)\n\n    self._is_expanded = not self._is_expanded\n\n    if self._is_expanded:\n        self.overflow = Overflow.RESIZE\n    else:\n        self.overflow = Overflow.HIDE\n        self.height = self.collapsed_height\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/widgets/color_picker/","title":"color_picker","text":"<p>The module containing the ColorPicker widget, as well as some helpers it needs.</p> <p>To test out the widget, run <code>ptg --color</code>!</p>"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker","title":"<code>ColorPicker</code>","text":"<p>             Bases: <code>Container</code></p> <p>A simple ColorPicker widget.</p> <p>This is used to visualize xterm-255 colors. RGB colors are not included here, as it is probably easier to use a web-based picker for those anyways.</p> Source code in <code>pytermgui/widgets/color_picker.py</code> <pre><code>class ColorPicker(Container):\n\"\"\"A simple ColorPicker widget.\n\n    This is used to visualize xterm-255 colors. RGB colors are not\n    included here, as it is probably easier to use a web-based picker\n    for those anyways.\n    \"\"\"\n\n    size_policy = SizePolicy.STATIC\n\n    def __init__(self, show_output: bool = True, **attrs: Any) -&gt; None:\n\"\"\"Initializes a ColorPicker.\n\n        Attrs:\n            show_output: Decides whether the output Container should be\n                added. If not set, the widget will only display the\n                PixelMatrix of colors.\n        \"\"\"\n\n        super().__init__(**attrs)\n        self.show_output = show_output\n\n        self._matrix = PixelMatrix.from_matrix(_get_xterm_matrix())\n\n        self.width = 72\n        self.box = boxes.EMPTY\n\n        self._add_widget(self._matrix, run_get_lines=False)\n\n        self.chosen = Joiner()\n        self._output = Container(self.chosen, \"\", \"\", \"\")\n\n        if self.show_output:\n            self._add_widget(self._output)\n\n    @property\n    def selectables_length(self) -&gt; int:\n\"\"\"Returns either the button count or 1.\"\"\"\n\n        return max(super().selectables_length, 1)\n\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Handles mouse events.\n\n        On hover, the widget will display the currently hovered\n        color and some testing text.\n\n        On click, it will add a _FadeInButton for the currently\n        hovered color.\n\n        Args:\n            event: The event to handle.\n        \"\"\"\n\n        if super().handle_mouse(event):\n            return True\n\n        if not self.show_output or not self._matrix.contains(event.position):\n            return False\n\n        if event.action is MouseAction.LEFT_CLICK:\n            if self._matrix.selected_pixel is None:\n                return True\n\n            _, color = self._matrix.selected_pixel\n            if len(color) == 0:\n                return False\n\n            button = _FadeInButton(f\"{color:^5}\", width=5)\n            button.styles.label = f\"@{color}\"\n            self.chosen.lazy_add(button)\n\n            return True\n\n        return False\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Updates self._output and gets widget lines.\"\"\"\n\n        if self.show_output and self._matrix.selected_pixel is not None:\n            _, color = self._matrix.selected_pixel\n            if len(color) == 0:\n                return super().get_lines()\n\n            color_obj = str_to_color(color)\n            rgb = color_obj.rgb\n            hex_ = color_obj.hex\n            lines: list[Widget] = [\n                Label(f\"[@{color} #auto] {color} [/ {color}] {color}\"),\n                Label(\n                    f\"[{color} bold]Here[/bold italic] is \"\n                    + \"[/italic underline]some[/underline dim] example[/dim] text\"\n                ),\n                Label(),\n                Label(\n                    f\"RGB: [{';'.join(map(str, rgb))}]\"\n                    + f\"rgb({rgb[0]:&gt;3}, {rgb[1]:&gt;3}, {rgb[2]:&gt;3})\"\n                ),\n                Label(f\"HEX: [{hex_}]{hex_}\"),\n            ]\n            self._output.set_widgets(lines + [Label(), self.chosen])\n\n            return super().get_lines()\n\n        return super().get_lines()\n</code></pre>"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker.selectables_length","title":"<code>selectables_length: int</code>  <code>property</code>","text":"<p>Returns either the button count or 1.</p>"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker.__init__","title":"<code>__init__(show_output=True, **attrs)</code>","text":"<p>Initializes a ColorPicker.</p> Attrs <p>show_output: Decides whether the output Container should be     added. If not set, the widget will only display the     PixelMatrix of colors.</p> Source code in <code>pytermgui/widgets/color_picker.py</code> <pre><code>def __init__(self, show_output: bool = True, **attrs: Any) -&gt; None:\n\"\"\"Initializes a ColorPicker.\n\n    Attrs:\n        show_output: Decides whether the output Container should be\n            added. If not set, the widget will only display the\n            PixelMatrix of colors.\n    \"\"\"\n\n    super().__init__(**attrs)\n    self.show_output = show_output\n\n    self._matrix = PixelMatrix.from_matrix(_get_xterm_matrix())\n\n    self.width = 72\n    self.box = boxes.EMPTY\n\n    self._add_widget(self._matrix, run_get_lines=False)\n\n    self.chosen = Joiner()\n    self._output = Container(self.chosen, \"\", \"\", \"\")\n\n    if self.show_output:\n        self._add_widget(self._output)\n</code></pre>"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker.get_lines","title":"<code>get_lines()</code>","text":"<p>Updates self._output and gets widget lines.</p> Source code in <code>pytermgui/widgets/color_picker.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Updates self._output and gets widget lines.\"\"\"\n\n    if self.show_output and self._matrix.selected_pixel is not None:\n        _, color = self._matrix.selected_pixel\n        if len(color) == 0:\n            return super().get_lines()\n\n        color_obj = str_to_color(color)\n        rgb = color_obj.rgb\n        hex_ = color_obj.hex\n        lines: list[Widget] = [\n            Label(f\"[@{color} #auto] {color} [/ {color}] {color}\"),\n            Label(\n                f\"[{color} bold]Here[/bold italic] is \"\n                + \"[/italic underline]some[/underline dim] example[/dim] text\"\n            ),\n            Label(),\n            Label(\n                f\"RGB: [{';'.join(map(str, rgb))}]\"\n                + f\"rgb({rgb[0]:&gt;3}, {rgb[1]:&gt;3}, {rgb[2]:&gt;3})\"\n            ),\n            Label(f\"HEX: [{hex_}]{hex_}\"),\n        ]\n        self._output.set_widgets(lines + [Label(), self.chosen])\n\n        return super().get_lines()\n\n    return super().get_lines()\n</code></pre>"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.ColorPicker.handle_mouse","title":"<code>handle_mouse(event)</code>","text":"<p>Handles mouse events.</p> <p>On hover, the widget will display the currently hovered color and some testing text.</p> <p>On click, it will add a _FadeInButton for the currently hovered color.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseEvent</code> <p>The event to handle.</p> required Source code in <code>pytermgui/widgets/color_picker.py</code> <pre><code>def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Handles mouse events.\n\n    On hover, the widget will display the currently hovered\n    color and some testing text.\n\n    On click, it will add a _FadeInButton for the currently\n    hovered color.\n\n    Args:\n        event: The event to handle.\n    \"\"\"\n\n    if super().handle_mouse(event):\n        return True\n\n    if not self.show_output or not self._matrix.contains(event.position):\n        return False\n\n    if event.action is MouseAction.LEFT_CLICK:\n        if self._matrix.selected_pixel is None:\n            return True\n\n        _, color = self._matrix.selected_pixel\n        if len(color) == 0:\n            return False\n\n        button = _FadeInButton(f\"{color:^5}\", width=5)\n        button.styles.label = f\"@{color}\"\n        self.chosen.lazy_add(button)\n\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.Joiner","title":"<code>Joiner</code>","text":"<p>             Bases: <code>Container</code></p> <p>A Container that stacks widgets horizontally, without filling up the available space.</p> <p>This works slightly differently to Splitter, as that applies padding &amp; custom widths to any Widget it finds. This works much more simply, and only joins their lines together as they come.</p> Source code in <code>pytermgui/widgets/color_picker.py</code> <pre><code>class Joiner(Container):\n\"\"\"A Container that stacks widgets horizontally, without filling up the available space.\n\n    This works slightly differently to Splitter, as that applies padding &amp; custom widths to\n    any Widget it finds. This works much more simply, and only joins their lines together as\n    they come.\n    \"\"\"\n\n    parent_align = HorizontalAlignment.LEFT\n\n    chars = {\"separator\": \" \"}\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Does magic\"\"\"\n\n        lines: list[str] = []\n        separator = self._get_char(\"separator\")\n        assert isinstance(separator, str)\n\n        line = \"\"\n        for widget in self._widgets:\n            if len(line) &gt; 0:\n                line += separator\n\n            widget.pos = (self.pos[0] + real_length(line), self.pos[1] + len(lines))\n            widget_line = widget.get_lines()[0]\n\n            if real_length(line + widget_line) &gt;= self.width:\n                lines.append(line)\n                widget.pos = self.pos[0], self.pos[1] + len(lines)\n                line = widget_line\n                continue\n\n            line += widget_line\n\n        lines.append(line)\n        self.height = len(lines)\n        return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/color_picker/#pytermgui.widgets.color_picker.Joiner.get_lines","title":"<code>get_lines()</code>","text":"<p>Does magic</p> Source code in <code>pytermgui/widgets/color_picker.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Does magic\"\"\"\n\n    lines: list[str] = []\n    separator = self._get_char(\"separator\")\n    assert isinstance(separator, str)\n\n    line = \"\"\n    for widget in self._widgets:\n        if len(line) &gt; 0:\n            line += separator\n\n        widget.pos = (self.pos[0] + real_length(line), self.pos[1] + len(lines))\n        widget_line = widget.get_lines()[0]\n\n        if real_length(line + widget_line) &gt;= self.width:\n            lines.append(line)\n            widget.pos = self.pos[0], self.pos[1] + len(lines)\n            line = widget_line\n            continue\n\n        line += widget_line\n\n    lines.append(line)\n    self.height = len(lines)\n    return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/","title":"containers","text":"<p>The module containing all of the layout-related widgets.</p>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container","title":"<code>Container</code>","text":"<p>             Bases: <code>ScrollableWidget</code></p> <p>A widget that displays other widgets, stacked vertically.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>class Container(ScrollableWidget):\n\"\"\"A widget that displays other widgets, stacked vertically.\"\"\"\n\n    styles = w_styles.StyleManager(\n        border=\"surface\",\n        corner=\"surface\",\n        fill=\"background\",\n    )\n\n    chars: dict[str, w_styles.CharType] = {\n        \"border\": [\"| \", \"-\", \" |\", \"-\"],\n        \"corner\": [\"\"] * 4,\n    }\n\n    keys = {\n        \"next\": {keys.DOWN, keys.CTRL_N, \"j\"},\n        \"previous\": {keys.UP, keys.CTRL_P, \"k\"},\n        \"scroll_down\": {keys.SHIFT_DOWN, \"J\"},\n        \"scroll_up\": {keys.SHIFT_UP, \"K\"},\n    }\n\n    serialized = Widget.serialized + [\"centered_axis\"]\n    vertical_align = VerticalAlignment.CENTER\n    allow_fullscreen = True\n\n    overflow = Overflow.get_default()\n\n    # TODO: Add `WidgetConvertible`? type instead of Any\n    def __init__(self, *widgets: Any, **attrs: Any) -&gt; None:\n\"\"\"Initialize Container data\"\"\"\n\n        super().__init__(**attrs)\n\n        # TODO: This is just a band-aid.\n        if not any(\"width\" in attr for attr in attrs):\n            self.width = 40\n\n        self._widgets: list[Widget] = []\n        self.dirty_widgets: list[Widget] = []\n        self.centered_axis: CenteringPolicy | None = None\n\n        self._prev_screen: tuple[int, int] = (0, 0)\n        self._has_printed = False\n\n        for widget in widgets:\n            self._add_widget(widget)\n\n        if \"box\" not in attrs:\n            attrs[\"box\"] = \"SINGLE\"\n\n        try:\n            self.box = attrs[\"box\"]\n        # Splitter doesn't use boxes ATM.\n        except KeyError:\n            pass\n\n        self._mouse_target: Widget | None = None\n\n    @property\n    def sidelength(self) -&gt; int:\n\"\"\"Gets the length of left and right borders combined.\n\n        Returns:\n            An integer equal to the `pytermgui.helpers.real_length` of the concatenation of\n                the left and right borders of this widget, both with their respective styles\n                applied.\n        \"\"\"\n\n        return self.width - self.content_dimensions[0]\n\n    @property\n    def content_dimensions(self) -&gt; tuple[int, int]:\n\"\"\"Gets the size (width, height) of the available content area.\"\"\"\n\n        if \"border\" not in self.chars:\n            return self.width, self.height\n\n        chars = self._get_char(\"border\")\n\n        assert isinstance(chars, list)\n\n        left, top, right, bottom = chars\n\n        return (\n            self.width - real_length(self.styles.border(left + right)),\n            self.height - sum(1 if real_length(char) else 0 for char in [top, bottom]),\n        )\n\n    @property\n    def selectables(self) -&gt; list[tuple[Widget, int]]:\n\"\"\"Gets all selectable widgets and their inner indices.\n\n        This is used in order to have a constant reference to all selectable indices within this\n        widget.\n\n        Returns:\n            A list of tuples containing a widget and an integer each. For each widget that is\n            withing this one, it is added to this list as many times as it has selectables. Each\n            of the integers correspond to a selectable_index within the widget.\n\n            For example, a Container with a Button, InputField and an inner Container containing\n            3 selectables might return something like this:\n\n            ```\n            [\n                (Button(...), 0),\n                (InputField(...), 0),\n                (Container(...), 0),\n                (Container(...), 1),\n                (Container(...), 2),\n            ]\n            ```\n        \"\"\"\n\n        _selectables: list[tuple[Widget, int]] = []\n        for widget in self._widgets:\n            if not widget.is_selectable:\n                continue\n\n            for i, (inner, _) in enumerate(widget.selectables):\n                _selectables.append((inner, i))\n\n        return _selectables\n\n    @property\n    def selectables_length(self) -&gt; int:\n\"\"\"Gets the length of the selectables list.\n\n        Returns:\n            An integer equal to the length of `self.selectables`.\n        \"\"\"\n\n        return len(self.selectables)\n\n    @property\n    def selected(self) -&gt; Widget | None:\n\"\"\"Returns the currently selected object\n\n        Returns:\n            The currently selected widget if selected_index is not None,\n            otherwise None.\n        \"\"\"\n\n        # TODO: Add deeper selection\n\n        if self.selected_index is None:\n            return None\n\n        if self.selected_index &gt;= len(self.selectables):\n            return None\n\n        return self.selectables[self.selected_index][0]\n\n    @property\n    def box(self) -&gt; boxes.Box:\n\"\"\"Returns current box setting\n\n        Returns:\n            The currently set box instance.\n        \"\"\"\n\n        return self._box\n\n    @box.setter\n    def box(self, new: str | boxes.Box) -&gt; None:\n\"\"\"Applies a new box.\n\n        Args:\n            new: Either a `pytermgui.boxes.Box` instance or a string\n                analogous to one of the default box names.\n        \"\"\"\n\n        if isinstance(new, str):\n            from_module = vars(boxes).get(new)\n            if from_module is None:\n                raise ValueError(f\"Unknown box type {new}.\")\n\n            new = from_module\n\n        assert isinstance(new, boxes.Box)\n        self._box = new\n        new.set_chars_of(self)\n\n    def get_change(self) -&gt; WidgetChange | None:\n\"\"\"Determines whether widget lines changed since the last call to this function.\"\"\"\n\n        change = super().get_change()\n\n        if change is None:\n            return None\n\n        for widget in self._widgets:\n            if widget.get_change() is not None:\n                self.dirty_widgets.append(widget)\n\n        return change\n\n    def __iadd__(self, other: object) -&gt; Container:\n\"\"\"Adds a new widget, then returns self.\n\n        Args:\n            other: Any widget instance, or data structure that can be turned\n                into a widget by `Widget.from_data`.\n\n        Returns:\n            A reference to self.\n        \"\"\"\n\n        self._add_widget(other)\n        return self\n\n    def __add__(self, other: object) -&gt; Container:\n\"\"\"Adds a new widget, then returns self.\n\n        This method is analogous to `Container.__iadd__`.\n\n        Args:\n            other: Any widget instance, or data structure that can be turned\n                into a widget by `Widget.from_data`.\n\n        Returns:\n            A reference to self.\n        \"\"\"\n\n        self.__iadd__(other)\n        return self\n\n    def __iter__(self) -&gt; Iterator[Widget]:\n\"\"\"Gets an iterator of self._widgets.\n\n        Yields:\n            The next widget.\n        \"\"\"\n\n        for widget in self._widgets:\n            yield widget\n\n    def __len__(self) -&gt; int:\n\"\"\"Gets the length of the widgets list.\n\n        Returns:\n            An integer describing len(self._widgets).\n        \"\"\"\n\n        return len(self._widgets)\n\n    def __getitem__(self, sli: int | slice) -&gt; Widget | list[Widget]:\n\"\"\"Gets an item from self._widgets.\n\n        Args:\n            sli: Slice of the list.\n\n        Returns:\n            The slice in the list.\n        \"\"\"\n\n        return self._widgets[sli]\n\n    def __setitem__(self, index: int, value: Any) -&gt; None:\n\"\"\"Sets an item in self._widgets.\n\n        Args:\n            index: The index to be set.\n            value: The new widget at this index.\n        \"\"\"\n\n        self._widgets[index] = value\n\n    def __contains__(self, other: object) -&gt; bool:\n\"\"\"Determines if self._widgets contains other widget.\n\n        Args:\n            other: Any widget-like.\n\n        Returns:\n            A boolean describing whether `other` is in `self.widgets`\n        \"\"\"\n\n        if other in self._widgets:\n            return True\n\n        for widget in self._widgets:\n            if isinstance(widget, Container) and other in widget:\n                return True\n\n        return False\n\n    def _add_widget(self, other: object, run_get_lines: bool = True) -&gt; Widget:\n\"\"\"Adds other to this widget.\n\n        Args:\n            other: Any widget-like object.\n            run_get_lines: Boolean controlling whether the self.get_lines is ran.\n\n        Returns:\n            The added widget. This is useful when data conversion took place in this\n            function, e.g. a string was converted to a Label.\n        \"\"\"\n\n        if not isinstance(other, Widget):\n            to_widget = Widget.from_data(other)\n            if to_widget is None:\n                raise ValueError(\n                    f\"Could not convert {other} of type {type(other)} to a Widget!\"\n                )\n\n            other = to_widget\n\n        # This is safe to do, as it would've raised an exception above already\n        assert isinstance(other, Widget)\n\n        self._widgets.append(other)\n        if isinstance(other, Container):\n            other.set_recursive_depth(self.depth + 2)\n        else:\n            other.depth = self.depth + 1\n\n        other.get_lines()\n        other.parent = self\n\n        if run_get_lines:\n            self.get_lines()\n\n        return other\n\n    def _get_aligners(\n        self, widget: Widget, borders: tuple[str, str]\n    ) -&gt; tuple[Callable[[str], str], int]:\n\"\"\"Gets an aligning method and position offset.\n\n        Args:\n            widget: The widget to align.\n            borders: The left and right borders to put the widget within.\n\n        Returns:\n            A tuple of a method that, when called with a line, will return that line\n            centered using the passed in widget's parent_align and width, as well as\n            the horizontal offset resulting from the widget being aligned.\n        \"\"\"\n\n        left, right = self.styles.border(borders[0]), self.styles.border(borders[1])\n        char = \" \"\n\n        fill = self.styles.fill\n\n        def _align_left(text: str) -&gt; str:\n\"\"\"Align line to the left\"\"\"\n\n            padding = self.width - real_length(left + right) - real_length(text)\n            return left + text + fill(padding * char) + right\n\n        def _align_center(text: str) -&gt; str:\n\"\"\"Align line to the center\"\"\"\n\n            total = self.width - real_length(left + right) - real_length(text)\n            padding, offset = divmod(total, 2)\n            return (\n                left\n                + fill((padding + offset) * char)\n                + text\n                + fill(padding * char)\n                + right\n            )\n\n        def _align_right(text: str) -&gt; str:\n\"\"\"Align line to the right\"\"\"\n\n            padding = self.width - real_length(left + right) - real_length(text)\n            return left + fill(padding * char) + text + right\n\n        if widget.parent_align == HorizontalAlignment.CENTER:\n            total = self.width - real_length(left + right) - widget.width\n            padding, offset = divmod(total, 2)\n            return _align_center, real_length(left) + padding + offset\n\n        if widget.parent_align == HorizontalAlignment.RIGHT:\n            return _align_right, self.width - real_length(left) - widget.width\n\n        # Default to left-aligned\n        return _align_left, real_length(left)\n\n    def _update_width(self, widget: Widget) -&gt; None:\n\"\"\"Updates the width of widget or self.\n\n        This method respects widget.size_policy.\n\n        Args:\n            widget: The widget to update/base updates on.\n\n        Raises:\n            ValueError: Widget has SizePolicy.RELATIVE, but relative_width is None.\n            WidthExceededError: Widget and self both have static widths, and widget's\n                is larger than what is available.\n        \"\"\"\n\n        available = self.width - self.sidelength\n\n        if widget.size_policy == SizePolicy.FILL:\n            widget.width = available\n            return\n\n        if widget.size_policy == SizePolicy.RELATIVE:\n            if widget.relative_width is None:\n                raise ValueError(f'Widget \"{widget}\"\\'s relative width cannot be None.')\n\n            widget.width = int(widget.relative_width * available)\n            return\n\n        if widget.width &gt; available:\n            if widget.size_policy == self.size_policy == SizePolicy.STATIC:\n                raise WidthExceededError(\n                    f\"Widget {widget}'s static width of {widget.width}\"\n                    + f\" exceeds its parent's available width {available}.\"\n                    \"\"\n                )\n\n            if widget.size_policy == SizePolicy.STATIC:\n                self.width = widget.width + self.sidelength\n\n            else:\n                widget.width = available\n\n    def _apply_vertalign(\n        self, lines: list[str], diff: int, padder: str\n    ) -&gt; tuple[int, list[str]]:\n\"\"\"Insert padder line into lines diff times, depending on self.vertical_align.\n\n        Args:\n            lines: The list of lines to align.\n            diff: The available height.\n            padder: The line to use to pad.\n\n        Returns:\n            A tuple containing the vertical offset as well as the padded list of lines.\n\n        Raises:\n            NotImplementedError: The given vertical alignment is not implemented.\n        \"\"\"\n\n        if self.vertical_align == VerticalAlignment.BOTTOM:\n            for _ in range(diff):\n                lines.insert(0, padder)\n\n            return diff, lines\n\n        if self.vertical_align == VerticalAlignment.TOP:\n            for _ in range(diff):\n                lines.append(padder)\n\n            return 0, lines\n\n        if self.vertical_align == VerticalAlignment.CENTER:\n            top, extra = divmod(diff, 2)\n            bottom = top + extra\n\n            for _ in range(top):\n                lines.insert(0, padder)\n\n            for _ in range(bottom):\n                lines.append(padder)\n\n            return top, lines\n\n        raise NotImplementedError(\n            f\"Vertical alignment {self.vertical_align} is not implemented for {type(self)}.\"\n        )\n\n    def lazy_add(self, other: object) -&gt; None:\n\"\"\"Adds `other` without running get_lines.\n\n        This is analogous to `self._add_widget(other, run_get_lines=False).\n\n        Args:\n            other: The object to add.\n        \"\"\"\n\n        self._add_widget(other, run_get_lines=False)\n\n    def move(self, diff_x: int, diff_y: int) -&gt; None:\n\"\"\"Moves the widget and its children by the given x and y changes.\"\"\"\n\n        super().move(diff_x, diff_y)\n\n        for child in self._widgets:\n            child.move(diff_x, diff_y)\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Gets all lines by spacing out inner widgets.\n\n        This method reflects &amp; applies both width settings, as well as\n        the `parent_align` field.\n\n        Returns:\n            A list of all lines that represent this Container.\n        \"\"\"\n\n        def _get_border(left: str, char: str, right: str) -&gt; str:\n\"\"\"Gets a top or bottom border.\n\n            Args:\n                left: Left corner character.\n                char: Border character filling between left &amp; right.\n                right: Right corner character.\n\n            Returns:\n                The border line.\n            \"\"\"\n\n            offset = real_length(strip_markup(left + right))\n            return (\n                self.styles.corner(left)\n                + self.styles.border(char * (self.width - offset))\n                + self.styles.corner(right)\n            )\n\n        lines: list[str] = []\n\n        borders = self._get_char(\"border\")\n        corners = self._get_char(\"corner\")\n\n        has_top_bottom = (real_length(borders[1]) &gt; 0, real_length(borders[3]) &gt; 0)\n\n        align, offset = self._get_aligners(self, (borders[0], borders[2]))\n\n        overflow = self.overflow\n\n        for widget in self._widgets:\n            align, offset = self._get_aligners(widget, (borders[0], borders[2]))\n\n            self._update_width(widget)\n\n            widget.pos = (\n                self.pos[0] + offset,\n                self.pos[1] + len(lines) + (1 if has_top_bottom[0] else 0),\n            )\n\n            widget_lines: list[str] = []\n            for line in widget.get_lines():\n                if len(lines) + len(widget_lines) &gt;= self.height - sum(has_top_bottom):\n                    if overflow is Overflow.HIDE:\n                        break\n\n                    if overflow == Overflow.AUTO:\n                        overflow = Overflow.SCROLL\n\n                widget_lines.append(align(line))\n\n            lines.extend(widget_lines)\n\n        if overflow == Overflow.SCROLL:\n            self._max_scroll = len(lines) - self.height + sum(has_top_bottom)\n            height = self.height - sum(has_top_bottom)\n\n            self._scroll_offset = max(0, min(self._scroll_offset, len(lines) - height))\n            lines = lines[self._scroll_offset : self._scroll_offset + height]\n\n        elif overflow == Overflow.RESIZE:\n            self.height = len(lines) + sum(has_top_bottom)\n\n        vertical_offset, lines = self._apply_vertalign(\n            lines, self.height - len(lines) - sum(has_top_bottom), align(\"\")\n        )\n\n        for widget in self._widgets:\n            widget.move(0, vertical_offset)\n\n            self.positioned_line_buffer.extend(widget.positioned_line_buffer)\n            widget.positioned_line_buffer = []\n\n        if has_top_bottom[0]:\n            lines.insert(0, _get_border(corners[0], borders[1], corners[1]))\n\n        if has_top_bottom[1]:\n            lines.append(_get_border(corners[3], borders[3], corners[2]))\n\n        self.height = len(lines)\n        return lines\n\n    def set_widgets(self, new: list[Widget]) -&gt; None:\n\"\"\"Sets new list in place of self._widgets.\n\n        Args:\n            new: The new widget list.\n        \"\"\"\n\n        self._widgets = []\n        for widget in new:\n            self._add_widget(widget)\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serializes this Container, adding in serializations of all widgets.\n\n        See `pytermgui.widgets.base.Widget.serialize` for more info.\n\n        Returns:\n            The dictionary containing all serialized data.\n        \"\"\"\n\n        out = super().serialize()\n        out[\"_widgets\"] = []\n\n        for widget in self._widgets:\n            out[\"_widgets\"].append(widget.serialize())\n\n        return out\n\n    def pop(self, index: int = -1) -&gt; Widget:\n\"\"\"Pops widget from self._widgets.\n\n        Analogous to self._widgets.pop(index).\n\n        Args:\n            index: The index to operate on.\n\n        Returns:\n            The widget that was popped off the list.\n        \"\"\"\n\n        return self._widgets.pop(index)\n\n    def remove(self, other: Widget) -&gt; None:\n\"\"\"Remove widget from self._widgets\n\n        Analogous to self._widgets.remove(other).\n\n        Args:\n            other: The widget to remove.\n        \"\"\"\n\n        return self._widgets.remove(other)\n\n    def set_recursive_depth(self, value: int) -&gt; None:\n\"\"\"Set depth for this Container and all its children.\n\n        All inner widgets will receive value+1 as their new depth.\n\n        Args:\n            value: The new depth to use as the base depth.\n        \"\"\"\n\n        self.depth = value\n        for widget in self._widgets:\n            if isinstance(widget, Container):\n                widget.set_recursive_depth(value + 1)\n            else:\n                widget.depth = value\n\n    def select(self, index: int | None = None) -&gt; None:\n\"\"\"Selects inner subwidget.\n\n        Args:\n            index: The index to select.\n\n        Raises:\n            IndexError: The index provided was beyond len(self.selectables).\n        \"\"\"\n\n        # Unselect all sub-elements\n        for other in self._widgets:\n            if other.selectables_length &gt; 0:\n                other.select(None)\n\n        if index is not None:\n            index = max(0, min(index, len(self.selectables) - 1))\n            widget, inner_index = self.selectables[index]\n            widget.select(inner_index)\n\n        self.selected_index = index\n\n    def center(\n        self, where: CenteringPolicy | None = None, store: bool = True\n    ) -&gt; Container:\n\"\"\"Centers this object to the given axis.\n\n        Args:\n            where: A CenteringPolicy describing the place to center to\n            store: When set, this centering will be reapplied during every\n                print, as well as when calling this method with no arguments.\n\n        Returns:\n            This Container.\n        \"\"\"\n\n        # Refresh in case changes happened\n        self.get_lines()\n\n        if where is None:\n            # See `enums.py` for explanation about this ignore.\n            where = CenteringPolicy.get_default()  # type: ignore\n\n        centerx = centery = where is CenteringPolicy.ALL\n        centerx |= where is CenteringPolicy.HORIZONTAL\n        centery |= where is CenteringPolicy.VERTICAL\n\n        pos = list(self.pos)\n        if centerx:\n            pos[0] = (self.terminal.width - self.width + 2) // 2\n\n        if centery:\n            pos[1] = (self.terminal.height - self.height + 2) // 2\n\n        self.pos = (pos[0], pos[1])\n\n        if store:\n            self.centered_axis = where\n\n        self._prev_screen = self.terminal.size\n\n        return self\n\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Handles mouse events.\n\n        This, like all mouse handlers should, calls super()'s implementation first,\n        to allow usage of `on_{event}`-type callbacks. After that, it tries to find\n        a target widget within itself to handle the event.\n\n        Each handler will return a boolean. This boolean is then used to figure out\n        whether the targeted widget should be \"sticky\", i.e. a slider. Returning\n        True will set that widget as the current mouse target, and all mouse events will\n        be sent to it as long as it returns True.\n\n        Args:\n            event: The event to handle.\n\n        Returns:\n            Whether the parent of this widget should treat it as one to \"stick\" events\n            to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by\n            returning False in the handler.\n        \"\"\"\n\n        def _handle_scrolling() -&gt; bool:\n\"\"\"Scrolls the container.\"\"\"\n\n            if self.overflow != Overflow.SCROLL:\n                return False\n\n            if event.action is MouseAction.SCROLL_UP:\n                return self.scroll(-1)\n\n            if event.action is MouseAction.SCROLL_DOWN:\n                return self.scroll(1)\n\n            return False\n\n        if super().handle_mouse(event):\n            return True\n\n        if event.action is MouseAction.RELEASE and self._mouse_target is not None:\n            return self._mouse_target.handle_mouse(event)\n\n        if (\n            self._mouse_target is not None\n            and (\n                event.action.value.endswith(\"drag\")\n                or event.action.value.startswith(\"scroll\")\n            )\n            and self._mouse_target.handle_mouse(event)\n        ):\n            return True\n\n        release = MouseEvent(MouseAction.RELEASE, event.position)\n\n        selectables_index = 0\n        event.position = (event.position[0], event.position[1] + self._scroll_offset)\n\n        handled = False\n        for widget in self._widgets:\n            if (\n                widget.pos[1] - self.pos[1] - self._scroll_offset\n                &gt; self.content_dimensions[1]\n            ):\n                break\n\n            if widget.contains(event.position):\n                handled = widget.handle_mouse(event)\n                selectables_index += widget.selected_index or 0\n\n                # TODO: This really should be customizable somehow.\n                if event.action is MouseAction.LEFT_CLICK:\n                    if handled and selectables_index &lt; len(self.selectables):\n                        self.select(selectables_index)\n\n                if self._mouse_target is not None and self._mouse_target is not widget:\n                    self._mouse_target.handle_mouse(release)\n\n                self._mouse_target = widget\n\n                break\n\n            if widget.is_selectable:\n                selectables_index += widget.selectables_length\n\n        handled = handled or _handle_scrolling()\n\n        return handled\n\n    def execute_binding(self, key: Any, ignore_any: bool = False) -&gt; bool:\n\"\"\"Executes a binding on self, and then on self._widgets.\n\n        If a widget.execute_binding call returns True this function will too. Note\n        that on success the function returns immediately; no further widgets are\n        checked.\n\n        Args:\n            key: The binding key.\n            ignore_any: If set, `keys.ANY_KEY` bindings will not be executed.\n\n        Returns:\n            True if any widget returned True, False otherwise.\n        \"\"\"\n\n        if super().execute_binding(key, ignore_any=ignore_any):\n            return True\n\n        selectables_index = 0\n        for widget in self._widgets:\n            if widget.execute_binding(key):\n                selectables_index += widget.selected_index or 0\n                self.select(selectables_index)\n                return True\n\n            if widget.is_selectable:\n                selectables_index += widget.selectables_length\n\n        return False\n\n    def handle_key(  # pylint: disable=too-many-return-statements, too-many-branches\n        self, key: str\n    ) -&gt; bool:\n\"\"\"Handles a keypress, returns its success.\n\n        Args:\n            key: A key str.\n\n        Returns:\n            A boolean showing whether the key was handled.\n        \"\"\"\n\n        def _is_nav(key: str) -&gt; bool:\n\"\"\"Determine if a key is in the navigation sets\"\"\"\n\n            return key in self.keys[\"next\"] | self.keys[\"previous\"]\n\n        if self.selected is not None and self.selected.handle_key(key):\n            return True\n\n        scroll_actions = {\n            **{key: 1 for key in self.keys[\"scroll_down\"]},\n            **{key: -1 for key in self.keys[\"scroll_up\"]},\n        }\n\n        if key in self.keys[\"scroll_down\"] | self.keys[\"scroll_up\"]:\n            for widget in self._widgets:\n                if isinstance(widget, Container) and self.selected in widget:\n                    widget.handle_key(key)\n\n            self.scroll(scroll_actions[key])\n            return True\n\n        # Only use navigation when there is more than one selectable\n        if self.selectables_length &gt;= 1 and _is_nav(key):\n            if self.selected_index is None:\n                self.select(0)\n                return True\n\n            handled = False\n\n            assert isinstance(self.selected_index, int)\n\n            if key in self.keys[\"previous\"]:\n                # No more selectables left, user wants to exit Container\n                # upwards.\n                if self.selected_index == 0:\n                    return False\n\n                self.select(self.selected_index - 1)\n                handled = True\n\n            elif key in self.keys[\"next\"]:\n                # Stop selection at last element, return as unhandled\n                new = self.selected_index + 1\n                if new == len(self.selectables):\n                    return False\n\n                self.select(new)\n                handled = True\n\n            if handled:\n                return True\n\n        if key == keys.ENTER:\n            if self.selected_index is None and self.selectables_length &gt; 0:\n                self.select(0)\n\n            if self.selected is not None:\n                self.selected.handle_key(key)\n                return True\n\n        for widget in self._widgets:\n            if widget.execute_binding(key):\n                return True\n\n        return False\n\n    def wipe(self) -&gt; None:\n\"\"\"Wipes the characters occupied by the object\"\"\"\n\n        with cursor_at(self.pos) as print_here:\n            for line in self.get_lines():\n                print_here(real_length(line) * \" \")\n\n    def print(self) -&gt; None:\n\"\"\"Prints this Container.\n\n        If the screen size has changed since last `print` call, the object\n        will be centered based on its `centered_axis`.\n        \"\"\"\n\n        if not self.terminal.size == self._prev_screen:\n            clear()\n            self.center(self.centered_axis)\n\n        self._prev_screen = self.terminal.size\n\n        if self.allow_fullscreen:\n            self.pos = self.terminal.origin\n\n        with cursor_at(self.pos) as print_here:\n            for line in self.get_lines():\n                print_here(line)\n\n        self._has_printed = True\n\n    def debug(self) -&gt; str:\n\"\"\"Returns a string with identifiable information on this widget.\n\n        Returns:\n            A str in the form of a class construction. This string is in a form that\n            __could have been__ used to create this Container.\n        \"\"\"\n\n        return (\n            f\"{type(self).__name__}(width={self.width}, height={self.height}\"\n            + (f\", id={self.id}\" if self.id is not None else \"\")\n            + \")\"\n        )\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.box","title":"<code>box: boxes.Box</code>  <code>property</code> <code>writable</code>","text":"<p>Returns current box setting</p> <p>Returns:</p> Type Description <code>boxes.Box</code> <p>The currently set box instance.</p>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.content_dimensions","title":"<code>content_dimensions: tuple[int, int]</code>  <code>property</code>","text":"<p>Gets the size (width, height) of the available content area.</p>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.selectables","title":"<code>selectables: list[tuple[Widget, int]]</code>  <code>property</code>","text":"<p>Gets all selectable widgets and their inner indices.</p> <p>This is used in order to have a constant reference to all selectable indices within this widget.</p> <p>Returns:</p> Type Description <code>list[tuple[Widget, int]]</code> <p>A list of tuples containing a widget and an integer each. For each widget that is</p> <code>list[tuple[Widget, int]]</code> <p>withing this one, it is added to this list as many times as it has selectables. Each</p> <code>list[tuple[Widget, int]]</code> <p>of the integers correspond to a selectable_index within the widget.</p> <code>list[tuple[Widget, int]]</code> <p>For example, a Container with a Button, InputField and an inner Container containing</p> <code>list[tuple[Widget, int]]</code> <p>3 selectables might return something like this:</p> <code>list[tuple[Widget, int]]</code> <p>```</p> <code>list[tuple[Widget, int]]</code> <p>[ (Button(...), 0), (InputField(...), 0), (Container(...), 0), (Container(...), 1), (Container(...), 2),</p> <code>list[tuple[Widget, int]]</code> <p>]</p> <code>list[tuple[Widget, int]]</code> <p>```</p>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.selectables_length","title":"<code>selectables_length: int</code>  <code>property</code>","text":"<p>Gets the length of the selectables list.</p> <p>Returns:</p> Type Description <code>int</code> <p>An integer equal to the length of <code>self.selectables</code>.</p>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.selected","title":"<code>selected: Widget | None</code>  <code>property</code>","text":"<p>Returns the currently selected object</p> <p>Returns:</p> Type Description <code>Widget | None</code> <p>The currently selected widget if selected_index is not None,</p> <code>Widget | None</code> <p>otherwise None.</p>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.sidelength","title":"<code>sidelength: int</code>  <code>property</code>","text":"<p>Gets the length of left and right borders combined.</p> <p>Returns:</p> Type Description <code>int</code> <p>An integer equal to the <code>pytermgui.helpers.real_length</code> of the concatenation of the left and right borders of this widget, both with their respective styles applied.</p>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__add__","title":"<code>__add__(other)</code>","text":"<p>Adds a new widget, then returns self.</p> <p>This method is analogous to <code>Container.__iadd__</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Any widget instance, or data structure that can be turned into a widget by <code>Widget.from_data</code>.</p> required <p>Returns:</p> Type Description <code>Container</code> <p>A reference to self.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def __add__(self, other: object) -&gt; Container:\n\"\"\"Adds a new widget, then returns self.\n\n    This method is analogous to `Container.__iadd__`.\n\n    Args:\n        other: Any widget instance, or data structure that can be turned\n            into a widget by `Widget.from_data`.\n\n    Returns:\n        A reference to self.\n    \"\"\"\n\n    self.__iadd__(other)\n    return self\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__contains__","title":"<code>__contains__(other)</code>","text":"<p>Determines if self._widgets contains other widget.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Any widget-like.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean describing whether <code>other</code> is in <code>self.widgets</code></p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def __contains__(self, other: object) -&gt; bool:\n\"\"\"Determines if self._widgets contains other widget.\n\n    Args:\n        other: Any widget-like.\n\n    Returns:\n        A boolean describing whether `other` is in `self.widgets`\n    \"\"\"\n\n    if other in self._widgets:\n        return True\n\n    for widget in self._widgets:\n        if isinstance(widget, Container) and other in widget:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__getitem__","title":"<code>__getitem__(sli)</code>","text":"<p>Gets an item from self._widgets.</p> <p>Parameters:</p> Name Type Description Default <code>sli</code> <code>int | slice</code> <p>Slice of the list.</p> required <p>Returns:</p> Type Description <code>Widget | list[Widget]</code> <p>The slice in the list.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def __getitem__(self, sli: int | slice) -&gt; Widget | list[Widget]:\n\"\"\"Gets an item from self._widgets.\n\n    Args:\n        sli: Slice of the list.\n\n    Returns:\n        The slice in the list.\n    \"\"\"\n\n    return self._widgets[sli]\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Adds a new widget, then returns self.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Any widget instance, or data structure that can be turned into a widget by <code>Widget.from_data</code>.</p> required <p>Returns:</p> Type Description <code>Container</code> <p>A reference to self.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def __iadd__(self, other: object) -&gt; Container:\n\"\"\"Adds a new widget, then returns self.\n\n    Args:\n        other: Any widget instance, or data structure that can be turned\n            into a widget by `Widget.from_data`.\n\n    Returns:\n        A reference to self.\n    \"\"\"\n\n    self._add_widget(other)\n    return self\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__init__","title":"<code>__init__(*widgets, **attrs)</code>","text":"<p>Initialize Container data</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def __init__(self, *widgets: Any, **attrs: Any) -&gt; None:\n\"\"\"Initialize Container data\"\"\"\n\n    super().__init__(**attrs)\n\n    # TODO: This is just a band-aid.\n    if not any(\"width\" in attr for attr in attrs):\n        self.width = 40\n\n    self._widgets: list[Widget] = []\n    self.dirty_widgets: list[Widget] = []\n    self.centered_axis: CenteringPolicy | None = None\n\n    self._prev_screen: tuple[int, int] = (0, 0)\n    self._has_printed = False\n\n    for widget in widgets:\n        self._add_widget(widget)\n\n    if \"box\" not in attrs:\n        attrs[\"box\"] = \"SINGLE\"\n\n    try:\n        self.box = attrs[\"box\"]\n    # Splitter doesn't use boxes ATM.\n    except KeyError:\n        pass\n\n    self._mouse_target: Widget | None = None\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__iter__","title":"<code>__iter__()</code>","text":"<p>Gets an iterator of self._widgets.</p> <p>Yields:</p> Type Description <code>Widget</code> <p>The next widget.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Widget]:\n\"\"\"Gets an iterator of self._widgets.\n\n    Yields:\n        The next widget.\n    \"\"\"\n\n    for widget in self._widgets:\n        yield widget\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__len__","title":"<code>__len__()</code>","text":"<p>Gets the length of the widgets list.</p> <p>Returns:</p> Type Description <code>int</code> <p>An integer describing len(self._widgets).</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Gets the length of the widgets list.\n\n    Returns:\n        An integer describing len(self._widgets).\n    \"\"\"\n\n    return len(self._widgets)\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.__setitem__","title":"<code>__setitem__(index, value)</code>","text":"<p>Sets an item in self._widgets.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to be set.</p> required <code>value</code> <code>Any</code> <p>The new widget at this index.</p> required Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def __setitem__(self, index: int, value: Any) -&gt; None:\n\"\"\"Sets an item in self._widgets.\n\n    Args:\n        index: The index to be set.\n        value: The new widget at this index.\n    \"\"\"\n\n    self._widgets[index] = value\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.center","title":"<code>center(where=None, store=True)</code>","text":"<p>Centers this object to the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>CenteringPolicy | None</code> <p>A CenteringPolicy describing the place to center to</p> <code>None</code> <code>store</code> <code>bool</code> <p>When set, this centering will be reapplied during every print, as well as when calling this method with no arguments.</p> <code>True</code> <p>Returns:</p> Type Description <code>Container</code> <p>This Container.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def center(\n    self, where: CenteringPolicy | None = None, store: bool = True\n) -&gt; Container:\n\"\"\"Centers this object to the given axis.\n\n    Args:\n        where: A CenteringPolicy describing the place to center to\n        store: When set, this centering will be reapplied during every\n            print, as well as when calling this method with no arguments.\n\n    Returns:\n        This Container.\n    \"\"\"\n\n    # Refresh in case changes happened\n    self.get_lines()\n\n    if where is None:\n        # See `enums.py` for explanation about this ignore.\n        where = CenteringPolicy.get_default()  # type: ignore\n\n    centerx = centery = where is CenteringPolicy.ALL\n    centerx |= where is CenteringPolicy.HORIZONTAL\n    centery |= where is CenteringPolicy.VERTICAL\n\n    pos = list(self.pos)\n    if centerx:\n        pos[0] = (self.terminal.width - self.width + 2) // 2\n\n    if centery:\n        pos[1] = (self.terminal.height - self.height + 2) // 2\n\n    self.pos = (pos[0], pos[1])\n\n    if store:\n        self.centered_axis = where\n\n    self._prev_screen = self.terminal.size\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.debug","title":"<code>debug()</code>","text":"<p>Returns a string with identifiable information on this widget.</p> <p>Returns:</p> Type Description <code>str</code> <p>A str in the form of a class construction. This string is in a form that</p> <code>str</code> <p>could have been used to create this Container.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def debug(self) -&gt; str:\n\"\"\"Returns a string with identifiable information on this widget.\n\n    Returns:\n        A str in the form of a class construction. This string is in a form that\n        __could have been__ used to create this Container.\n    \"\"\"\n\n    return (\n        f\"{type(self).__name__}(width={self.width}, height={self.height}\"\n        + (f\", id={self.id}\" if self.id is not None else \"\")\n        + \")\"\n    )\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.execute_binding","title":"<code>execute_binding(key, ignore_any=False)</code>","text":"<p>Executes a binding on self, and then on self._widgets.</p> <p>If a widget.execute_binding call returns True this function will too. Note that on success the function returns immediately; no further widgets are checked.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The binding key.</p> required <code>ignore_any</code> <code>bool</code> <p>If set, <code>keys.ANY_KEY</code> bindings will not be executed.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if any widget returned True, False otherwise.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def execute_binding(self, key: Any, ignore_any: bool = False) -&gt; bool:\n\"\"\"Executes a binding on self, and then on self._widgets.\n\n    If a widget.execute_binding call returns True this function will too. Note\n    that on success the function returns immediately; no further widgets are\n    checked.\n\n    Args:\n        key: The binding key.\n        ignore_any: If set, `keys.ANY_KEY` bindings will not be executed.\n\n    Returns:\n        True if any widget returned True, False otherwise.\n    \"\"\"\n\n    if super().execute_binding(key, ignore_any=ignore_any):\n        return True\n\n    selectables_index = 0\n    for widget in self._widgets:\n        if widget.execute_binding(key):\n            selectables_index += widget.selected_index or 0\n            self.select(selectables_index)\n            return True\n\n        if widget.is_selectable:\n            selectables_index += widget.selectables_length\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.get_change","title":"<code>get_change()</code>","text":"<p>Determines whether widget lines changed since the last call to this function.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def get_change(self) -&gt; WidgetChange | None:\n\"\"\"Determines whether widget lines changed since the last call to this function.\"\"\"\n\n    change = super().get_change()\n\n    if change is None:\n        return None\n\n    for widget in self._widgets:\n        if widget.get_change() is not None:\n            self.dirty_widgets.append(widget)\n\n    return change\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.get_lines","title":"<code>get_lines()</code>","text":"<p>Gets all lines by spacing out inner widgets.</p> <p>This method reflects &amp; applies both width settings, as well as the <code>parent_align</code> field.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of all lines that represent this Container.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Gets all lines by spacing out inner widgets.\n\n    This method reflects &amp; applies both width settings, as well as\n    the `parent_align` field.\n\n    Returns:\n        A list of all lines that represent this Container.\n    \"\"\"\n\n    def _get_border(left: str, char: str, right: str) -&gt; str:\n\"\"\"Gets a top or bottom border.\n\n        Args:\n            left: Left corner character.\n            char: Border character filling between left &amp; right.\n            right: Right corner character.\n\n        Returns:\n            The border line.\n        \"\"\"\n\n        offset = real_length(strip_markup(left + right))\n        return (\n            self.styles.corner(left)\n            + self.styles.border(char * (self.width - offset))\n            + self.styles.corner(right)\n        )\n\n    lines: list[str] = []\n\n    borders = self._get_char(\"border\")\n    corners = self._get_char(\"corner\")\n\n    has_top_bottom = (real_length(borders[1]) &gt; 0, real_length(borders[3]) &gt; 0)\n\n    align, offset = self._get_aligners(self, (borders[0], borders[2]))\n\n    overflow = self.overflow\n\n    for widget in self._widgets:\n        align, offset = self._get_aligners(widget, (borders[0], borders[2]))\n\n        self._update_width(widget)\n\n        widget.pos = (\n            self.pos[0] + offset,\n            self.pos[1] + len(lines) + (1 if has_top_bottom[0] else 0),\n        )\n\n        widget_lines: list[str] = []\n        for line in widget.get_lines():\n            if len(lines) + len(widget_lines) &gt;= self.height - sum(has_top_bottom):\n                if overflow is Overflow.HIDE:\n                    break\n\n                if overflow == Overflow.AUTO:\n                    overflow = Overflow.SCROLL\n\n            widget_lines.append(align(line))\n\n        lines.extend(widget_lines)\n\n    if overflow == Overflow.SCROLL:\n        self._max_scroll = len(lines) - self.height + sum(has_top_bottom)\n        height = self.height - sum(has_top_bottom)\n\n        self._scroll_offset = max(0, min(self._scroll_offset, len(lines) - height))\n        lines = lines[self._scroll_offset : self._scroll_offset + height]\n\n    elif overflow == Overflow.RESIZE:\n        self.height = len(lines) + sum(has_top_bottom)\n\n    vertical_offset, lines = self._apply_vertalign(\n        lines, self.height - len(lines) - sum(has_top_bottom), align(\"\")\n    )\n\n    for widget in self._widgets:\n        widget.move(0, vertical_offset)\n\n        self.positioned_line_buffer.extend(widget.positioned_line_buffer)\n        widget.positioned_line_buffer = []\n\n    if has_top_bottom[0]:\n        lines.insert(0, _get_border(corners[0], borders[1], corners[1]))\n\n    if has_top_bottom[1]:\n        lines.append(_get_border(corners[3], borders[3], corners[2]))\n\n    self.height = len(lines)\n    return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.handle_key","title":"<code>handle_key(key)</code>","text":"<p>Handles a keypress, returns its success.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>A key str.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean showing whether the key was handled.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def handle_key(  # pylint: disable=too-many-return-statements, too-many-branches\n    self, key: str\n) -&gt; bool:\n\"\"\"Handles a keypress, returns its success.\n\n    Args:\n        key: A key str.\n\n    Returns:\n        A boolean showing whether the key was handled.\n    \"\"\"\n\n    def _is_nav(key: str) -&gt; bool:\n\"\"\"Determine if a key is in the navigation sets\"\"\"\n\n        return key in self.keys[\"next\"] | self.keys[\"previous\"]\n\n    if self.selected is not None and self.selected.handle_key(key):\n        return True\n\n    scroll_actions = {\n        **{key: 1 for key in self.keys[\"scroll_down\"]},\n        **{key: -1 for key in self.keys[\"scroll_up\"]},\n    }\n\n    if key in self.keys[\"scroll_down\"] | self.keys[\"scroll_up\"]:\n        for widget in self._widgets:\n            if isinstance(widget, Container) and self.selected in widget:\n                widget.handle_key(key)\n\n        self.scroll(scroll_actions[key])\n        return True\n\n    # Only use navigation when there is more than one selectable\n    if self.selectables_length &gt;= 1 and _is_nav(key):\n        if self.selected_index is None:\n            self.select(0)\n            return True\n\n        handled = False\n\n        assert isinstance(self.selected_index, int)\n\n        if key in self.keys[\"previous\"]:\n            # No more selectables left, user wants to exit Container\n            # upwards.\n            if self.selected_index == 0:\n                return False\n\n            self.select(self.selected_index - 1)\n            handled = True\n\n        elif key in self.keys[\"next\"]:\n            # Stop selection at last element, return as unhandled\n            new = self.selected_index + 1\n            if new == len(self.selectables):\n                return False\n\n            self.select(new)\n            handled = True\n\n        if handled:\n            return True\n\n    if key == keys.ENTER:\n        if self.selected_index is None and self.selectables_length &gt; 0:\n            self.select(0)\n\n        if self.selected is not None:\n            self.selected.handle_key(key)\n            return True\n\n    for widget in self._widgets:\n        if widget.execute_binding(key):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.handle_mouse","title":"<code>handle_mouse(event)</code>","text":"<p>Handles mouse events.</p> <p>This, like all mouse handlers should, calls super()'s implementation first, to allow usage of <code>on_{event}</code>-type callbacks. After that, it tries to find a target widget within itself to handle the event.</p> <p>Each handler will return a boolean. This boolean is then used to figure out whether the targeted widget should be \"sticky\", i.e. a slider. Returning True will set that widget as the current mouse target, and all mouse events will be sent to it as long as it returns True.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseEvent</code> <p>The event to handle.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the parent of this widget should treat it as one to \"stick\" events</p> <code>bool</code> <p>to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by</p> <code>bool</code> <p>returning False in the handler.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Handles mouse events.\n\n    This, like all mouse handlers should, calls super()'s implementation first,\n    to allow usage of `on_{event}`-type callbacks. After that, it tries to find\n    a target widget within itself to handle the event.\n\n    Each handler will return a boolean. This boolean is then used to figure out\n    whether the targeted widget should be \"sticky\", i.e. a slider. Returning\n    True will set that widget as the current mouse target, and all mouse events will\n    be sent to it as long as it returns True.\n\n    Args:\n        event: The event to handle.\n\n    Returns:\n        Whether the parent of this widget should treat it as one to \"stick\" events\n        to, e.g. to keep sending mouse events to it. One can \"unstick\" a widget by\n        returning False in the handler.\n    \"\"\"\n\n    def _handle_scrolling() -&gt; bool:\n\"\"\"Scrolls the container.\"\"\"\n\n        if self.overflow != Overflow.SCROLL:\n            return False\n\n        if event.action is MouseAction.SCROLL_UP:\n            return self.scroll(-1)\n\n        if event.action is MouseAction.SCROLL_DOWN:\n            return self.scroll(1)\n\n        return False\n\n    if super().handle_mouse(event):\n        return True\n\n    if event.action is MouseAction.RELEASE and self._mouse_target is not None:\n        return self._mouse_target.handle_mouse(event)\n\n    if (\n        self._mouse_target is not None\n        and (\n            event.action.value.endswith(\"drag\")\n            or event.action.value.startswith(\"scroll\")\n        )\n        and self._mouse_target.handle_mouse(event)\n    ):\n        return True\n\n    release = MouseEvent(MouseAction.RELEASE, event.position)\n\n    selectables_index = 0\n    event.position = (event.position[0], event.position[1] + self._scroll_offset)\n\n    handled = False\n    for widget in self._widgets:\n        if (\n            widget.pos[1] - self.pos[1] - self._scroll_offset\n            &gt; self.content_dimensions[1]\n        ):\n            break\n\n        if widget.contains(event.position):\n            handled = widget.handle_mouse(event)\n            selectables_index += widget.selected_index or 0\n\n            # TODO: This really should be customizable somehow.\n            if event.action is MouseAction.LEFT_CLICK:\n                if handled and selectables_index &lt; len(self.selectables):\n                    self.select(selectables_index)\n\n            if self._mouse_target is not None and self._mouse_target is not widget:\n                self._mouse_target.handle_mouse(release)\n\n            self._mouse_target = widget\n\n            break\n\n        if widget.is_selectable:\n            selectables_index += widget.selectables_length\n\n    handled = handled or _handle_scrolling()\n\n    return handled\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.lazy_add","title":"<code>lazy_add(other)</code>","text":"<p>Adds <code>other</code> without running get_lines.</p> <p>This is analogous to `self._add_widget(other, run_get_lines=False).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>The object to add.</p> required Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def lazy_add(self, other: object) -&gt; None:\n\"\"\"Adds `other` without running get_lines.\n\n    This is analogous to `self._add_widget(other, run_get_lines=False).\n\n    Args:\n        other: The object to add.\n    \"\"\"\n\n    self._add_widget(other, run_get_lines=False)\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.move","title":"<code>move(diff_x, diff_y)</code>","text":"<p>Moves the widget and its children by the given x and y changes.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def move(self, diff_x: int, diff_y: int) -&gt; None:\n\"\"\"Moves the widget and its children by the given x and y changes.\"\"\"\n\n    super().move(diff_x, diff_y)\n\n    for child in self._widgets:\n        child.move(diff_x, diff_y)\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.pop","title":"<code>pop(index=-1)</code>","text":"<p>Pops widget from self._widgets.</p> <p>Analogous to self._widgets.pop(index).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to operate on.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Widget</code> <p>The widget that was popped off the list.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def pop(self, index: int = -1) -&gt; Widget:\n\"\"\"Pops widget from self._widgets.\n\n    Analogous to self._widgets.pop(index).\n\n    Args:\n        index: The index to operate on.\n\n    Returns:\n        The widget that was popped off the list.\n    \"\"\"\n\n    return self._widgets.pop(index)\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.print","title":"<code>print()</code>","text":"<p>Prints this Container.</p> <p>If the screen size has changed since last <code>print</code> call, the object will be centered based on its <code>centered_axis</code>.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def print(self) -&gt; None:\n\"\"\"Prints this Container.\n\n    If the screen size has changed since last `print` call, the object\n    will be centered based on its `centered_axis`.\n    \"\"\"\n\n    if not self.terminal.size == self._prev_screen:\n        clear()\n        self.center(self.centered_axis)\n\n    self._prev_screen = self.terminal.size\n\n    if self.allow_fullscreen:\n        self.pos = self.terminal.origin\n\n    with cursor_at(self.pos) as print_here:\n        for line in self.get_lines():\n            print_here(line)\n\n    self._has_printed = True\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.remove","title":"<code>remove(other)</code>","text":"<p>Remove widget from self._widgets</p> <p>Analogous to self._widgets.remove(other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Widget</code> <p>The widget to remove.</p> required Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def remove(self, other: Widget) -&gt; None:\n\"\"\"Remove widget from self._widgets\n\n    Analogous to self._widgets.remove(other).\n\n    Args:\n        other: The widget to remove.\n    \"\"\"\n\n    return self._widgets.remove(other)\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.select","title":"<code>select(index=None)</code>","text":"<p>Selects inner subwidget.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | None</code> <p>The index to select.</p> <code>None</code> <p>Raises:</p> Type Description <code>IndexError</code> <p>The index provided was beyond len(self.selectables).</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def select(self, index: int | None = None) -&gt; None:\n\"\"\"Selects inner subwidget.\n\n    Args:\n        index: The index to select.\n\n    Raises:\n        IndexError: The index provided was beyond len(self.selectables).\n    \"\"\"\n\n    # Unselect all sub-elements\n    for other in self._widgets:\n        if other.selectables_length &gt; 0:\n            other.select(None)\n\n    if index is not None:\n        index = max(0, min(index, len(self.selectables) - 1))\n        widget, inner_index = self.selectables[index]\n        widget.select(inner_index)\n\n    self.selected_index = index\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.serialize","title":"<code>serialize()</code>","text":"<p>Serializes this Container, adding in serializations of all widgets.</p> <p>See <code>pytermgui.widgets.base.Widget.serialize</code> for more info.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dictionary containing all serialized data.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serializes this Container, adding in serializations of all widgets.\n\n    See `pytermgui.widgets.base.Widget.serialize` for more info.\n\n    Returns:\n        The dictionary containing all serialized data.\n    \"\"\"\n\n    out = super().serialize()\n    out[\"_widgets\"] = []\n\n    for widget in self._widgets:\n        out[\"_widgets\"].append(widget.serialize())\n\n    return out\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.set_recursive_depth","title":"<code>set_recursive_depth(value)</code>","text":"<p>Set depth for this Container and all its children.</p> <p>All inner widgets will receive value+1 as their new depth.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The new depth to use as the base depth.</p> required Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def set_recursive_depth(self, value: int) -&gt; None:\n\"\"\"Set depth for this Container and all its children.\n\n    All inner widgets will receive value+1 as their new depth.\n\n    Args:\n        value: The new depth to use as the base depth.\n    \"\"\"\n\n    self.depth = value\n    for widget in self._widgets:\n        if isinstance(widget, Container):\n            widget.set_recursive_depth(value + 1)\n        else:\n            widget.depth = value\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.set_widgets","title":"<code>set_widgets(new)</code>","text":"<p>Sets new list in place of self._widgets.</p> <p>Parameters:</p> Name Type Description Default <code>new</code> <code>list[Widget]</code> <p>The new widget list.</p> required Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def set_widgets(self, new: list[Widget]) -&gt; None:\n\"\"\"Sets new list in place of self._widgets.\n\n    Args:\n        new: The new widget list.\n    \"\"\"\n\n    self._widgets = []\n    for widget in new:\n        self._add_widget(widget)\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Container.wipe","title":"<code>wipe()</code>","text":"<p>Wipes the characters occupied by the object</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def wipe(self) -&gt; None:\n\"\"\"Wipes the characters occupied by the object\"\"\"\n\n    with cursor_at(self.pos) as print_here:\n        for line in self.get_lines():\n            print_here(real_length(line) * \" \")\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Splitter","title":"<code>Splitter</code>","text":"<p>             Bases: <code>Container</code></p> <p>A widget that displays other widgets, stacked horizontally.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>class Splitter(Container):\n\"\"\"A widget that displays other widgets, stacked horizontally.\"\"\"\n\n    styles = w_styles.StyleManager(separator=\"surface\", fill=\"background\")\n\n    chars: dict[str, list[str] | str] = {\"separator\": \" | \"}\n    keys = {\n        \"previous\": {keys.LEFT, \"h\", keys.CTRL_B},\n        \"next\": {keys.RIGHT, \"l\", keys.CTRL_F},\n    }\n\n    parent_align = HorizontalAlignment.RIGHT\n\n    def _align_line(\n        self, alignment: HorizontalAlignment, target_width: int, line: str\n    ) -&gt; tuple[int, str]:\n\"\"\"Align a line\n\n        r/wordavalanches\"\"\"\n\n        available = target_width - real_length(line)\n        fill_style = self._get_style(\"fill\")\n\n        char = fill_style(\" \")\n        line = fill_style(line)\n\n        if alignment == HorizontalAlignment.CENTER:\n            padding, offset = divmod(available, 2)\n            return padding, padding * char + line + (padding + offset) * char\n\n        if alignment == HorizontalAlignment.RIGHT:\n            return available, available * char + line\n\n        return 0, line + available * char\n\n    @property\n    def content_dimensions(self) -&gt; tuple[int, int]:\n\"\"\"Returns the available area for widgets.\"\"\"\n\n        return self.height, self.width\n\n    def get_lines(self) -&gt; list[str]:  # pylint: disable=too-many-locals\n\"\"\"Join all widgets horizontally.\"\"\"\n\n        # An error will be raised if `separator` is not the correct type (str).\n        separator = self._get_style(\"separator\")(self._get_char(\"separator\"))  # type: ignore\n        separator_length = real_length(separator)\n\n        target_width, error = divmod(\n            self.width - (len(self._widgets) - 1) * separator_length, len(self._widgets)\n        )\n\n        self.positioned_line_buffer = []\n        vertical_lines = []\n        total_offset = 0\n\n        for widget in self._widgets:\n            inner = []\n\n            if widget.size_policy is SizePolicy.STATIC:\n                target_width += target_width - widget.width\n                width = widget.width\n            else:\n                widget.width = target_width + error\n                width = widget.width\n                error = 0\n\n            aligned: str | None = None\n            for line in widget.get_lines():\n                # See `enums.py` for information about this ignore\n                padding, aligned = self._align_line(\n                    cast(HorizontalAlignment, widget.parent_align), width, line\n                )\n                inner.append(aligned)\n\n            new_pos = (\n                self.pos[0] + padding + total_offset,\n                self.pos[1] + (1 if type(widget).__name__ == \"Container\" else 0),\n            )\n\n            diff_x = new_pos[0] - widget.pos[0]\n            diff_y = new_pos[1] - widget.pos[1]\n\n            widget.pos = new_pos\n\n            for pos, line in widget.positioned_line_buffer:\n                self.positioned_line_buffer.append(\n                    ((pos[0] + diff_x, pos[1] + diff_y), line)\n                )\n\n            widget.positioned_line_buffer = []\n\n            if aligned is not None:\n                total_offset += real_length(inner[-1]) + separator_length\n\n            vertical_lines.append(inner)\n\n        lines = []\n        for horizontal in zip_longest(*vertical_lines, fillvalue=\" \" * target_width):\n            lines.append((reset() + separator).join(horizontal))\n\n        self.height = max(widget.height for widget in self)\n        return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Splitter.content_dimensions","title":"<code>content_dimensions: tuple[int, int]</code>  <code>property</code>","text":"<p>Returns the available area for widgets.</p>"},{"location":"reference/pytermgui/widgets/containers/#pytermgui.widgets.containers.Splitter.get_lines","title":"<code>get_lines()</code>","text":"<p>Join all widgets horizontally.</p> Source code in <code>pytermgui/widgets/containers.py</code> <pre><code>def get_lines(self) -&gt; list[str]:  # pylint: disable=too-many-locals\n\"\"\"Join all widgets horizontally.\"\"\"\n\n    # An error will be raised if `separator` is not the correct type (str).\n    separator = self._get_style(\"separator\")(self._get_char(\"separator\"))  # type: ignore\n    separator_length = real_length(separator)\n\n    target_width, error = divmod(\n        self.width - (len(self._widgets) - 1) * separator_length, len(self._widgets)\n    )\n\n    self.positioned_line_buffer = []\n    vertical_lines = []\n    total_offset = 0\n\n    for widget in self._widgets:\n        inner = []\n\n        if widget.size_policy is SizePolicy.STATIC:\n            target_width += target_width - widget.width\n            width = widget.width\n        else:\n            widget.width = target_width + error\n            width = widget.width\n            error = 0\n\n        aligned: str | None = None\n        for line in widget.get_lines():\n            # See `enums.py` for information about this ignore\n            padding, aligned = self._align_line(\n                cast(HorizontalAlignment, widget.parent_align), width, line\n            )\n            inner.append(aligned)\n\n        new_pos = (\n            self.pos[0] + padding + total_offset,\n            self.pos[1] + (1 if type(widget).__name__ == \"Container\" else 0),\n        )\n\n        diff_x = new_pos[0] - widget.pos[0]\n        diff_y = new_pos[1] - widget.pos[1]\n\n        widget.pos = new_pos\n\n        for pos, line in widget.positioned_line_buffer:\n            self.positioned_line_buffer.append(\n                ((pos[0] + diff_x, pos[1] + diff_y), line)\n            )\n\n        widget.positioned_line_buffer = []\n\n        if aligned is not None:\n            total_offset += real_length(inner[-1]) + separator_length\n\n        vertical_lines.append(inner)\n\n    lines = []\n    for horizontal in zip_longest(*vertical_lines, fillvalue=\" \" * target_width):\n        lines.append((reset() + separator).join(horizontal))\n\n    self.height = max(widget.height for widget in self)\n    return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/fancy_repr/","title":"fancy_repr","text":"<p>A widget to wrap objects supporting the <code>fancy_repr</code> protocol.</p>"},{"location":"reference/pytermgui/widgets/fancy_repr/#pytermgui.widgets.fancy_repr.FancyReprWidget","title":"<code>FancyReprWidget</code>","text":"<p>             Bases: <code>Widget</code></p> <p>A widget that wraps objects supporting the <code>fancy_repr</code> protocol.</p> Source code in <code>pytermgui/widgets/fancy_repr.py</code> <pre><code>class FancyReprWidget(Widget):\n\"\"\"A widget that wraps objects supporting the `fancy_repr` protocol.\"\"\"\n\n    def __init__(\n        self, target: SupportsFancyRepr, starts_at: int = 0, **attrs: Any\n    ) -&gt; None:\n        self.target = target\n        self.starts_at = starts_at\n\n        super().__init__(**attrs)\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Builds fancy repr of target and returns it.\"\"\"\n\n        start = self.starts_at\n        lines = [\n            tim.parse(line)\n            for line in build_fancy_repr(self.target).splitlines()[start:]\n        ]\n\n        self.width = max(len(line) for line in lines)\n        self.height = len(lines)\n\n        return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/fancy_repr/#pytermgui.widgets.fancy_repr.FancyReprWidget.get_lines","title":"<code>get_lines()</code>","text":"<p>Builds fancy repr of target and returns it.</p> Source code in <code>pytermgui/widgets/fancy_repr.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Builds fancy repr of target and returns it.\"\"\"\n\n    start = self.starts_at\n    lines = [\n        tim.parse(line)\n        for line in build_fancy_repr(self.target).splitlines()[start:]\n    ]\n\n    self.width = max(len(line) for line in lines)\n    self.height = len(lines)\n\n    return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/","title":"frames","text":"<p>Classes to wrap anything that needs a border.</p>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.ASCII","title":"<code>ASCII</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame made up of only ASCII characters.</p> <p>Preview:</p> <pre><code>-----\n| x |\n-----\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class ASCII(Frame):\n\"\"\"A frame made up of only ASCII characters.\n\n    Preview:\n\n    ```\n    -----\n    | x |\n    -----\n    ```\n    \"\"\"\n\n    descriptor = [\n        \"-----\",\n        \"| x |\",\n        \"-----\",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.ASCII_O","title":"<code>ASCII_O</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame made up of only ASCII characters, with X-s in the corners.</p> <p>Preview:</p> <pre><code>o---o\n| x |\no---o\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class ASCII_O(Frame):  # pylint: disable=invalid-name\n\"\"\"A frame made up of only ASCII characters, with X-s in the corners.\n\n    Preview:\n\n    ```\n    o---o\n    | x |\n    o---o\n    ```\n    \"\"\"\n\n    content_char = \"x\"\n\n    descriptor = [\n        \"o---o\",\n        \"| x |\",\n        \"o---o\",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.ASCII_X","title":"<code>ASCII_X</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame made up of only ASCII characters, with X-s in the corners.</p> <p>Preview:</p> <pre><code>x---x\n| # |\nx---x\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class ASCII_X(Frame):  # pylint: disable=invalid-name\n\"\"\"A frame made up of only ASCII characters, with X-s in the corners.\n\n    Preview:\n\n    ```\n    x---x\n    | # |\n    x---x\n    ```\n    \"\"\"\n\n    content_char = \"#\"\n\n    descriptor = [\n        \"x---x\",\n        \"| # |\",\n        \"x---x\",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Double","title":"<code>Double</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame with a double outline.</p> <p>Preview:</p> <pre><code>\u2554\u2550\u2550\u2550\u2557\n\u2551 x \u2551\n\u255a\u2550\u2550\u2550\u255d\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class Double(Frame):\n\"\"\"A frame with a double outline.\n\n    Preview:\n\n    ```\n    \u2554\u2550\u2550\u2550\u2557\n    \u2551 x \u2551\n    \u255a\u2550\u2550\u2550\u255d\n    ```\n    \"\"\"\n\n    descriptor = [\n        \"\u2554\u2550\u2550\u2550\u2557\",\n        \"\u2551 x \u2551\",\n        \"\u255a\u2550\u2550\u2550\u255d\",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frame","title":"<code>Frame</code>","text":"<p>An object that wraps a frame around its parent.</p> <p>It can be used by any widget in order to draw a 'box' around itself. It implements scrolling as well.</p> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class Frame:\n\"\"\"An object that wraps a frame around its parent.\n\n    It can be used by any widget in order to draw a 'box' around itself. It\n    implements scrolling as well.\n    \"\"\"\n\n    descriptor: str\n    content_char: str = \"x\"\n\n    # left, top, right, bottom\n    borders: tuple[str, str, str, str]\n\n    # left_top, right_top, right_bottom, left_bottom\n    corners: tuple[str, str, str, str]\n\n    styles = StyleManager(\n        border=\"surface\",\n        corner=\"surface2+2\",\n    )\n\n    def __init__(self, parent: Widget) -&gt; None:\n\"\"\"Initializes Frame.\"\"\"\n\n        self._parent = parent\n        self.styles = self.styles.branch(self._parent)\n\n        if self.descriptor is not None:\n            self._init_from_descriptor()\n\n    def _init_from_descriptor(self) -&gt; None:\n\"\"\"Initializes the Frame's border &amp; corner chars from the content property.\"\"\"\n\n        top, _, bottom = self.descriptor\n        top_left, top_right = self._get_corners(top)\n        bottom_left, bottom_right = self._get_corners(bottom)\n\n        self.borders = list(self._get_borders(self.descriptor))\n        self.corners = [\n            top_left,\n            top_right,\n            bottom_right,\n            bottom_left,\n        ]\n\n    @staticmethod\n    def _find_mode_char(line: str) -&gt; str:\n\"\"\"Finds the most often consecutively occuring character.\"\"\"\n\n        instances = 0\n        current_char = \"\"\n\n        results: list[tuple[str, int]] = []\n        for char in line:\n            if current_char == char:\n                instances += 1\n            else:\n                if len(current_char) &gt; 0:\n                    results.append((current_char, instances))\n\n                instances = 1\n                current_char = char\n\n        results.append((current_char, instances))\n\n        results.sort(key=lambda item: item[1])\n        if len(results) == 0:\n            print(line, instances, current_char)\n\n        return results[-1][0]\n\n    def _get_corners(self, line: str) -&gt; tuple[str, str]:\n\"\"\"Gets corners from a line.\"\"\"\n\n        mode_char = self._find_mode_char(line)\n        left = line[: line.index(mode_char)]\n        right = line[real_length(line) - (line[::-1].index(mode_char)) :]\n\n        return left, right\n\n    def _get_borders(self, lines: list[str]) -&gt; tuple[str, str, str, str]:\n\"\"\"Gets borders from all lines.\"\"\"\n\n        top, middle, bottom = lines\n        middle_reversed = middle[::-1]\n\n        top_border = self._find_mode_char(top)\n        left_border = middle[: middle.index(self.content_char)]\n\n        right_border = middle[\n            real_length(middle) - middle_reversed.index(self.content_char) :\n        ]\n        bottom_border = self._find_mode_char(bottom)\n\n        return left_border, top_border, right_border, bottom_border\n\n    @staticmethod\n    def from_name(name: str) -&gt; Type[Frame]:\n\"\"\"Gets a builtin Frame type from its name.\"\"\"\n\n        if frame := globals().get(name):\n            return frame\n\n        raise ValueError(f\"No frame defined with name {name!r}.\")\n\n    @cached_property\n    def left_size(self) -&gt; int:\n\"\"\"Returns the length of the left border character.\"\"\"\n\n        return real_length(self.borders[0])\n\n    @cached_property\n    def top_size(self) -&gt; int:\n\"\"\"Returns the height of the top border.\"\"\"\n\n        return 1\n\n    @cached_property\n    def right_size(self) -&gt; int:\n\"\"\"Returns the length of the right border character.\"\"\"\n\n        return real_length(self.borders[2])\n\n    @cached_property\n    def bottom_size(self) -&gt; int:\n\"\"\"Returns the height of the bottom border.\"\"\"\n\n        return 1\n\n    def __call__(self, lines: list[str]) -&gt; list[str]:\n\"\"\"Frames the given lines, handles scrolling when necessary.\n\n        Args:\n            lines: A list of lines to 'frame'. If there are too many\n                lines, they are clipped according to the parent's\n                `scroll` field.\n\n        Returns:\n            Framed lines, clipped to the current scrolling settings.\n        \"\"\"\n\n        if len(self.borders) != 4 or len(self.corners) != 4:\n            raise ValueError(\"Cannot frame with no border or corner values.\")\n\n        scroll = self._parent.scroll\n\n        # TODO: Widget.size should substract frame size, once\n        #       it is aware of the frame.\n        # width, height = self._parent.size\n        width, height = self._parent.width, self._parent.height\n\n        lines = lines[scroll.vertical : scroll.vertical + height]\n\n        left_top, right_top, right_bottom, left_bottom = [\n            self.styles.corner(corner) for corner in self.corners\n        ]\n\n        borders = [self.styles.border(char) for char in self.borders]\n\n        top = (\n            left_top\n            + (width - real_length(left_top + right_top)) * borders[1]\n            + right_top\n        )\n\n        bottom = (\n            left_bottom\n            + (width - real_length(left_bottom + right_bottom)) * borders[3]\n            + right_bottom\n        )\n\n        framed = []\n\n        if top != \"\":\n            framed.append(top)\n\n        for line in lines:\n            # TODO: Implement horizontal scrolling\n            framed.append(borders[0] + line + borders[2])\n\n        if bottom != \"\":\n            framed.append(bottom)\n\n        return framed\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frame.bottom_size","title":"<code>bottom_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the height of the bottom border.</p>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frame.left_size","title":"<code>left_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the length of the left border character.</p>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frame.right_size","title":"<code>right_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the length of the right border character.</p>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frame.top_size","title":"<code>top_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the height of the top border.</p>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frame.__call__","title":"<code>__call__(lines)</code>","text":"<p>Frames the given lines, handles scrolling when necessary.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>A list of lines to 'frame'. If there are too many lines, they are clipped according to the parent's <code>scroll</code> field.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Framed lines, clipped to the current scrolling settings.</p> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>def __call__(self, lines: list[str]) -&gt; list[str]:\n\"\"\"Frames the given lines, handles scrolling when necessary.\n\n    Args:\n        lines: A list of lines to 'frame'. If there are too many\n            lines, they are clipped according to the parent's\n            `scroll` field.\n\n    Returns:\n        Framed lines, clipped to the current scrolling settings.\n    \"\"\"\n\n    if len(self.borders) != 4 or len(self.corners) != 4:\n        raise ValueError(\"Cannot frame with no border or corner values.\")\n\n    scroll = self._parent.scroll\n\n    # TODO: Widget.size should substract frame size, once\n    #       it is aware of the frame.\n    # width, height = self._parent.size\n    width, height = self._parent.width, self._parent.height\n\n    lines = lines[scroll.vertical : scroll.vertical + height]\n\n    left_top, right_top, right_bottom, left_bottom = [\n        self.styles.corner(corner) for corner in self.corners\n    ]\n\n    borders = [self.styles.border(char) for char in self.borders]\n\n    top = (\n        left_top\n        + (width - real_length(left_top + right_top)) * borders[1]\n        + right_top\n    )\n\n    bottom = (\n        left_bottom\n        + (width - real_length(left_bottom + right_bottom)) * borders[3]\n        + right_bottom\n    )\n\n    framed = []\n\n    if top != \"\":\n        framed.append(top)\n\n    for line in lines:\n        # TODO: Implement horizontal scrolling\n        framed.append(borders[0] + line + borders[2])\n\n    if bottom != \"\":\n        framed.append(bottom)\n\n    return framed\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frame.__init__","title":"<code>__init__(parent)</code>","text":"<p>Initializes Frame.</p> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>def __init__(self, parent: Widget) -&gt; None:\n\"\"\"Initializes Frame.\"\"\"\n\n    self._parent = parent\n    self.styles = self.styles.branch(self._parent)\n\n    if self.descriptor is not None:\n        self._init_from_descriptor()\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frame.from_name","title":"<code>from_name(name)</code>  <code>staticmethod</code>","text":"<p>Gets a builtin Frame type from its name.</p> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>@staticmethod\ndef from_name(name: str) -&gt; Type[Frame]:\n\"\"\"Gets a builtin Frame type from its name.\"\"\"\n\n    if frame := globals().get(name):\n        return frame\n\n    raise ValueError(f\"No frame defined with name {name!r}.\")\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Frameless","title":"<code>Frameless</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame that is not. No frame will be drawn around the object.</p> <p>Preview:</p> <pre><code>x\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class Frameless(Frame):\n\"\"\"A frame that is not. No frame will be drawn around the object.\n\n    Preview:\n\n    ```\n\n    x\n\n    ```\n    \"\"\"\n\n    descriptor = [\n        \"\",\n        \"x\",\n        \"\",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Heavy","title":"<code>Heavy</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame with a heavy outline.</p> <p>Preview:</p> <pre><code>\u250f\u2501\u2501\u2501\u2513\n\u2503 x \u2503\n\u2517\u2501\u2501\u2501\u251b\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class Heavy(Frame):\n\"\"\"A frame with a heavy outline.\n\n    Preview:\n\n    ```\n    \u250f\u2501\u2501\u2501\u2513\n    \u2503 x \u2503\n    \u2517\u2501\u2501\u2501\u251b\n    ```\n    \"\"\"\n\n    descriptor = [\n        \"\u250f\u2501\u2501\u2501\u2513\",\n        \"\u2503 x \u2503\",\n        \"\u2517\u2501\u2501\u2501\u251b\",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Light","title":"<code>Light</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame with a light outline.</p> <p>Preview:</p> <pre><code>\u250c\u2500\u2500\u2500\u2510\n\u2502 x \u2502\n\u2514\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class Light(Frame):\n\"\"\"A frame with a light outline.\n\n    Preview:\n\n    ```\n    \u250c\u2500\u2500\u2500\u2510\n    \u2502 x \u2502\n    \u2514\u2500\u2500\u2500\u2518\n    ```\n    \"\"\"\n\n    descriptor = [\n        \"\u250c\u2500\u2500\u2500\u2510\",\n        \"\u2502 x \u2502\",\n        \"\u2514\u2500\u2500\u2500\u2518\",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Padded","title":"<code>Padded</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame that pads its content by a single space on all sides.</p> <p>Preview:</p> <pre><code>x\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class Padded(Frame):\n\"\"\"A frame that pads its content by a single space on all sides.\n\n    Preview:\n\n    ```\n    x\n    ```\n    \"\"\"\n\n    descriptor = [\n        \"   \",\n        \" x \",\n        \"   \",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/frames/#pytermgui.widgets.frames.Rounded","title":"<code>Rounded</code>","text":"<p>             Bases: <code>Frame</code></p> <p>A frame with a light outline and rounded corners.</p> <p>Preview:</p> <pre><code>\u256d\u2500\u2500\u2500\u256e\n\u2502 x \u2502\n\u2570\u2500\u2500\u2500\u256f\n</code></pre> Source code in <code>pytermgui/widgets/frames.py</code> <pre><code>class Rounded(Frame):\n\"\"\"A frame with a light outline and rounded corners.\n\n    Preview:\n\n    ```\n    \u256d\u2500\u2500\u2500\u256e\n    \u2502 x \u2502\n    \u2570\u2500\u2500\u2500\u256f\n    ```\n    \"\"\"\n\n    descriptor = [\n        \"\u256d\u2500\u2500\u2500\u256e\",\n        \"\u2502 x \u2502\",\n        \"\u2570\u2500\u2500\u2500\u256f\",\n    ]\n</code></pre>"},{"location":"reference/pytermgui/widgets/inline/","title":"inline","text":"<p>This module lets you run widgets as an inline terminal prompt.</p>"},{"location":"reference/pytermgui/widgets/inline/#pytermgui.widgets.inline.inline","title":"<code>inline(widget, *, exit_on=None, width=None)</code>","text":"<p>Runs a widget as an inline terminal prompt.</p> <p>This can be useful for adding GUI-like functionality within CLI scripts, as it gives you access to the widget system for building prompts, built in keyboard &amp; mouse handling and everything else that makes PyTermGUI's WindowManager work, without the commitment to a full-screen app.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>T</code> <p>Some widget that will be run.</p> required <code>width</code> <code>int | None</code> <p>The width to set for the widget. If nothing is given, the widget's width is unchanged.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The same widget. This allows defining and running a prompt in the same line:</p> <pre><code>prompt = inline(_build_prompt())\n</code></pre> Source code in <code>pytermgui/widgets/inline.py</code> <pre><code>def inline(\n    widget: T, *, exit_on: list[str] | None = None, width: int | None = None\n) -&gt; T:\n\"\"\"Runs a widget as an inline terminal prompt.\n\n    This can be useful for adding GUI-like functionality within CLI scripts, as it\n    gives you access to the widget system for building prompts, built in keyboard &amp;\n    mouse handling and everything else that makes PyTermGUI's WindowManager work,\n    without the commitment to a full-screen app.\n\n    Args:\n        widget: Some widget that will be run.\n        width: The width to set for the widget. If nothing is given, the widget's\n            width is unchanged.\n\n    Returns:\n        The same widget. This allows defining and running a prompt in the same line:\n\n            ```python\n            prompt = inline(_build_prompt())\n            ```\n    \"\"\"\n\n    # Make sure we use the global terminal\n    terminal = get_terminal()\n\n    unset_echo()\n    hide_cursor()\n\n    if width is not None:\n        widget.width = width\n\n    if exit_on is None:\n        exit_on = [keys.CTRL_C, keys.ENTER]\n\n    cursor = report_cursor()\n\n    if cursor is not None:\n        widget.pos = cursor\n\n    def _print_widget() -&gt; None:\n        save_cursor()\n\n        for line in widget.get_lines():\n            print(line)\n\n        for pos, line in widget.positioned_line_buffer:\n            print_to(pos, line)\n        widget.positioned_line_buffer = []\n\n        restore_cursor()\n\n    def _clear_widget() -&gt; None:\n        save_cursor()\n\n        for _ in range(widget.height):\n            clear(\"line\")\n            terminal.write(\"\\n\")\n\n        restore_cursor()\n        terminal.flush()\n\n    _print_widget()\n\n    with mouse_handler([\"press_hold\", \"hover\"], \"decimal_xterm\") as translate:\n        while True:\n            key = getch(interrupts=False)\n\n            if key in exit_on:\n                break\n\n            if not widget.handle_key(key):\n                events = translate(key)\n                # Don't try iterating when there are no events\n                if events is None:\n                    continue\n\n                for event in events:\n                    if event is None:\n                        continue\n                    widget.handle_mouse(event)\n\n            _clear_widget()\n            _print_widget()\n\n    _clear_widget()\n\n    set_echo()\n    show_cursor()\n\n    return widget\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/","title":"input_field","text":"<p>This module contains the <code>InputField</code> class.</p>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.Cursor","title":"<code>Cursor</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Iterable</code></p> <p>A simple dataclass representing the InputField's cursor.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>@dataclass\nclass Cursor(Iterable):\n\"\"\"A simple dataclass representing the InputField's cursor.\"\"\"\n\n    row: int\n    col: int\n\n    def __iadd__(self, difference: tuple[int, int]) -&gt; Cursor:\n\"\"\"Move the cursor by the difference.\"\"\"\n\n        row, col = difference\n\n        self.row += row\n        self.col += col\n\n        return self\n\n    def __iter__(self) -&gt; Iterator[int]:\n        return iter((self.row, self.col))\n\n    def __len__(self) -&gt; int:\n        return 2\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.Cursor.__iadd__","title":"<code>__iadd__(difference)</code>","text":"<p>Move the cursor by the difference.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def __iadd__(self, difference: tuple[int, int]) -&gt; Cursor:\n\"\"\"Move the cursor by the difference.\"\"\"\n\n    row, col = difference\n\n    self.row += row\n    self.col += col\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField","title":"<code>InputField</code>","text":"<p>             Bases: <code>Widget</code></p> <p>An element to display user input</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>class InputField(Widget):  # pylint: disable=too-many-instance-attributes\n\"\"\"An element to display user input\"\"\"\n\n    styles = w_styles.StyleManager(\n        value=\"\",\n        prompt=\"surface+2\",\n        cursor=\"@primary dim #auto\",\n    )\n\n    keys = {\n        \"move_left\": {keys.LEFT},\n        \"move_right\": {keys.RIGHT},\n        \"move_word_left\": {keys.ALT_LEFT, keys.CTRL_LEFT},\n        \"move_word_right\": {keys.ALT_RIGHT, keys.CTRL_RIGHT},\n        \"move_up\": {keys.UP},\n        \"move_down\": {keys.DOWN},\n        \"move_end\": {keys.END},\n        \"move_home\": {keys.HOME},\n        \"select_left\": {keys.SHIFT_LEFT},\n        \"select_right\": {keys.SHIFT_RIGHT},\n        \"select_up\": {keys.SHIFT_UP},\n        \"select_down\": {keys.SHIFT_DOWN},\n        \"word_remove\": {keys.ALT_BACKSPACE, keys.CTRL_BACKSPACE},\n    }\n\n    parent_align = HorizontalAlignment.LEFT\n\n    def __init__(\n        self,\n        value: str = \"\",\n        *,\n        prompt: str = \"\",\n        tablength: int = 4,\n        multiline: bool = False,\n        cursor: Cursor | None = None,\n        **attrs: Any,\n    ) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n        super().__init__(**attrs)\n\n        if \"width\" not in attrs:\n            self.width = len(value)\n\n        self.prompt = prompt\n        self.height = 1\n        self.tablength = tablength\n        self.multiline = multiline\n\n        self.cursor = cursor or Cursor(0, len(value))\n\n        self._lines = value.splitlines() or [\"\"]\n        self._selection_length = 1\n\n        self._styled_cache: list[str] | None = self._style_and_break_lines()\n\n        self._cached_state: int = self.width\n        self._drag_start: tuple[int, int] | None = None\n\n    @property\n    def selectables_length(self) -&gt; int:\n\"\"\"Get length of selectables in object\"\"\"\n\n        return 1\n\n    @property\n    def value(self) -&gt; str:\n\"\"\"Returns the internal value of this field.\"\"\"\n\n        return \"\\n\".join(self._lines)\n\n    @property\n    def selection(self) -&gt; str:\n\"\"\"Returns the currently selected span of text.\"\"\"\n\n        start, end = sorted([self.cursor.col, self.cursor.col + self._selection_length])\n        return self._lines[self.cursor.row][start:end]\n\n    def _cache_is_valid(self) -&gt; bool:\n\"\"\"Determines if the styled line cache is still usable.\"\"\"\n\n        return self.width == self._cached_state\n\n    def _style_and_break_lines(self) -&gt; list[str]:\n\"\"\"Styles and breaks self._lines.\"\"\"\n\n        document = (\n            self.styles.prompt(self.prompt) + self.styles.value(self.value)\n        ).splitlines()\n\n        lines: list[str] = []\n        width = self.width\n        extend = lines.extend\n\n        for line in document:\n            extend(break_line(line.replace(\"\\n\", \"\\\\n\"), width, fill=\" \"))\n            extend(\"\")\n\n        return lines\n\n    def update_selection(self, count: int, correct_zero_length: bool = True) -&gt; None:\n\"\"\"Updates the selection state.\n\n        Args:\n            count: How many characters the cursor should change by. Negative for\n                selecting leftward, positive for right.\n            correct_zero_length: If set, when the selection length is 0 both the cursor\n                and the selection length are manipulated to keep the original selection\n                start while moving the selection in more of the way the user might\n                expect.\n        \"\"\"\n\n        self._selection_length += count\n\n        if correct_zero_length and abs(self._selection_length) == 0:\n            self._selection_length += 2 if count &gt; 0 else -2\n            self.move_cursor((0, (-1 if count &gt; 0 else 1)))\n\n    def delete_back(self, count: int = 1) -&gt; str:\n\"\"\"Deletes `count` characters from the cursor, backwards.\n\n        Args:\n            count: How many characters should be deleted.\n\n        Returns:\n            The deleted string.\n        \"\"\"\n\n        row, col = self.cursor\n\n        if len(self._lines) &lt;= row:\n            return \"\"\n\n        line = self._lines[row]\n\n        start, end = sorted([col, col - count])\n        start = max(0, start)\n        self._lines[row] = line[:start] + line[end:]\n\n        self._styled_cache = None\n\n        if self._lines[row] == \"\":\n            self.move_cursor((0, -2))\n\n            return self._lines.pop(row)\n\n        if count &gt; 0:\n            self.move_cursor((0, -count))\n\n        return line[col - count : col]\n\n    def insert_text(self, text: str) -&gt; None:\n\"\"\"Inserts text at the cursor location.\"\"\"\n\n        row, col = self.cursor\n\n        if len(self._lines) &lt;= row:\n            self._lines.insert(row, \"\")\n\n        line = self._lines[row]\n\n        self._lines[row] = line[:col] + text + line[col:]\n        self.move_cursor((0, len(text)))\n\n        self._styled_cache = None\n\n    def get_word_pos(self, direction: Literal[-1, 1]) -&gt; int:\n\"\"\"Gets the column offset to the next word in the given direction.\n\n        Args:\n            direction: Which direction we need to look for.\n\n        Returns:\n            The column offset.\n        \"\"\"\n\n        row, col = self.cursor\n        if len(self._lines) &lt;= row:\n            return direction\n\n        # Consistent with unix shell behaviour:\n        # * Always delete first char, then remove any non-punctuation\n        # Note that the exact behaviour isn't standardized:\n        # * Python repl: until change in letter+digit &amp; punctionation\n        # * Unix shells: only removes letter+digit\n        word_chars = string.ascii_letters + string.digits\n\n        if direction == -1:\n            line = self._lines[row][: col - 1]\n            strip_line = line.rstrip(word_chars)\n\n        else:\n            line = self._lines[row][col:]\n            strip_line = line.lstrip(word_chars)\n\n        return -direction * (len(strip_line) - len(line)) + direction\n\n    def handle_action(self, action: str) -&gt; bool:\n\"\"\"Handles some action.\n\n        This will be expanded in the future to allow using all behaviours with\n        just their actions.\n        \"\"\"\n\n        cursors = {\n            \"move_left\": (0, -1),\n            \"move_right\": (0, 1),\n            \"move_up\": (-1, 0),\n            \"move_down\": (1, 0),\n        }\n\n        if action.startswith(\"move_\"):\n            if action.endswith((\"word_left\", \"word_right\")):\n                col = self.get_word_pos(-1 if action == \"move_word_left\" else 1)\n                self.move_cursor((0, col))\n                return True\n\n            if action.endswith((\"end\", \"home\")):\n                crow, ccol = self.cursor\n                if action == \"move_end\":\n                    ccol = len(self._lines[crow])\n                else:\n                    ccol = 0\n                self.move_cursor((crow, ccol), absolute=True)\n                return True\n\n            row, col = cursors[action]\n\n            if self.cursor.row + row &gt; len(self._lines):\n                self._lines.append(\"\")\n\n            col += self._selection_length\n            if self._selection_length &gt; 0:\n                col -= 1\n\n            self._selection_length = 1\n            self.move_cursor((row, col))\n            return True\n\n        if action.startswith(\"select_\"):\n            if action == \"select_right\":\n                self.update_selection(1)\n\n            elif action == \"select_left\":\n                self.update_selection(-1)\n\n            return True\n\n        if action == \"word_remove\":\n            row, col = self.cursor\n            self.delete_back(-self.get_word_pos(-1))\n            return True\n\n        return False\n\n    # TODO: This could probably be simplified by a wider adoption of the action pattern.\n    def handle_key(  # pylint: disable=too-many-return-statements, too-many-branches\n        self, key: str\n    ) -&gt; bool:\n\"\"\"Adds text to the field, or moves the cursor.\"\"\"\n\n        if self.execute_binding(key, ignore_any=True):\n            return True\n\n        for name, options in self.keys.items():\n            if (\n                name.rsplit(\"_\", maxsplit=1)[-1] in (\"up\", \"down\")\n                and not self.multiline\n            ):\n                continue\n\n            if key in options:\n                return self.handle_action(name)\n\n        if key == keys.TAB:\n            if not self.multiline:\n                return False\n\n            for _ in range(self.tablength):\n                self.handle_key(\" \")\n\n            return True\n\n        if key in string.printable and key not in \"\\x0c\\x0b\":\n            if key == keys.ENTER:\n                if not self.multiline:\n                    return False\n\n                if len(self._lines) &lt;= self.cursor.row:\n                    self._lines.append(\"\")\n\n                line = self._lines[self.cursor.row]\n                left, right = line[: self.cursor.col], line[self.cursor.col :]\n\n                self._lines[self.cursor.row] = left\n                self._lines.insert(self.cursor.row + 1, right)\n\n                self.move_cursor((1, -self.cursor.col))\n                self._styled_cache = None\n\n            else:\n                self.insert_text(key)\n\n            if keys.ANY_KEY in self._bindings:\n                method, _ = self._bindings[keys.ANY_KEY]\n                method(self, key)\n\n            return True\n\n        if key == keys.BACKSPACE:\n            if self._selection_length == 1:\n                self.delete_back(1)\n            else:\n                self.delete_back(-self._selection_length)\n\n            self._selection_length = 1\n            self._styled_cache = None\n\n            return True\n\n        if len(key) &gt; 1 and not key.startswith(\"\\x1b[\"):\n            for char in key:\n                self.handle_key(char)\n\n            return True\n\n        return False\n\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Allows point-and-click selection.\"\"\"\n\n        x_offset = event.position[0] - self.pos[0]\n        y_offset = event.position[1] - self.pos[1]\n\n        if y_offset == 0:\n            x_offset -= len(self.prompt)\n\n            if x_offset &lt; 0:\n                return False\n\n        # Set cursor to mouse location\n        if event.action is MouseAction.LEFT_CLICK:\n            if not y_offset &lt; len(self._lines):\n                return False\n\n            line = self._lines[y_offset]\n\n            if y_offset == 0:\n                line = self.prompt + line\n\n            self.move_cursor((y_offset, min(len(line), x_offset)), absolute=True)\n\n            self._drag_start = (x_offset, y_offset)\n            self._selection_length = 1\n\n            return True\n\n        # Select text using dragging the mouse\n        if event.action is MouseAction.LEFT_DRAG and self._drag_start is not None:\n            change = x_offset - self._drag_start[0]\n            self.update_selection(\n                change - self._selection_length + 1, correct_zero_length=False\n            )\n\n            return True\n\n        return super().handle_mouse(event)\n\n    def move_cursor(self, new: tuple[int, int], *, absolute: bool = False) -&gt; None:\n\"\"\"Moves the cursor, then possible re-positions it to a valid location.\n\n        Args:\n            new: The new set of (y, x) positions to use.\n            absolute: If set, `new` will be interpreted as absolute coordinates,\n                instead of being added on top of the current ones.\n        \"\"\"\n\n        if len(self._lines) == 0:\n            return\n\n        if absolute:\n            new_y, new_x = new\n            self.cursor.row = new_y\n            self.cursor.col = new_x\n\n        else:\n            self.cursor += new\n\n        self.cursor.row = max(0, min(self.cursor.row, len(self._lines) - 1))\n        row, col = self.cursor\n\n        line = self._lines[row]\n\n        # Going left, possibly upwards\n        if col &lt; 0:\n            if row &lt;= 0:\n                self.cursor.col = 0\n\n            else:\n                self.cursor.row -= 1\n                line = self._lines[self.cursor.row]\n                self.cursor.col = len(line)\n\n        # Going right, possibly downwards\n        elif col &gt; len(line) and line != \"\":\n            if len(self._lines) &gt; row + 1:\n                self.cursor.row += 1\n                self.cursor.col = 0\n\n            line = self._lines[self.cursor.row]\n\n        self.cursor.col = max(0, min(self.cursor.col, len(line)))\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Builds the input field's lines.\"\"\"\n\n        if not self._cache_is_valid() or self._styled_cache is None:\n            self._styled_cache = self._style_and_break_lines()\n\n        lines = self._styled_cache\n\n        row, col = self.cursor\n\n        if len(self._lines) == 0:\n            line = \" \"\n        else:\n            line = self._lines[row]\n\n        start = col\n        cursor_char = \" \"\n        if len(line) &gt; col:\n            start = col\n            end = col + self._selection_length\n            start, end = sorted([start, end])\n\n            try:\n                cursor_char = line[start:end]\n            except IndexError as error:\n                raise ValueError(f\"Invalid index in {line!r}: {col}\") from error\n\n        style_cursor = (\n            self.styles.value if self.selected_index is None else self.styles.cursor\n        )\n\n        # TODO: This is horribly hackish, but is the only way to \"get around\" the\n        #       limits of the current scrolling techniques. Should be refactored\n        #       once a better solution is available\n        if self.parent is not None and self.selected_index is not None:\n            offset = 0\n            parent = self.parent\n            while hasattr(parent, \"parent\"):\n                offset += getattr(parent, \"_scroll_offset\")\n\n                parent = parent.parent  # type: ignore\n\n            offset_row = -offset + row\n            offset_col = start + (len(self.prompt) if row == 0 else 0)\n\n            if offset_col &gt; self.width - 1:\n                offset_col -= self.width\n                offset_row += 1\n                row += 1\n\n                if row &gt;= len(lines):\n                    lines.append(self.styles.value(\"\"))\n\n            position = (\n                self.pos[0] + offset_col,\n                self.pos[1] + offset_row,\n            )\n\n            self.positioned_line_buffer.append(\n                (position, style_cursor(cursor_char))  # type: ignore\n            )\n\n        lines = lines or [\"\"]\n        self.height = len(lines)\n\n        return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.selectables_length","title":"<code>selectables_length: int</code>  <code>property</code>","text":"<p>Get length of selectables in object</p>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.selection","title":"<code>selection: str</code>  <code>property</code>","text":"<p>Returns the currently selected span of text.</p>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.value","title":"<code>value: str</code>  <code>property</code>","text":"<p>Returns the internal value of this field.</p>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.__init__","title":"<code>__init__(value='', *, prompt='', tablength=4, multiline=False, cursor=None, **attrs)</code>","text":"<p>Initialize object</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def __init__(\n    self,\n    value: str = \"\",\n    *,\n    prompt: str = \"\",\n    tablength: int = 4,\n    multiline: bool = False,\n    cursor: Cursor | None = None,\n    **attrs: Any,\n) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n    super().__init__(**attrs)\n\n    if \"width\" not in attrs:\n        self.width = len(value)\n\n    self.prompt = prompt\n    self.height = 1\n    self.tablength = tablength\n    self.multiline = multiline\n\n    self.cursor = cursor or Cursor(0, len(value))\n\n    self._lines = value.splitlines() or [\"\"]\n    self._selection_length = 1\n\n    self._styled_cache: list[str] | None = self._style_and_break_lines()\n\n    self._cached_state: int = self.width\n    self._drag_start: tuple[int, int] | None = None\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.delete_back","title":"<code>delete_back(count=1)</code>","text":"<p>Deletes <code>count</code> characters from the cursor, backwards.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>How many characters should be deleted.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The deleted string.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def delete_back(self, count: int = 1) -&gt; str:\n\"\"\"Deletes `count` characters from the cursor, backwards.\n\n    Args:\n        count: How many characters should be deleted.\n\n    Returns:\n        The deleted string.\n    \"\"\"\n\n    row, col = self.cursor\n\n    if len(self._lines) &lt;= row:\n        return \"\"\n\n    line = self._lines[row]\n\n    start, end = sorted([col, col - count])\n    start = max(0, start)\n    self._lines[row] = line[:start] + line[end:]\n\n    self._styled_cache = None\n\n    if self._lines[row] == \"\":\n        self.move_cursor((0, -2))\n\n        return self._lines.pop(row)\n\n    if count &gt; 0:\n        self.move_cursor((0, -count))\n\n    return line[col - count : col]\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.get_lines","title":"<code>get_lines()</code>","text":"<p>Builds the input field's lines.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Builds the input field's lines.\"\"\"\n\n    if not self._cache_is_valid() or self._styled_cache is None:\n        self._styled_cache = self._style_and_break_lines()\n\n    lines = self._styled_cache\n\n    row, col = self.cursor\n\n    if len(self._lines) == 0:\n        line = \" \"\n    else:\n        line = self._lines[row]\n\n    start = col\n    cursor_char = \" \"\n    if len(line) &gt; col:\n        start = col\n        end = col + self._selection_length\n        start, end = sorted([start, end])\n\n        try:\n            cursor_char = line[start:end]\n        except IndexError as error:\n            raise ValueError(f\"Invalid index in {line!r}: {col}\") from error\n\n    style_cursor = (\n        self.styles.value if self.selected_index is None else self.styles.cursor\n    )\n\n    # TODO: This is horribly hackish, but is the only way to \"get around\" the\n    #       limits of the current scrolling techniques. Should be refactored\n    #       once a better solution is available\n    if self.parent is not None and self.selected_index is not None:\n        offset = 0\n        parent = self.parent\n        while hasattr(parent, \"parent\"):\n            offset += getattr(parent, \"_scroll_offset\")\n\n            parent = parent.parent  # type: ignore\n\n        offset_row = -offset + row\n        offset_col = start + (len(self.prompt) if row == 0 else 0)\n\n        if offset_col &gt; self.width - 1:\n            offset_col -= self.width\n            offset_row += 1\n            row += 1\n\n            if row &gt;= len(lines):\n                lines.append(self.styles.value(\"\"))\n\n        position = (\n            self.pos[0] + offset_col,\n            self.pos[1] + offset_row,\n        )\n\n        self.positioned_line_buffer.append(\n            (position, style_cursor(cursor_char))  # type: ignore\n        )\n\n    lines = lines or [\"\"]\n    self.height = len(lines)\n\n    return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.get_word_pos","title":"<code>get_word_pos(direction)</code>","text":"<p>Gets the column offset to the next word in the given direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>Literal[-1, 1]</code> <p>Which direction we need to look for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The column offset.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def get_word_pos(self, direction: Literal[-1, 1]) -&gt; int:\n\"\"\"Gets the column offset to the next word in the given direction.\n\n    Args:\n        direction: Which direction we need to look for.\n\n    Returns:\n        The column offset.\n    \"\"\"\n\n    row, col = self.cursor\n    if len(self._lines) &lt;= row:\n        return direction\n\n    # Consistent with unix shell behaviour:\n    # * Always delete first char, then remove any non-punctuation\n    # Note that the exact behaviour isn't standardized:\n    # * Python repl: until change in letter+digit &amp; punctionation\n    # * Unix shells: only removes letter+digit\n    word_chars = string.ascii_letters + string.digits\n\n    if direction == -1:\n        line = self._lines[row][: col - 1]\n        strip_line = line.rstrip(word_chars)\n\n    else:\n        line = self._lines[row][col:]\n        strip_line = line.lstrip(word_chars)\n\n    return -direction * (len(strip_line) - len(line)) + direction\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.handle_action","title":"<code>handle_action(action)</code>","text":"<p>Handles some action.</p> <p>This will be expanded in the future to allow using all behaviours with just their actions.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def handle_action(self, action: str) -&gt; bool:\n\"\"\"Handles some action.\n\n    This will be expanded in the future to allow using all behaviours with\n    just their actions.\n    \"\"\"\n\n    cursors = {\n        \"move_left\": (0, -1),\n        \"move_right\": (0, 1),\n        \"move_up\": (-1, 0),\n        \"move_down\": (1, 0),\n    }\n\n    if action.startswith(\"move_\"):\n        if action.endswith((\"word_left\", \"word_right\")):\n            col = self.get_word_pos(-1 if action == \"move_word_left\" else 1)\n            self.move_cursor((0, col))\n            return True\n\n        if action.endswith((\"end\", \"home\")):\n            crow, ccol = self.cursor\n            if action == \"move_end\":\n                ccol = len(self._lines[crow])\n            else:\n                ccol = 0\n            self.move_cursor((crow, ccol), absolute=True)\n            return True\n\n        row, col = cursors[action]\n\n        if self.cursor.row + row &gt; len(self._lines):\n            self._lines.append(\"\")\n\n        col += self._selection_length\n        if self._selection_length &gt; 0:\n            col -= 1\n\n        self._selection_length = 1\n        self.move_cursor((row, col))\n        return True\n\n    if action.startswith(\"select_\"):\n        if action == \"select_right\":\n            self.update_selection(1)\n\n        elif action == \"select_left\":\n            self.update_selection(-1)\n\n        return True\n\n    if action == \"word_remove\":\n        row, col = self.cursor\n        self.delete_back(-self.get_word_pos(-1))\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.handle_key","title":"<code>handle_key(key)</code>","text":"<p>Adds text to the field, or moves the cursor.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def handle_key(  # pylint: disable=too-many-return-statements, too-many-branches\n    self, key: str\n) -&gt; bool:\n\"\"\"Adds text to the field, or moves the cursor.\"\"\"\n\n    if self.execute_binding(key, ignore_any=True):\n        return True\n\n    for name, options in self.keys.items():\n        if (\n            name.rsplit(\"_\", maxsplit=1)[-1] in (\"up\", \"down\")\n            and not self.multiline\n        ):\n            continue\n\n        if key in options:\n            return self.handle_action(name)\n\n    if key == keys.TAB:\n        if not self.multiline:\n            return False\n\n        for _ in range(self.tablength):\n            self.handle_key(\" \")\n\n        return True\n\n    if key in string.printable and key not in \"\\x0c\\x0b\":\n        if key == keys.ENTER:\n            if not self.multiline:\n                return False\n\n            if len(self._lines) &lt;= self.cursor.row:\n                self._lines.append(\"\")\n\n            line = self._lines[self.cursor.row]\n            left, right = line[: self.cursor.col], line[self.cursor.col :]\n\n            self._lines[self.cursor.row] = left\n            self._lines.insert(self.cursor.row + 1, right)\n\n            self.move_cursor((1, -self.cursor.col))\n            self._styled_cache = None\n\n        else:\n            self.insert_text(key)\n\n        if keys.ANY_KEY in self._bindings:\n            method, _ = self._bindings[keys.ANY_KEY]\n            method(self, key)\n\n        return True\n\n    if key == keys.BACKSPACE:\n        if self._selection_length == 1:\n            self.delete_back(1)\n        else:\n            self.delete_back(-self._selection_length)\n\n        self._selection_length = 1\n        self._styled_cache = None\n\n        return True\n\n    if len(key) &gt; 1 and not key.startswith(\"\\x1b[\"):\n        for char in key:\n            self.handle_key(char)\n\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.handle_mouse","title":"<code>handle_mouse(event)</code>","text":"<p>Allows point-and-click selection.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Allows point-and-click selection.\"\"\"\n\n    x_offset = event.position[0] - self.pos[0]\n    y_offset = event.position[1] - self.pos[1]\n\n    if y_offset == 0:\n        x_offset -= len(self.prompt)\n\n        if x_offset &lt; 0:\n            return False\n\n    # Set cursor to mouse location\n    if event.action is MouseAction.LEFT_CLICK:\n        if not y_offset &lt; len(self._lines):\n            return False\n\n        line = self._lines[y_offset]\n\n        if y_offset == 0:\n            line = self.prompt + line\n\n        self.move_cursor((y_offset, min(len(line), x_offset)), absolute=True)\n\n        self._drag_start = (x_offset, y_offset)\n        self._selection_length = 1\n\n        return True\n\n    # Select text using dragging the mouse\n    if event.action is MouseAction.LEFT_DRAG and self._drag_start is not None:\n        change = x_offset - self._drag_start[0]\n        self.update_selection(\n            change - self._selection_length + 1, correct_zero_length=False\n        )\n\n        return True\n\n    return super().handle_mouse(event)\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.insert_text","title":"<code>insert_text(text)</code>","text":"<p>Inserts text at the cursor location.</p> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def insert_text(self, text: str) -&gt; None:\n\"\"\"Inserts text at the cursor location.\"\"\"\n\n    row, col = self.cursor\n\n    if len(self._lines) &lt;= row:\n        self._lines.insert(row, \"\")\n\n    line = self._lines[row]\n\n    self._lines[row] = line[:col] + text + line[col:]\n    self.move_cursor((0, len(text)))\n\n    self._styled_cache = None\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.move_cursor","title":"<code>move_cursor(new, *, absolute=False)</code>","text":"<p>Moves the cursor, then possible re-positions it to a valid location.</p> <p>Parameters:</p> Name Type Description Default <code>new</code> <code>tuple[int, int]</code> <p>The new set of (y, x) positions to use.</p> required <code>absolute</code> <code>bool</code> <p>If set, <code>new</code> will be interpreted as absolute coordinates, instead of being added on top of the current ones.</p> <code>False</code> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def move_cursor(self, new: tuple[int, int], *, absolute: bool = False) -&gt; None:\n\"\"\"Moves the cursor, then possible re-positions it to a valid location.\n\n    Args:\n        new: The new set of (y, x) positions to use.\n        absolute: If set, `new` will be interpreted as absolute coordinates,\n            instead of being added on top of the current ones.\n    \"\"\"\n\n    if len(self._lines) == 0:\n        return\n\n    if absolute:\n        new_y, new_x = new\n        self.cursor.row = new_y\n        self.cursor.col = new_x\n\n    else:\n        self.cursor += new\n\n    self.cursor.row = max(0, min(self.cursor.row, len(self._lines) - 1))\n    row, col = self.cursor\n\n    line = self._lines[row]\n\n    # Going left, possibly upwards\n    if col &lt; 0:\n        if row &lt;= 0:\n            self.cursor.col = 0\n\n        else:\n            self.cursor.row -= 1\n            line = self._lines[self.cursor.row]\n            self.cursor.col = len(line)\n\n    # Going right, possibly downwards\n    elif col &gt; len(line) and line != \"\":\n        if len(self._lines) &gt; row + 1:\n            self.cursor.row += 1\n            self.cursor.col = 0\n\n        line = self._lines[self.cursor.row]\n\n    self.cursor.col = max(0, min(self.cursor.col, len(line)))\n</code></pre>"},{"location":"reference/pytermgui/widgets/input_field/#pytermgui.widgets.input_field.InputField.update_selection","title":"<code>update_selection(count, correct_zero_length=True)</code>","text":"<p>Updates the selection state.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>How many characters the cursor should change by. Negative for selecting leftward, positive for right.</p> required <code>correct_zero_length</code> <code>bool</code> <p>If set, when the selection length is 0 both the cursor and the selection length are manipulated to keep the original selection start while moving the selection in more of the way the user might expect.</p> <code>True</code> Source code in <code>pytermgui/widgets/input_field.py</code> <pre><code>def update_selection(self, count: int, correct_zero_length: bool = True) -&gt; None:\n\"\"\"Updates the selection state.\n\n    Args:\n        count: How many characters the cursor should change by. Negative for\n            selecting leftward, positive for right.\n        correct_zero_length: If set, when the selection length is 0 both the cursor\n            and the selection length are manipulated to keep the original selection\n            start while moving the selection in more of the way the user might\n            expect.\n    \"\"\"\n\n    self._selection_length += count\n\n    if correct_zero_length and abs(self._selection_length) == 0:\n        self._selection_length += 2 if count &gt; 0 else -2\n        self.move_cursor((0, (-1 if count &gt; 0 else 1)))\n</code></pre>"},{"location":"reference/pytermgui/widgets/keyboard_button/","title":"keyboard_button","text":"<p>This module provides a keyboard-accessible button.</p>"},{"location":"reference/pytermgui/widgets/keyboard_button/#pytermgui.widgets.keyboard_button.KeyboardButton","title":"<code>KeyboardButton</code>","text":"<p>             Bases: <code>Button</code></p> <p>A button with keyboard mnemonics in mind.</p> Shoutout to the HackerNews thread where this was originally suggested <p>https://news.ycombinator.com/item?id=30517299#30533444</p> Source code in <code>pytermgui/widgets/keyboard_button.py</code> <pre><code>class KeyboardButton(Button):\n\"\"\"A button with keyboard mnemonics in mind.\n\n    Shoutout to the HackerNews thread where this was originally suggested:\n        https://news.ycombinator.com/item?id=30517299#30533444\n    \"\"\"\n\n    chars = {**Button.chars, **{\"bracket\": [\"(\", \")\"]}}\n\n    is_bindable = True\n\n    def __init__(\n        self,\n        label: str,\n        onclick: Callable[[Button], Any],\n        index: int = 0,\n        bound: str | None = None,\n    ) -&gt; None:\n\"\"\"Initializes a KeyboardButton.\n\n        For example, `KeyboardButton(\"Help\")` will look like: \"[ (H)elp ]\", and\n        `KeyboardButton(\"Test\", index=1)` will give \"[ T(e)st ]\"\n\n        Args:\n            label: The label of the button.\n            onclick: The callback to be executed when the button is activated.\n            index: The index of the label to use as the binding character.\n            bound: The keybind that activates this button. Defaults to `keys.CTRL_{char}`\n                is used as the default binding.\n        \"\"\"\n\n        if bound is None:\n            bound = getattr(keys, \"CTRL_\" + label[index].upper())\n\n        brackets = \"{}\".join(self._get_char(\"bracket\"))\n        original = label\n        label = label[:index] + brackets.format(label[index])\n\n        if index &gt; -1:\n            label += original[index + 1 :]\n\n        super().__init__(label, onclick)\n        self.bind(bound, lambda btn, _: onclick(btn))\n</code></pre>"},{"location":"reference/pytermgui/widgets/keyboard_button/#pytermgui.widgets.keyboard_button.KeyboardButton.__init__","title":"<code>__init__(label, onclick, index=0, bound=None)</code>","text":"<p>Initializes a KeyboardButton.</p> <p>For example, <code>KeyboardButton(\"Help\")</code> will look like: \"[ (H)elp ]\", and <code>KeyboardButton(\"Test\", index=1)</code> will give \"[ T(e)st ]\"</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the button.</p> required <code>onclick</code> <code>Callable[[Button], Any]</code> <p>The callback to be executed when the button is activated.</p> required <code>index</code> <code>int</code> <p>The index of the label to use as the binding character.</p> <code>0</code> <code>bound</code> <code>str | None</code> <p>The keybind that activates this button. Defaults to <code>keys.CTRL_{char}</code> is used as the default binding.</p> <code>None</code> Source code in <code>pytermgui/widgets/keyboard_button.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    onclick: Callable[[Button], Any],\n    index: int = 0,\n    bound: str | None = None,\n) -&gt; None:\n\"\"\"Initializes a KeyboardButton.\n\n    For example, `KeyboardButton(\"Help\")` will look like: \"[ (H)elp ]\", and\n    `KeyboardButton(\"Test\", index=1)` will give \"[ T(e)st ]\"\n\n    Args:\n        label: The label of the button.\n        onclick: The callback to be executed when the button is activated.\n        index: The index of the label to use as the binding character.\n        bound: The keybind that activates this button. Defaults to `keys.CTRL_{char}`\n            is used as the default binding.\n    \"\"\"\n\n    if bound is None:\n        bound = getattr(keys, \"CTRL_\" + label[index].upper())\n\n    brackets = \"{}\".join(self._get_char(\"bracket\"))\n    original = label\n    label = label[:index] + brackets.format(label[index])\n\n    if index &gt; -1:\n        label += original[index + 1 :]\n\n    super().__init__(label, onclick)\n    self.bind(bound, lambda btn, _: onclick(btn))\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/","title":"pixel_matrix","text":"<p>The module containing all the widgets that can be used to display pixel-based data.</p>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.DensePixelMatrix","title":"<code>DensePixelMatrix</code>","text":"<p>             Bases: <code>PixelMatrix</code></p> <p>A more dense (2x) PixelMatrix.</p> <p>Due to each pixel only occupying 1/2 characters in height, accurately determining selected_pixel is impossible, thus the functionality does not exist here.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>class DensePixelMatrix(PixelMatrix):\n\"\"\"A more dense (2x) PixelMatrix.\n\n    Due to each pixel only occupying 1/2 characters in height, accurately\n    determining selected_pixel is impossible, thus the functionality does\n    not exist here.\n    \"\"\"\n\n    def __init__(self, width: int, height: int, default: str = \"\", **attrs) -&gt; None:\n\"\"\"Initializes DensePixelMatrix.\n\n        Args:\n            width: The width of the matrix.\n            height: The height of the matrix.\n            default: The default color to use to initialize the matrix with.\n        \"\"\"\n\n        super().__init__(width, height, default, **attrs)\n\n        self.width = width // 2\n\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"As mentioned in the class documentation, mouse handling is disabled here.\"\"\"\n\n        return False\n\n    def build(self) -&gt; list[str]:\n\"\"\"Builds the image pixels, using half-block characters.\n\n        Returns:\n            The lines that this object will return, until a subsequent `build` call.\n            These lines are stored in the `self._lines` variable.\n        \"\"\"\n\n        lines = []\n        lines_to_zip: list[list[str]] = []\n        for row in self._matrix:\n            lines_to_zip.append(row)\n            if len(lines_to_zip) != 2:\n                continue\n\n            line = \"\"\n            top_row, bottom_row = lines_to_zip[0], lines_to_zip[1]\n            for bottom, top in zip(bottom_row, top_row):\n                if len(top) + len(bottom) == 0:\n                    line += \" \"\n                    continue\n\n                if bottom == \"\":\n                    line += tim.parse(f\"[{top}]\u2580\")\n                    continue\n\n                markup_str = \"@\" + top + \" \" if len(top) &gt; 0 else \"\"\n\n                markup_str += bottom\n                line += tim.parse(f\"[{markup_str}]\u2584\")\n\n            lines.append(line)\n            lines_to_zip = []\n\n        self._lines = lines\n        self._update_dimensions(lines)\n\n        return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.DensePixelMatrix.__init__","title":"<code>__init__(width, height, default='', **attrs)</code>","text":"<p>Initializes DensePixelMatrix.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the matrix.</p> required <code>height</code> <code>int</code> <p>The height of the matrix.</p> required <code>default</code> <code>str</code> <p>The default color to use to initialize the matrix with.</p> <code>''</code> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def __init__(self, width: int, height: int, default: str = \"\", **attrs) -&gt; None:\n\"\"\"Initializes DensePixelMatrix.\n\n    Args:\n        width: The width of the matrix.\n        height: The height of the matrix.\n        default: The default color to use to initialize the matrix with.\n    \"\"\"\n\n    super().__init__(width, height, default, **attrs)\n\n    self.width = width // 2\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.DensePixelMatrix.build","title":"<code>build()</code>","text":"<p>Builds the image pixels, using half-block characters.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>The lines that this object will return, until a subsequent <code>build</code> call.</p> <code>list[str]</code> <p>These lines are stored in the <code>self._lines</code> variable.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def build(self) -&gt; list[str]:\n\"\"\"Builds the image pixels, using half-block characters.\n\n    Returns:\n        The lines that this object will return, until a subsequent `build` call.\n        These lines are stored in the `self._lines` variable.\n    \"\"\"\n\n    lines = []\n    lines_to_zip: list[list[str]] = []\n    for row in self._matrix:\n        lines_to_zip.append(row)\n        if len(lines_to_zip) != 2:\n            continue\n\n        line = \"\"\n        top_row, bottom_row = lines_to_zip[0], lines_to_zip[1]\n        for bottom, top in zip(bottom_row, top_row):\n            if len(top) + len(bottom) == 0:\n                line += \" \"\n                continue\n\n            if bottom == \"\":\n                line += tim.parse(f\"[{top}]\u2580\")\n                continue\n\n            markup_str = \"@\" + top + \" \" if len(top) &gt; 0 else \"\"\n\n            markup_str += bottom\n            line += tim.parse(f\"[{markup_str}]\u2584\")\n\n        lines.append(line)\n        lines_to_zip = []\n\n    self._lines = lines\n    self._update_dimensions(lines)\n\n    return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.DensePixelMatrix.handle_mouse","title":"<code>handle_mouse(event)</code>","text":"<p>As mentioned in the class documentation, mouse handling is disabled here.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"As mentioned in the class documentation, mouse handling is disabled here.\"\"\"\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix","title":"<code>PixelMatrix</code>","text":"<p>             Bases: <code>Widget</code></p> <p>A matrix of pixels.</p> <p>The way this object should be used is by accessing &amp; modifying the underlying matrix. This can be done using the set &amp; getitem syntacies:</p> <pre><code>from pytermgui import PixelMatrix\n\nmatrix = PixelMatrix(10, 10, default=\"white\")\nfor y in matrix.rows:\n    for x in matrix.columns:\n        matrix[y, x] = \"black\"\n</code></pre> <p>The above snippet draws a black diagonal going from the top left to bottom right.</p> <p>Each item of the rows should be a single PyTermGUI-parsable color string. For more information about this, see <code>pytermgui.ansi_interface.Color</code>.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>class PixelMatrix(Widget):\n\"\"\"A matrix of pixels.\n\n    The way this object should be used is by accessing &amp; modifying\n    the underlying matrix. This can be done using the set &amp; getitem\n    syntacies:\n\n    ```python3\n    from pytermgui import PixelMatrix\n\n    matrix = PixelMatrix(10, 10, default=\"white\")\n    for y in matrix.rows:\n        for x in matrix.columns:\n            matrix[y, x] = \"black\"\n    ```\n\n    The above snippet draws a black diagonal going from the top left\n    to bottom right.\n\n    Each item of the rows should be a single PyTermGUI-parsable color\n    string. For more information about this, see\n    `pytermgui.ansi_interface.Color`.\n    \"\"\"\n\n    selected_pixel: tuple[tuple[int, int], str] | None\n\"\"\"A tuple of the position &amp; value (color) of the currently hovered pixel.\"\"\"\n\n    def __init__(\n        self, width: int, height: int, default: str = \"background\", **attrs\n    ) -&gt; None:\n\"\"\"Initializes a PixelMatrix.\n\n        Args:\n            width: The amount of columns the matrix will have.\n            height: The amount of rows the matrix will have.\n            default: The default color to use to initialize the matrix with.\n        \"\"\"\n\n        super().__init__(**attrs)\n\n        self.rows = height\n        self.columns = width\n\n        self._matrix = []\n\n        for _ in range(self.rows):\n            self._matrix.append([default] * self.columns)\n\n        self.selected_pixel = None\n        self.build()\n\n    @classmethod\n    def from_matrix(cls, matrix: list[list[str]]) -&gt; PixelMatrix:\n\"\"\"Creates a PixelMatrix from the given matrix.\n\n        The given matrix should be a list of rows, each containing a number\n        of cells. It is optimal for all rows to share the same amount of cells.\n\n        Args:\n            matrix: The matrix to use. This is a list of lists of strings\n                with each element representing a PyTermGUI-parseable color.\n\n        Returns:\n            A new type(self).\n        \"\"\"\n\n        obj = cls(max(len(row) for row in matrix), len(matrix))\n        setattr(obj, \"_matrix\", matrix)\n        obj.build()\n\n        return obj\n\n    def _update_dimensions(self, lines: list[str]):\n\"\"\"Updates the dimensions of this matrix.\n\n        Args:\n            lines: A list of lines that the calculations will be based upon.\n        \"\"\"\n\n        self.static_width = max(real_length(line) for line in lines)\n        self.height = len(lines)\n\n    def on_hover(self, event: MouseEvent) -&gt; bool:\n\"\"\"Sets `selected_pixel` to the current pixel.\"\"\"\n\n        xoffset = event.position[0] - self.pos[0]\n        yoffset = event.position[1] - self.pos[1]\n\n        color = self._matrix[yoffset][xoffset // 2]\n\n        self.selected_pixel = ((xoffset // 2, yoffset), color)\n        return True\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Returns lines built by the `build` method.\"\"\"\n\n        return self._lines\n\n    def build(self) -&gt; list[str]:\n\"\"\"Builds the image pixels.\n\n        Returns:\n            The lines that this object will return, until a subsequent `build` call.\n            These lines are stored in the `self._lines` variable.\n        \"\"\"\n\n        lines: list[str] = []\n        for row in self._matrix:\n            line = \"\"\n            for pixel in row:\n                if len(pixel) &gt; 0 and pixel != \"background\":\n                    line += f\"[@{pixel}]  \"\n                else:\n                    line += \"[/ background]  \"\n\n            lines.append(tim.parse(line))\n\n        self._lines = lines\n        self._update_dimensions(lines)\n\n        return lines\n\n    def __getitem__(self, indices: tuple[int, int]) -&gt; str:\n\"\"\"Gets a matrix item.\"\"\"\n\n        posy, posx = indices\n        return self._matrix[posy][posx]\n\n    def __setitem__(self, indices: tuple[int, int], value: str) -&gt; None:\n\"\"\"Sets a matrix item.\"\"\"\n\n        posy, posx = indices\n        self._matrix[posy][posx] = value\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.selected_pixel","title":"<code>selected_pixel: tuple[tuple[int, int], str] | None = None</code>  <code>instance-attribute</code>","text":"<p>A tuple of the position &amp; value (color) of the currently hovered pixel.</p>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.__getitem__","title":"<code>__getitem__(indices)</code>","text":"<p>Gets a matrix item.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def __getitem__(self, indices: tuple[int, int]) -&gt; str:\n\"\"\"Gets a matrix item.\"\"\"\n\n    posy, posx = indices\n    return self._matrix[posy][posx]\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.__init__","title":"<code>__init__(width, height, default='background', **attrs)</code>","text":"<p>Initializes a PixelMatrix.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The amount of columns the matrix will have.</p> required <code>height</code> <code>int</code> <p>The amount of rows the matrix will have.</p> required <code>default</code> <code>str</code> <p>The default color to use to initialize the matrix with.</p> <code>'background'</code> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def __init__(\n    self, width: int, height: int, default: str = \"background\", **attrs\n) -&gt; None:\n\"\"\"Initializes a PixelMatrix.\n\n    Args:\n        width: The amount of columns the matrix will have.\n        height: The amount of rows the matrix will have.\n        default: The default color to use to initialize the matrix with.\n    \"\"\"\n\n    super().__init__(**attrs)\n\n    self.rows = height\n    self.columns = width\n\n    self._matrix = []\n\n    for _ in range(self.rows):\n        self._matrix.append([default] * self.columns)\n\n    self.selected_pixel = None\n    self.build()\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.__setitem__","title":"<code>__setitem__(indices, value)</code>","text":"<p>Sets a matrix item.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def __setitem__(self, indices: tuple[int, int], value: str) -&gt; None:\n\"\"\"Sets a matrix item.\"\"\"\n\n    posy, posx = indices\n    self._matrix[posy][posx] = value\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.build","title":"<code>build()</code>","text":"<p>Builds the image pixels.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>The lines that this object will return, until a subsequent <code>build</code> call.</p> <code>list[str]</code> <p>These lines are stored in the <code>self._lines</code> variable.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def build(self) -&gt; list[str]:\n\"\"\"Builds the image pixels.\n\n    Returns:\n        The lines that this object will return, until a subsequent `build` call.\n        These lines are stored in the `self._lines` variable.\n    \"\"\"\n\n    lines: list[str] = []\n    for row in self._matrix:\n        line = \"\"\n        for pixel in row:\n            if len(pixel) &gt; 0 and pixel != \"background\":\n                line += f\"[@{pixel}]  \"\n            else:\n                line += \"[/ background]  \"\n\n        lines.append(tim.parse(line))\n\n    self._lines = lines\n    self._update_dimensions(lines)\n\n    return lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.from_matrix","title":"<code>from_matrix(matrix)</code>  <code>classmethod</code>","text":"<p>Creates a PixelMatrix from the given matrix.</p> <p>The given matrix should be a list of rows, each containing a number of cells. It is optimal for all rows to share the same amount of cells.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>list[list[str]]</code> <p>The matrix to use. This is a list of lists of strings with each element representing a PyTermGUI-parseable color.</p> required <p>Returns:</p> Type Description <code>PixelMatrix</code> <p>A new type(self).</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>@classmethod\ndef from_matrix(cls, matrix: list[list[str]]) -&gt; PixelMatrix:\n\"\"\"Creates a PixelMatrix from the given matrix.\n\n    The given matrix should be a list of rows, each containing a number\n    of cells. It is optimal for all rows to share the same amount of cells.\n\n    Args:\n        matrix: The matrix to use. This is a list of lists of strings\n            with each element representing a PyTermGUI-parseable color.\n\n    Returns:\n        A new type(self).\n    \"\"\"\n\n    obj = cls(max(len(row) for row in matrix), len(matrix))\n    setattr(obj, \"_matrix\", matrix)\n    obj.build()\n\n    return obj\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.get_lines","title":"<code>get_lines()</code>","text":"<p>Returns lines built by the <code>build</code> method.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Returns lines built by the `build` method.\"\"\"\n\n    return self._lines\n</code></pre>"},{"location":"reference/pytermgui/widgets/pixel_matrix/#pytermgui.widgets.pixel_matrix.PixelMatrix.on_hover","title":"<code>on_hover(event)</code>","text":"<p>Sets <code>selected_pixel</code> to the current pixel.</p> Source code in <code>pytermgui/widgets/pixel_matrix.py</code> <pre><code>def on_hover(self, event: MouseEvent) -&gt; bool:\n\"\"\"Sets `selected_pixel` to the current pixel.\"\"\"\n\n    xoffset = event.position[0] - self.pos[0]\n    yoffset = event.position[1] - self.pos[1]\n\n    color = self._matrix[yoffset][xoffset // 2]\n\n    self.selected_pixel = ((xoffset // 2, yoffset), color)\n    return True\n</code></pre>"},{"location":"reference/pytermgui/widgets/slider/","title":"slider","text":"<p>This module contains the <code>Slider</code> class.</p>"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider","title":"<code>Slider</code>","text":"<p>             Bases: <code>Widget</code></p> <p>A Widget to display &amp; configure scalable data.</p> <p>By default, this Widget will act like a slider you might find in a settings page, allowing percentage-based selection of magnitude. Using <code>WindowManager</code> it can even be dragged around by the user using the mouse.</p> Source code in <code>pytermgui/widgets/slider.py</code> <pre><code>class Slider(Widget):  # pylint: disable=too-many-instance-attributes\n\"\"\"A Widget to display &amp; configure scalable data.\n\n    By default, this Widget will act like a slider you might find in a\n    settings page, allowing percentage-based selection of magnitude.\n    Using `WindowManager` it can even be dragged around by the user using\n    the mouse.\n    \"\"\"\n\n    locked: bool\n\"\"\"Disallow mouse input, hide cursor and lock current state\"\"\"\n\n    chars = {\"cursor\": \"\", \"rail\": \"\u2501\", \"delimiter\": [\"[\", \"]\"]}\n\n    styles = w_styles.StyleManager(\n        delimiter=\"surface\",\n        filled=\"surface+1\",\n        cursor=\"primary\",\n        filled_selected=\"primary\",\n        unfilled=\"surface-1\",\n        unfilled_selected=\"surface\",\n    )\n\n    keys = {\n        \"increase\": {keys.RIGHT, keys.CTRL_F, \"l\", \"+\"},\n        \"decrease\": {keys.LEFT, keys.CTRL_B, \"h\", \"-\"},\n    }\n\n    def __init__(\n        self,\n        onchange: Callable[[float], Any] | None = None,\n        locked: bool = False,\n        **attrs: Any,\n    ) -&gt; None:\n\"\"\"Initializes a Slider.\n\n        Args:\n            onchange: The callable called every time the value\n                is updated.\n            locked: Whether this Slider should accept value changes.\n        \"\"\"\n\n        self._value = 0.0\n\n        super().__init__(**attrs)\n        self._selectables_length = 1\n\n        self.is_locked = locked\n        self.onchange = onchange\n\n    @property\n    def value(self) -&gt; float:\n\"\"\"Returns the value of this Slider.\n\n        Returns:\n            A floating point number between 0.0 and 1.0.\n        \"\"\"\n\n        return self._value\n\n    @value.setter\n    def value(self, new: float) -&gt; None:\n\"\"\"Updates the value.\"\"\"\n\n        if self.is_locked:\n            return\n\n        self._value = max(0.0, min(new, 1.0))\n\n        if self.onchange is not None:\n            self.onchange(self._value)\n\n    def handle_key(self, key: str) -&gt; bool:\n\"\"\"Moves the slider cursor.\"\"\"\n\n        if self.execute_binding(key):\n            return True\n\n        if key in self.keys[\"increase\"]:\n            self.value += 0.1\n            return True\n\n        if key in self.keys[\"decrease\"]:\n            self.value -= 0.1\n            return True\n\n        return False\n\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Moves the slider cursor.\"\"\"\n\n        delimiter = self._get_char(\"delimiter\")[0]\n\n        if event.action in [MouseAction.LEFT_CLICK, MouseAction.LEFT_DRAG]:\n            offset = event.position[0] - self.pos[0] + 1 - real_length(delimiter)\n            self.value = max(0, min(offset / self.width, 1.0))\n            return True\n\n        return False\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Gets slider lines.\"\"\"\n\n        rail = self._get_char(\"rail\")\n        cursor = self._get_char(\"cursor\") or rail\n        delimiters = self._get_char(\"delimiter\")\n\n        assert isinstance(delimiters, list)\n        assert isinstance(cursor, str)\n        assert isinstance(rail, str)\n\n        cursor = self._get_style(\"cursor\")(cursor)\n        unfilled = self.styles.unfilled(rail)\n\n        if self.selected_index is None:\n            filled = self.styles.filled(rail)\n        else:\n            filled = self.styles.filled_selected(rail)\n\n            for i, char in enumerate(delimiters):\n                delimiters[i] = self.styles.filled_selected(char)\n\n        for i, delimiter in enumerate(delimiters):\n            delimiters[i] = self.styles.delimiter(delimiter)\n\n        width = self.width - real_length(\"\".join(delimiters))\n        count = width * self.value - 1\n\n        chars = [delimiters[0]]\n\n        for i in range(width):\n            if i == count and not self.is_locked and self.selected_index is not None:\n                chars.append(cursor)\n                continue\n\n            if i &lt;= count:\n                chars.append(filled)\n                continue\n\n            chars.append(unfilled)\n\n        chars.append(delimiters[1])\n        line = \"\".join(chars)\n        self.width = real_length(line)\n\n        return [line]\n</code></pre>"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.locked","title":"<code>locked: bool</code>  <code>instance-attribute</code>","text":"<p>Disallow mouse input, hide cursor and lock current state</p>"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.value","title":"<code>value: float</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the value of this Slider.</p> <p>Returns:</p> Type Description <code>float</code> <p>A floating point number between 0.0 and 1.0.</p>"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.__init__","title":"<code>__init__(onchange=None, locked=False, **attrs)</code>","text":"<p>Initializes a Slider.</p> <p>Parameters:</p> Name Type Description Default <code>onchange</code> <code>Callable[[float], Any] | None</code> <p>The callable called every time the value is updated.</p> <code>None</code> <code>locked</code> <code>bool</code> <p>Whether this Slider should accept value changes.</p> <code>False</code> Source code in <code>pytermgui/widgets/slider.py</code> <pre><code>def __init__(\n    self,\n    onchange: Callable[[float], Any] | None = None,\n    locked: bool = False,\n    **attrs: Any,\n) -&gt; None:\n\"\"\"Initializes a Slider.\n\n    Args:\n        onchange: The callable called every time the value\n            is updated.\n        locked: Whether this Slider should accept value changes.\n    \"\"\"\n\n    self._value = 0.0\n\n    super().__init__(**attrs)\n    self._selectables_length = 1\n\n    self.is_locked = locked\n    self.onchange = onchange\n</code></pre>"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.get_lines","title":"<code>get_lines()</code>","text":"<p>Gets slider lines.</p> Source code in <code>pytermgui/widgets/slider.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Gets slider lines.\"\"\"\n\n    rail = self._get_char(\"rail\")\n    cursor = self._get_char(\"cursor\") or rail\n    delimiters = self._get_char(\"delimiter\")\n\n    assert isinstance(delimiters, list)\n    assert isinstance(cursor, str)\n    assert isinstance(rail, str)\n\n    cursor = self._get_style(\"cursor\")(cursor)\n    unfilled = self.styles.unfilled(rail)\n\n    if self.selected_index is None:\n        filled = self.styles.filled(rail)\n    else:\n        filled = self.styles.filled_selected(rail)\n\n        for i, char in enumerate(delimiters):\n            delimiters[i] = self.styles.filled_selected(char)\n\n    for i, delimiter in enumerate(delimiters):\n        delimiters[i] = self.styles.delimiter(delimiter)\n\n    width = self.width - real_length(\"\".join(delimiters))\n    count = width * self.value - 1\n\n    chars = [delimiters[0]]\n\n    for i in range(width):\n        if i == count and not self.is_locked and self.selected_index is not None:\n            chars.append(cursor)\n            continue\n\n        if i &lt;= count:\n            chars.append(filled)\n            continue\n\n        chars.append(unfilled)\n\n    chars.append(delimiters[1])\n    line = \"\".join(chars)\n    self.width = real_length(line)\n\n    return [line]\n</code></pre>"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.handle_key","title":"<code>handle_key(key)</code>","text":"<p>Moves the slider cursor.</p> Source code in <code>pytermgui/widgets/slider.py</code> <pre><code>def handle_key(self, key: str) -&gt; bool:\n\"\"\"Moves the slider cursor.\"\"\"\n\n    if self.execute_binding(key):\n        return True\n\n    if key in self.keys[\"increase\"]:\n        self.value += 0.1\n        return True\n\n    if key in self.keys[\"decrease\"]:\n        self.value -= 0.1\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/slider/#pytermgui.widgets.slider.Slider.handle_mouse","title":"<code>handle_mouse(event)</code>","text":"<p>Moves the slider cursor.</p> Source code in <code>pytermgui/widgets/slider.py</code> <pre><code>def handle_mouse(self, event: MouseEvent) -&gt; bool:\n\"\"\"Moves the slider cursor.\"\"\"\n\n    delimiter = self._get_char(\"delimiter\")[0]\n\n    if event.action in [MouseAction.LEFT_CLICK, MouseAction.LEFT_DRAG]:\n        offset = event.position[0] - self.pos[0] + 1 - real_length(delimiter)\n        self.value = max(0, min(offset / self.width, 1.0))\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/","title":"styles","text":"<p>Conveniences for styling widgets</p> <p>All styles have a <code>depth</code> and <code>item</code> argument. <code>depth</code> is an int that represents that \"deep\" the Widget is within the hierarchy, and <code>item</code> is the string that the style is applied to.</p>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.HighlighterStyle","title":"<code>HighlighterStyle</code>  <code>dataclass</code>","text":"<p>A style that highlights the items given to it.</p> <p>See <code>pytermgui.highlighters</code> for more information.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>@dataclass\nclass HighlighterStyle:\n\"\"\"A style that highlights the items given to it.\n\n    See `pytermgui.highlighters` for more information.\n    \"\"\"\n\n    highlighter: Highlighter\n\n    def __call__(self, _: int, item: str) -&gt; str:\n\"\"\"Highlights the given string.\"\"\"\n\n        return tim.parse(self.highlighter(item))\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.HighlighterStyle.__call__","title":"<code>__call__(_, item)</code>","text":"<p>Highlights the given string.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __call__(self, _: int, item: str) -&gt; str:\n\"\"\"Highlights the given string.\"\"\"\n\n    return tim.parse(self.highlighter(item))\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.MarkupFormatter","title":"<code>MarkupFormatter</code>  <code>dataclass</code>","text":"<p>A style that formats depth &amp; item into the given markup on call.</p> <p>Useful in Widget styles, such as:</p> <pre><code>import pytermgui as ptg\n\nroot = ptg.Container()\n\n# Set border style to be reactive to the widget's depth\nroot.set_style(\"border\", ptg.MarkupFactory(\"[35 @{depth}]{item}]\")\n</code></pre> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>@dataclass\nclass MarkupFormatter:\n\"\"\"A style that formats depth &amp; item into the given markup on call.\n\n    Useful in Widget styles, such as:\n\n    ```python3\n    import pytermgui as ptg\n\n    root = ptg.Container()\n\n    # Set border style to be reactive to the widget's depth\n    root.set_style(\"border\", ptg.MarkupFactory(\"[35 @{depth}]{item}]\")\n    ```\n    \"\"\"\n\n    markup: str\n    ensure_strip: bool = False\n\n    _markup_cache: dict[str, str] = field(init=False, default_factory=dict)\n\n    def __call__(self, depth: int, item: str) -&gt; str:\n\"\"\"StyleType: Format depth &amp; item into given markup template\"\"\"\n\n        if self.ensure_strip:\n            item = strip_ansi(item)\n\n        if item in self._markup_cache:\n            item = self._markup_cache[item]\n\n        else:\n            original = item\n            item = get_markup(item)\n            self._markup_cache[original] = item\n\n        return tim.parse(self.markup.format(depth=depth, item=item))\n\n    def __str__(self) -&gt; str:\n\"\"\"Returns __repr__, but with markup escaped.\"\"\"\n\n        return self.__repr__().replace(\"[\", r\"\\[\")\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.MarkupFormatter.__call__","title":"<code>__call__(depth, item)</code>","text":"<p>StyleType: Format depth &amp; item into given markup template</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __call__(self, depth: int, item: str) -&gt; str:\n\"\"\"StyleType: Format depth &amp; item into given markup template\"\"\"\n\n    if self.ensure_strip:\n        item = strip_ansi(item)\n\n    if item in self._markup_cache:\n        item = self._markup_cache[item]\n\n    else:\n        original = item\n        item = get_markup(item)\n        self._markup_cache[original] = item\n\n    return tim.parse(self.markup.format(depth=depth, item=item))\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.MarkupFormatter.__str__","title":"<code>__str__()</code>","text":"<p>Returns repr, but with markup escaped.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns __repr__, but with markup escaped.\"\"\"\n\n    return self.__repr__().replace(\"[\", r\"\\[\")\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleCall","title":"<code>StyleCall</code>  <code>dataclass</code>","text":"<p>A callable object that simplifies calling style methods.</p> <p>Instances of this class are created within the <code>Widget._get_style</code> method, and this class should not be used outside of that context.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>@dataclass\nclass StyleCall:\n\"\"\"A callable object that simplifies calling style methods.\n\n    Instances of this class are created within the `Widget._get_style`\n    method, and this class should not be used outside of that context.\"\"\"\n\n    obj: Widget | Type[Widget] | None\n    method: StyleType\n\n    def __call__(self, item: str) -&gt; str:\n\"\"\"DepthlessStyleType: Apply style method to item, using depth\"\"\"\n\n        if self.obj is None:\n            raise ValueError(\n                f\"Can not call {self.method!r}, as no object is assigned to this StyleCall.\"\n            )\n\n        try:\n            # mypy fails on one machine with this, but not on the other.\n            return self.method(self.obj.depth, item)  # type: ignore\n\n        # this is purposefully broad, as anything can happen during these calls.\n        except Exception as error:\n            raise RuntimeError(\n                f\"Could not apply style {self.method} to {item!r}: {error}\"  # type: ignore\n            ) from error\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, type(self)):\n            return False\n\n        return other.method == self.method\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleCall.__call__","title":"<code>__call__(item)</code>","text":"<p>DepthlessStyleType: Apply style method to item, using depth</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __call__(self, item: str) -&gt; str:\n\"\"\"DepthlessStyleType: Apply style method to item, using depth\"\"\"\n\n    if self.obj is None:\n        raise ValueError(\n            f\"Can not call {self.method!r}, as no object is assigned to this StyleCall.\"\n        )\n\n    try:\n        # mypy fails on one machine with this, but not on the other.\n        return self.method(self.obj.depth, item)  # type: ignore\n\n    # this is purposefully broad, as anything can happen during these calls.\n    except Exception as error:\n        raise RuntimeError(\n            f\"Could not apply style {self.method} to {item!r}: {error}\"  # type: ignore\n        ) from error\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager","title":"<code>StyleManager</code>","text":"<p>             Bases: <code>UserDict</code></p> <p>An fancy dictionary to manage a Widget's styles.</p> <p>Individual styles can be accessed two ways:</p> <pre><code>manager.styles.style_name == manager._get_style(\"style_name\")\n</code></pre> <p>Same with setting:</p> <pre><code>widget.styles.style_name = ...\nwidget.set_style(\"style_name\", ...)\n</code></pre> <p>The <code>set</code> and <code>get</code> methods remain for backwards compatibility reasons, but all newly written code should use the dot syntax.</p> <p>It is also possible to set styles as markup shorthands. For example:</p> <pre><code>widget.styles.border = \"60 bold\"\n</code></pre> <p>...is equivalent to:</p> <pre><code>widget.styles.border = \"[60 bold]{item}\"\n</code></pre> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>class StyleManager(UserDict):  # pylint: disable=too-many-ancestors\n\"\"\"An fancy dictionary to manage a Widget's styles.\n\n    Individual styles can be accessed two ways:\n\n    ```python3\n    manager.styles.style_name == manager._get_style(\"style_name\")\n    ```\n\n    Same with setting:\n\n    ```python3\n    widget.styles.style_name = ...\n    widget.set_style(\"style_name\", ...)\n    ```\n\n    The `set` and `get` methods remain for backwards compatibility reasons, but all\n    newly written code should use the dot syntax.\n\n    It is also possible to set styles as markup shorthands. For example:\n\n    ```python3\n    widget.styles.border = \"60 bold\"\n    ```\n\n    ...is equivalent to:\n\n    ```python3\n    widget.styles.border = \"[60 bold]{item}\"\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: Widget | Type[Widget] | None = None,\n        **base,\n    ) -&gt; None:\n\n\"\"\"Initializes a `StyleManager`.\n\n        Args:\n            parent: The parent of this instance. It will be assigned in all\n                `StyleCall`-s created by it.\n        \"\"\"\n\n        self.__dict__[\"_is_setup\"] = False\n\n        self.parent = parent\n\n        super().__init__()\n\n        for key, value in base.items():\n            self._set_as_stylecall(key, value)\n\n        self.__dict__[\"_is_setup\"] = self.parent is not None\n\n    @staticmethod\n    def expand_shorthand(shorthand: str) -&gt; MarkupFormatter:\n\"\"\"Expands a shorthand string into a `MarkupFormatter` instance.\n\n        For example, all of these will expand into `MarkupFormatter([60]{item}')`:\n        - '60'\n        - '[60]'\n        - '[60]{item}'\n\n        Args:\n            shorthand: The short version of markup to expand.\n\n        Returns:\n            A `MarkupFormatter` with the expanded markup.\n        \"\"\"\n\n        if len(shorthand) == 0:\n            return MarkupFormatter(\"{item}\")\n\n        if RE_MARKUP.match(shorthand) is not None:\n            return MarkupFormatter(shorthand)\n\n        tokens = _sub_aliases(list(tokenize_markup(f\"[{shorthand}]\")), tim.context)\n\n        colors = [tkn for tkn in tokens if Token.is_color(tkn)]\n\n        if any(tkn.color.background for tkn in colors) and not any(\n            not tkn.color.background for tkn in colors\n        ):\n            shorthand += \" #auto\"\n\n        markup = f\"[{shorthand}]\"\n\n        if not \"{item}\" in shorthand:\n            markup += \"{item}\"\n\n        return MarkupFormatter(markup)\n\n    @classmethod\n    def merge(cls, other: StyleManager, **styles: str) -&gt; StyleManager:\n\"\"\"Creates a new manager that merges `other` with the passed in styles.\n\n        Args:\n            other: The style manager to base the new one from.\n            **styles: The additional styles the new instance should have.\n\n        Returns:\n            A new `StyleManager`. This instance will only gather its data when\n            `branch` is called on it. This is done so any changes made to the original\n            data between the `merge` call and the actual usage of the instance will be\n            reflected.\n        \"\"\"\n\n        return cls(**{**other, **styles})\n\n    def branch(self, parent: Widget | Type[Widget]) -&gt; StyleManager:\n\"\"\"Branch off from the `base` style dictionary.\n\n        This method should be called during widget construction. It creates a new\n        `StyleManager` based on self, but with its data detached from the original.\n\n        Args:\n            parent: The parent of the new instance.\n\n        Returns:\n            A new `StyleManager`, with detached instances of data. This can then be\n            modified without touching the original instance.\n        \"\"\"\n\n        return type(self)(parent, **self.data)\n\n    def _set_as_stylecall(self, key: str, item: StyleValue) -&gt; None:\n\"\"\"Sets `self.data[key]` as a `StyleCall` of the given item.\n\n        If the item is a string, it will be expanded into a `MarkupFormatter` before\n        being converted into the `StyleCall`, using `expand_shorthand`.\n        \"\"\"\n\n        if isinstance(item, StyleCall):\n            self.data[key] = StyleCall(self.parent, item.method)\n            return\n\n        if isinstance(item, str):\n            item = self.expand_shorthand(item)\n\n        self.data[key] = StyleCall(self.parent, item)\n\n    def __setitem__(self, key: str, value: StyleValue) -&gt; None:\n\"\"\"Sets an item in `self.data`.\n\n        If the item is a string, it will be expanded into a `MarkupFormatter` before\n        being converted into the `StyleCall`, using `expand_shorthand`.\n        \"\"\"\n\n        self._set_as_stylecall(key, value)\n\n    def __setattr__(self, key: str, value: StyleValue) -&gt; None:\n\"\"\"Sets an attribute.\n\n        It first looks if it can set inside self.data, and defaults back to\n        self.__dict__.\n\n        Raises:\n            KeyError: The given key is not a defined attribute, and is not part of this\n                object's style set.\n        \"\"\"\n\n        found = False\n        if \"data\" in self.__dict__:\n            for part in key.split(\"__\"):\n                if part in self.data:\n                    self._set_as_stylecall(part, value)\n                    found = True\n\n        if found:\n            return\n\n        if self.__dict__.get(\"_is_setup\") and key not in self.__dict__:\n            raise KeyError(f\"Style {key!r} was not defined during construction.\")\n\n        self.__dict__[key] = value\n\n    def __getattr__(self, key: str) -&gt; StyleCall:\n\"\"\"Allows styles.dot_syntax.\"\"\"\n\n        if key in self.__dict__:\n            return self.__dict__[key]\n\n        if key in self.__dict__[\"data\"]:\n            return self.__dict__[\"data\"][key]\n\n        raise AttributeError(key, self.data)\n\n    def __call__(self, **styles: StyleValue) -&gt; Any:\n\"\"\"Allows calling the manager and setting its styles.\n\n        For example:\n        ```\n        &gt;&gt;&gt; Button(\"Hello\").styles(label=\"@60\")\n        ```\n        \"\"\"\n\n        for key, value in styles.items():\n            self._set_as_stylecall(key, value)\n\n        return self.parent\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__call__","title":"<code>__call__(**styles)</code>","text":"<p>Allows calling the manager and setting its styles.</p> <p>For example: <pre><code>&gt;&gt;&gt; Button(\"Hello\").styles(label=\"@60\")\n</code></pre></p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __call__(self, **styles: StyleValue) -&gt; Any:\n\"\"\"Allows calling the manager and setting its styles.\n\n    For example:\n    ```\n    &gt;&gt;&gt; Button(\"Hello\").styles(label=\"@60\")\n    ```\n    \"\"\"\n\n    for key, value in styles.items():\n        self._set_as_stylecall(key, value)\n\n    return self.parent\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__getattr__","title":"<code>__getattr__(key)</code>","text":"<p>Allows styles.dot_syntax.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __getattr__(self, key: str) -&gt; StyleCall:\n\"\"\"Allows styles.dot_syntax.\"\"\"\n\n    if key in self.__dict__:\n        return self.__dict__[key]\n\n    if key in self.__dict__[\"data\"]:\n        return self.__dict__[\"data\"][key]\n\n    raise AttributeError(key, self.data)\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__init__","title":"<code>__init__(parent=None, **base)</code>","text":"<p>Initializes a <code>StyleManager</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Widget | Type[Widget] | None</code> <p>The parent of this instance. It will be assigned in all <code>StyleCall</code>-s created by it.</p> <code>None</code> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __init__(\n    self,\n    parent: Widget | Type[Widget] | None = None,\n    **base,\n) -&gt; None:\n\n\"\"\"Initializes a `StyleManager`.\n\n    Args:\n        parent: The parent of this instance. It will be assigned in all\n            `StyleCall`-s created by it.\n    \"\"\"\n\n    self.__dict__[\"_is_setup\"] = False\n\n    self.parent = parent\n\n    super().__init__()\n\n    for key, value in base.items():\n        self._set_as_stylecall(key, value)\n\n    self.__dict__[\"_is_setup\"] = self.parent is not None\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"<p>Sets an attribute.</p> <p>It first looks if it can set inside self.data, and defaults back to self.dict.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>The given key is not a defined attribute, and is not part of this object's style set.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __setattr__(self, key: str, value: StyleValue) -&gt; None:\n\"\"\"Sets an attribute.\n\n    It first looks if it can set inside self.data, and defaults back to\n    self.__dict__.\n\n    Raises:\n        KeyError: The given key is not a defined attribute, and is not part of this\n            object's style set.\n    \"\"\"\n\n    found = False\n    if \"data\" in self.__dict__:\n        for part in key.split(\"__\"):\n            if part in self.data:\n                self._set_as_stylecall(part, value)\n                found = True\n\n    if found:\n        return\n\n    if self.__dict__.get(\"_is_setup\") and key not in self.__dict__:\n        raise KeyError(f\"Style {key!r} was not defined during construction.\")\n\n    self.__dict__[key] = value\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Sets an item in <code>self.data</code>.</p> <p>If the item is a string, it will be expanded into a <code>MarkupFormatter</code> before being converted into the <code>StyleCall</code>, using <code>expand_shorthand</code>.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def __setitem__(self, key: str, value: StyleValue) -&gt; None:\n\"\"\"Sets an item in `self.data`.\n\n    If the item is a string, it will be expanded into a `MarkupFormatter` before\n    being converted into the `StyleCall`, using `expand_shorthand`.\n    \"\"\"\n\n    self._set_as_stylecall(key, value)\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.branch","title":"<code>branch(parent)</code>","text":"<p>Branch off from the <code>base</code> style dictionary.</p> <p>This method should be called during widget construction. It creates a new <code>StyleManager</code> based on self, but with its data detached from the original.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Widget | Type[Widget]</code> <p>The parent of the new instance.</p> required <p>Returns:</p> Type Description <code>StyleManager</code> <p>A new <code>StyleManager</code>, with detached instances of data. This can then be</p> <code>StyleManager</code> <p>modified without touching the original instance.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>def branch(self, parent: Widget | Type[Widget]) -&gt; StyleManager:\n\"\"\"Branch off from the `base` style dictionary.\n\n    This method should be called during widget construction. It creates a new\n    `StyleManager` based on self, but with its data detached from the original.\n\n    Args:\n        parent: The parent of the new instance.\n\n    Returns:\n        A new `StyleManager`, with detached instances of data. This can then be\n        modified without touching the original instance.\n    \"\"\"\n\n    return type(self)(parent, **self.data)\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.expand_shorthand","title":"<code>expand_shorthand(shorthand)</code>  <code>staticmethod</code>","text":"<p>Expands a shorthand string into a <code>MarkupFormatter</code> instance.</p> <p>For example, all of these will expand into <code>MarkupFormatter([60]{item}')</code>: - '60' - '[60]' - '[60]{item}'</p> <p>Parameters:</p> Name Type Description Default <code>shorthand</code> <code>str</code> <p>The short version of markup to expand.</p> required <p>Returns:</p> Type Description <code>MarkupFormatter</code> <p>A <code>MarkupFormatter</code> with the expanded markup.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>@staticmethod\ndef expand_shorthand(shorthand: str) -&gt; MarkupFormatter:\n\"\"\"Expands a shorthand string into a `MarkupFormatter` instance.\n\n    For example, all of these will expand into `MarkupFormatter([60]{item}')`:\n    - '60'\n    - '[60]'\n    - '[60]{item}'\n\n    Args:\n        shorthand: The short version of markup to expand.\n\n    Returns:\n        A `MarkupFormatter` with the expanded markup.\n    \"\"\"\n\n    if len(shorthand) == 0:\n        return MarkupFormatter(\"{item}\")\n\n    if RE_MARKUP.match(shorthand) is not None:\n        return MarkupFormatter(shorthand)\n\n    tokens = _sub_aliases(list(tokenize_markup(f\"[{shorthand}]\")), tim.context)\n\n    colors = [tkn for tkn in tokens if Token.is_color(tkn)]\n\n    if any(tkn.color.background for tkn in colors) and not any(\n        not tkn.color.background for tkn in colors\n    ):\n        shorthand += \" #auto\"\n\n    markup = f\"[{shorthand}]\"\n\n    if not \"{item}\" in shorthand:\n        markup += \"{item}\"\n\n    return MarkupFormatter(markup)\n</code></pre>"},{"location":"reference/pytermgui/widgets/styles/#pytermgui.widgets.styles.StyleManager.merge","title":"<code>merge(other, **styles)</code>  <code>classmethod</code>","text":"<p>Creates a new manager that merges <code>other</code> with the passed in styles.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>StyleManager</code> <p>The style manager to base the new one from.</p> required <code>**styles</code> <code>str</code> <p>The additional styles the new instance should have.</p> <code>{}</code> <p>Returns:</p> Type Description <code>StyleManager</code> <p>A new <code>StyleManager</code>. This instance will only gather its data when</p> <code>StyleManager</code> <p><code>branch</code> is called on it. This is done so any changes made to the original</p> <code>StyleManager</code> <p>data between the <code>merge</code> call and the actual usage of the instance will be</p> <code>StyleManager</code> <p>reflected.</p> Source code in <code>pytermgui/widgets/styles.py</code> <pre><code>@classmethod\ndef merge(cls, other: StyleManager, **styles: str) -&gt; StyleManager:\n\"\"\"Creates a new manager that merges `other` with the passed in styles.\n\n    Args:\n        other: The style manager to base the new one from.\n        **styles: The additional styles the new instance should have.\n\n    Returns:\n        A new `StyleManager`. This instance will only gather its data when\n        `branch` is called on it. This is done so any changes made to the original\n        data between the `merge` call and the actual usage of the instance will be\n        reflected.\n    \"\"\"\n\n    return cls(**{**other, **styles})\n</code></pre>"},{"location":"reference/pytermgui/widgets/toggle/","title":"toggle","text":"<p>This module contains the <code>Toggle</code> class.</p>"},{"location":"reference/pytermgui/widgets/toggle/#pytermgui.widgets.toggle.Toggle","title":"<code>Toggle</code>","text":"<p>             Bases: <code>Checkbox</code></p> <p>A specialized checkbox showing either of two states</p> Source code in <code>pytermgui/widgets/toggle.py</code> <pre><code>class Toggle(Checkbox):\n\"\"\"A specialized checkbox showing either of two states\"\"\"\n\n    chars = {**Checkbox.chars, **{\"delimiter\": [\" \", \" \"], \"checked\": \"choose\"}}\n\n    def __init__(\n        self,\n        states: tuple[str, str],\n        callback: Callable[[str], Any] | None = None,\n        **attrs: Any,\n    ) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n        self.states = states\n\n        self.set_char(\"checked\", states[0])\n        self.set_char(\"unchecked\", states[1])\n\n        super().__init__(callback, **attrs)\n        self.toggle(run_callback=False)\n\n    def _run_callback(self) -&gt; None:\n\"\"\"Run the toggle callback with the label as its argument\"\"\"\n\n        if self.callback is not None:\n            self.callback(self.label)\n</code></pre>"},{"location":"reference/pytermgui/widgets/toggle/#pytermgui.widgets.toggle.Toggle.__init__","title":"<code>__init__(states, callback=None, **attrs)</code>","text":"<p>Initialize object</p> Source code in <code>pytermgui/widgets/toggle.py</code> <pre><code>def __init__(\n    self,\n    states: tuple[str, str],\n    callback: Callable[[str], Any] | None = None,\n    **attrs: Any,\n) -&gt; None:\n\"\"\"Initialize object\"\"\"\n\n    self.states = states\n\n    self.set_char(\"checked\", states[0])\n    self.set_char(\"unchecked\", states[1])\n\n    super().__init__(callback, **attrs)\n    self.toggle(run_callback=False)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/","title":"Index","text":"<p>PyTermGUI's WindowManager, Compositor and Window live here.</p> <p>The window is a subclass of <code>Container</code>, and represents a desktop window. It can be moved, resized and otherwise interacted with.</p> <p>Compositor is a class specialized at drawing Window objects. It tries to be as efficient as possible, and follow a given target framerate.</p> <p>WindowManager is what ties the two together. It manages its list of Windows, transmits and handles mouse input and more.</p>"},{"location":"reference/pytermgui/window_manager/compositor/","title":"compositor","text":"<p>The Compositor class, which is used by the WindowManager to draw onto the terminal.</p>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor","title":"<code>Compositor</code>","text":"<p>The class used to draw <code>pytermgui.window_managers.manager.WindowManager</code> state.</p> <p>This class handles turning a list of windows into a drawable buffer (composite), and then drawing it onto the screen.</p> <p>Calling its <code>run</code> method will start the drawing thread, which will draw the current window states onto the screen. This routine targets <code>framerate</code>, though will likely not match it perfectly.</p> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>class Compositor:\n\"\"\"The class used to draw `pytermgui.window_managers.manager.WindowManager` state.\n\n    This class handles turning a list of windows into a drawable buffer (composite),\n    and then drawing it onto the screen.\n\n    Calling its `run` method will start the drawing thread, which will draw the current\n    window states onto the screen. This routine targets `framerate`, though will likely\n    not match it perfectly.\n    \"\"\"\n\n    def __init__(self, windows: list[Window], framerate: int) -&gt; None:\n\"\"\"Initializes the Compositor.\n\n        Args:\n            windows: A list of the windows to be drawn.\n        \"\"\"\n\n        self._windows = windows\n        self._is_running = False\n\n        self._previous: PositionedLineList = []\n        self._frametime = 0.0\n        self._should_redraw: bool = True\n        self._cache: dict[int, list[str]] = {}\n\n        self.fps = 0\n        self.framerate = framerate\n\n    @property\n    def terminal(self) -&gt; Terminal:\n\"\"\"Returns the current global terminal.\"\"\"\n\n        return get_terminal()\n\n    def _draw_loop(self) -&gt; None:\n\"\"\"A loop that draws at regular intervals.\"\"\"\n\n        framecount = 0\n        last_frame = fps_start_time = time.perf_counter()\n\n        while self._is_running:\n            elapsed = time.perf_counter() - last_frame\n\n            if elapsed &lt; self._frametime:\n                time.sleep(self._frametime - elapsed)\n                continue\n\n            animator.step(elapsed)\n\n            last_frame = time.perf_counter()\n            self.draw()\n\n            framecount += 1\n\n            if last_frame - fps_start_time &gt;= 1:\n                self.fps = framecount\n                fps_start_time = last_frame\n                framecount = 0\n\n    # NOTE: This is not needed at the moment, but might be at some point soon.\n    # def _get_lines(self, window: Window) -&gt; list[str]:\n    #     \"\"\"Gets lines from the window, caching when possible.\n\n    #     This also applies the blurred style of the window, if it has no focus.\n    #     \"\"\"\n\n    #     if window.allow_fullscreen:\n    #         window.pos = self.terminal.origin\n    #         window.width = self.terminal.width\n    #         window.height = self.terminal.height\n\n    #     return window.get_lines()\n\n    #     if window.has_focus or window.is_noblur:\n    #         return window.get_lines()\n\n    #     _id = id(window)\n    #     if not window.is_dirty and _id in self._cache:\n    #         return self._cache[_id]\n\n    #     lines: list[str] = []\n    #     for line in window.get_lines():\n    #         if not window.has_focus:\n    #             line = tim.parse(\"[239]\" + strip_ansi(line).replace(\"[\", r\"\\[\"))\n\n    #         lines.append(line)\n\n    #     self._cache[_id] = lines\n    #     return lines\n\n    def _iter_positioned(\n        self, widget: Widget, until: int | None = None\n    ) -&gt; Iterator[tuple[tuple[int, int], str]]:\n\"\"\"Iterates through (pos, line) tuples from widget.get_lines().\"\"\"\n\n        # get_lines = widget.get_lines\n        # if isinstance(widget, Window):\n        #     get_lines = lambda *_: self._get_lines(widget)  # type: ignore\n        width, height = self.terminal.size\n\n        if until is None:\n            until = widget.height\n\n        for i, line in enumerate(widget.get_lines()[:until]):\n            if i &gt;= until:\n                break\n\n            pos = (widget.pos[0], widget.pos[1] + i)\n\n            yield (pos, line)\n\n        for item in widget.positioned_line_buffer.copy():\n            pos, line = item\n\n            if 0 &lt;= pos[0] &lt;= width and 0 &lt;= pos[1] &lt;= height:\n                yield item\n\n            widget.positioned_line_buffer.remove(item)\n\n    @property\n    def framerate(self) -&gt; int:\n\"\"\"The framerate the draw loop runs at.\n\n        Note:\n            This will likely not be matched very accurately, mostly undershooting\n            the given target.\n        \"\"\"\n\n        return self._framerate\n\n    @framerate.setter\n    def framerate(self, new: int) -&gt; None:\n\"\"\"Updates the framerate.\"\"\"\n\n        self._frametime = 1 / new\n        self._framerate = new\n\n    def clear_cache(self, window: Window) -&gt; None:\n\"\"\"Clears the compositor's cache related to the given window.\"\"\"\n\n        if id(window) in self._cache:\n            del self._cache[id(window)]\n\n    def run(self) -&gt; None:\n\"\"\"Runs the compositor draw loop as a thread.\"\"\"\n\n        self._is_running = True\n        Thread(name=\"CompositorDrawLoop\", target=self._draw_loop, daemon=True).start()\n\n    def stop(self) -&gt; None:\n\"\"\"Stops the compositor.\"\"\"\n\n        self._is_running = False\n\n    def composite(self) -&gt; PositionedLineList:\n\"\"\"Creates a composited buffer from the assigned windows.\n\n        Note that this is currently not used.\"\"\"\n\n        lines = []\n        windows = self._windows\n\n        # Don't unnecessarily print under full screen windows\n        if any(window.allow_fullscreen for window in self._windows):\n            for window in reversed(self._windows):\n                if window.allow_fullscreen:\n                    windows = [window]\n                    break\n\n        size_changes = {WidgetChange.WIDTH, WidgetChange.HEIGHT, WidgetChange.SIZE}\n        for window in reversed(windows):\n            if not window.has_focus:\n                continue\n\n            change = window.get_change()\n\n            if change is None:\n                continue\n\n            if window.is_dirty or change in size_changes:\n                for pos, line in self._iter_positioned(window):\n                    lines.append((pos, line))\n\n                window.is_dirty = False\n                continue\n\n            if change is not None:\n                remaining = window.content_dimensions[1]\n\n                for widget in window.dirty_widgets:\n                    for pos, line in self._iter_positioned(widget, until=remaining):\n                        lines.append((pos, line))\n\n                    remaining -= widget.height\n\n                window.dirty_widgets = []\n                continue\n\n            if window.allow_fullscreen:\n                break\n\n        return lines\n\n    def set_redraw(self) -&gt; None:\n\"\"\"Flags compositor for full redraw.\n\n        Note:\n            At the moment the compositor will always redraw the entire screen.\n        \"\"\"\n\n        self._should_redraw = True\n\n    def draw(self, force: bool = False) -&gt; None:\n\"\"\"Writes composited screen to the terminal.\n\n        At the moment this uses full-screen rewrites. There is a compositing\n        implementation in `composite`, but it is currently not performant enough to use.\n\n        Args:\n            force: When set, new composited lines will not be checked against the\n                previous ones, and everything will be redrawn.\n        \"\"\"\n\n        # if self._should_redraw or force:\n        lines: PositionedLineList = []\n\n        for window in reversed(self._windows):\n            lines.extend(self._iter_positioned(window))\n\n        self._should_redraw = False\n\n        # else:\n        # lines = self.composite()\n\n        if not force and self._previous == lines:\n            return\n\n        self.terminal.clear_stream()\n        with self.terminal.frame() as frame:\n            frame_write = frame.write\n\n            for pos, line in lines:\n                frame_write(f\"\\x1b[{pos[1]};{pos[0]}H{line}\")\n\n        self._previous = lines\n\n    def redraw(self) -&gt; None:\n\"\"\"Force-redraws the buffer.\"\"\"\n\n        self.draw(force=True)\n\n    def capture(self, title: str, filename: str | None = None) -&gt; None:\n\"\"\"Captures the most-recently drawn buffer as `filename`.\n\n        See `pytermgui.exporters.to_svg` for more information.\n        \"\"\"\n\n        with self.terminal.record() as recording:\n            self.redraw()\n\n        recording.save_svg(title=title, filename=filename)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.framerate","title":"<code>framerate: int</code>  <code>property</code> <code>writable</code>","text":"<p>The framerate the draw loop runs at.</p> Note <p>This will likely not be matched very accurately, mostly undershooting the given target.</p>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.terminal","title":"<code>terminal: Terminal</code>  <code>property</code>","text":"<p>Returns the current global terminal.</p>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.__init__","title":"<code>__init__(windows, framerate)</code>","text":"<p>Initializes the Compositor.</p> <p>Parameters:</p> Name Type Description Default <code>windows</code> <code>list[Window]</code> <p>A list of the windows to be drawn.</p> required Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def __init__(self, windows: list[Window], framerate: int) -&gt; None:\n\"\"\"Initializes the Compositor.\n\n    Args:\n        windows: A list of the windows to be drawn.\n    \"\"\"\n\n    self._windows = windows\n    self._is_running = False\n\n    self._previous: PositionedLineList = []\n    self._frametime = 0.0\n    self._should_redraw: bool = True\n    self._cache: dict[int, list[str]] = {}\n\n    self.fps = 0\n    self.framerate = framerate\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.capture","title":"<code>capture(title, filename=None)</code>","text":"<p>Captures the most-recently drawn buffer as <code>filename</code>.</p> <p>See <code>pytermgui.exporters.to_svg</code> for more information.</p> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def capture(self, title: str, filename: str | None = None) -&gt; None:\n\"\"\"Captures the most-recently drawn buffer as `filename`.\n\n    See `pytermgui.exporters.to_svg` for more information.\n    \"\"\"\n\n    with self.terminal.record() as recording:\n        self.redraw()\n\n    recording.save_svg(title=title, filename=filename)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.clear_cache","title":"<code>clear_cache(window)</code>","text":"<p>Clears the compositor's cache related to the given window.</p> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def clear_cache(self, window: Window) -&gt; None:\n\"\"\"Clears the compositor's cache related to the given window.\"\"\"\n\n    if id(window) in self._cache:\n        del self._cache[id(window)]\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.composite","title":"<code>composite()</code>","text":"<p>Creates a composited buffer from the assigned windows.</p> <p>Note that this is currently not used.</p> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def composite(self) -&gt; PositionedLineList:\n\"\"\"Creates a composited buffer from the assigned windows.\n\n    Note that this is currently not used.\"\"\"\n\n    lines = []\n    windows = self._windows\n\n    # Don't unnecessarily print under full screen windows\n    if any(window.allow_fullscreen for window in self._windows):\n        for window in reversed(self._windows):\n            if window.allow_fullscreen:\n                windows = [window]\n                break\n\n    size_changes = {WidgetChange.WIDTH, WidgetChange.HEIGHT, WidgetChange.SIZE}\n    for window in reversed(windows):\n        if not window.has_focus:\n            continue\n\n        change = window.get_change()\n\n        if change is None:\n            continue\n\n        if window.is_dirty or change in size_changes:\n            for pos, line in self._iter_positioned(window):\n                lines.append((pos, line))\n\n            window.is_dirty = False\n            continue\n\n        if change is not None:\n            remaining = window.content_dimensions[1]\n\n            for widget in window.dirty_widgets:\n                for pos, line in self._iter_positioned(widget, until=remaining):\n                    lines.append((pos, line))\n\n                remaining -= widget.height\n\n            window.dirty_widgets = []\n            continue\n\n        if window.allow_fullscreen:\n            break\n\n    return lines\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.draw","title":"<code>draw(force=False)</code>","text":"<p>Writes composited screen to the terminal.</p> <p>At the moment this uses full-screen rewrites. There is a compositing implementation in <code>composite</code>, but it is currently not performant enough to use.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>When set, new composited lines will not be checked against the previous ones, and everything will be redrawn.</p> <code>False</code> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def draw(self, force: bool = False) -&gt; None:\n\"\"\"Writes composited screen to the terminal.\n\n    At the moment this uses full-screen rewrites. There is a compositing\n    implementation in `composite`, but it is currently not performant enough to use.\n\n    Args:\n        force: When set, new composited lines will not be checked against the\n            previous ones, and everything will be redrawn.\n    \"\"\"\n\n    # if self._should_redraw or force:\n    lines: PositionedLineList = []\n\n    for window in reversed(self._windows):\n        lines.extend(self._iter_positioned(window))\n\n    self._should_redraw = False\n\n    # else:\n    # lines = self.composite()\n\n    if not force and self._previous == lines:\n        return\n\n    self.terminal.clear_stream()\n    with self.terminal.frame() as frame:\n        frame_write = frame.write\n\n        for pos, line in lines:\n            frame_write(f\"\\x1b[{pos[1]};{pos[0]}H{line}\")\n\n    self._previous = lines\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.redraw","title":"<code>redraw()</code>","text":"<p>Force-redraws the buffer.</p> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def redraw(self) -&gt; None:\n\"\"\"Force-redraws the buffer.\"\"\"\n\n    self.draw(force=True)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.run","title":"<code>run()</code>","text":"<p>Runs the compositor draw loop as a thread.</p> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"Runs the compositor draw loop as a thread.\"\"\"\n\n    self._is_running = True\n    Thread(name=\"CompositorDrawLoop\", target=self._draw_loop, daemon=True).start()\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.set_redraw","title":"<code>set_redraw()</code>","text":"<p>Flags compositor for full redraw.</p> Note <p>At the moment the compositor will always redraw the entire screen.</p> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def set_redraw(self) -&gt; None:\n\"\"\"Flags compositor for full redraw.\n\n    Note:\n        At the moment the compositor will always redraw the entire screen.\n    \"\"\"\n\n    self._should_redraw = True\n</code></pre>"},{"location":"reference/pytermgui/window_manager/compositor/#pytermgui.window_manager.compositor.Compositor.stop","title":"<code>stop()</code>","text":"<p>Stops the compositor.</p> Source code in <code>pytermgui/window_manager/compositor.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stops the compositor.\"\"\"\n\n    self._is_running = False\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/","title":"layouts","text":"<p>Layouts for the WindowManager.</p>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.ROW_BREAK","title":"<code>ROW_BREAK = Slot('Row Break', Static(0), Static(0))</code>  <code>module-attribute</code>","text":"<p>When encountered in <code>Layout.build_rows</code>, a new row will be started at the next element.</p>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Auto","title":"<code>Auto</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dimension</code></p> <p>An automatically calculated dimension.</p> <p>The value of this dimension is overwritten on <code>Layout.apply</code>.</p> <p>Generally, the way calculations are done is by looking at the available size of the layout by subtracting the sum of all the non-auto dimensions from the terminal's width or height, and dividing it by the number of Auto-type dimensions in the current context.</p> <p>An additional offset is applied to the first dimension (left-most or top-most) of the context when the division has a remainder.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>@dataclass\nclass Auto(Dimension):\n\"\"\"An automatically calculated dimension.\n\n    The value of this dimension is overwritten on `Layout.apply`.\n\n    Generally, the way calculations are done is by looking at the available\n    size of the layout by subtracting the sum of all the non-auto dimensions\n    from the terminal's width or height, and dividing it by the number of\n    Auto-type dimensions in the current context.\n\n    An additional offset is applied to the first dimension (left-most or top-most)\n    of the context when the division has a remainder.\n    \"\"\"\n\n    _value = 0\n\n    def __repr__(self) -&gt; str:\n        return f\"{type(self).__name__}(value={self.value})\"\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Dimension","title":"<code>Dimension</code>","text":"<p>The base class for layout dimensions.</p> <p>Each dimension has a <code>value</code> property. This returns an integer, and is essentially the meaning of the object.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>class Dimension:\n\"\"\"The base class for layout dimensions.\n\n    Each dimension has a `value` property. This returns an integer,\n    and is essentially the *meaning* of the object.\n    \"\"\"\n\n    _value: int\n\n    @property\n    def value(self) -&gt; int:\n\"\"\"Returns the value of the object.\n\n        Override this for custom behaviour.\"\"\"\n\n        return self._value\n\n    @value.setter\n    def value(self, new: int) -&gt; None:\n\"\"\"Sets a new value.\"\"\"\n\n        self._value = new\n\n    def __repr__(self) -&gt; str:\n\"\"\"Returns `{typename}(value={value})`.\n\n        We use this over the dataclasses one as that used `_value`, and it's\n        a bit ugly.\n        \"\"\"\n\n        return f\"{type(self).__name__}(value={self.value})\"\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Dimension.value","title":"<code>value: int</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the value of the object.</p> <p>Override this for custom behaviour.</p>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Dimension.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns <code>{typename}(value={value})</code>.</p> <p>We use this over the dataclasses one as that used <code>_value</code>, and it's a bit ugly.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns `{typename}(value={value})`.\n\n    We use this over the dataclasses one as that used `_value`, and it's\n    a bit ugly.\n    \"\"\"\n\n    return f\"{type(self).__name__}(value={self.value})\"\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout","title":"<code>Layout</code>","text":"<p>Defines a layout of Widgets, used by WindowManager.</p> <p>Internally, it keeps track of a list of <code>Slot</code>. This list is then turned into a list of rows, all containing slots. This is done either when the current row has run out of the terminal's width, or <code>ROW_BREAK</code> is encountered.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>class Layout:\n\"\"\"Defines a layout of Widgets, used by WindowManager.\n\n    Internally, it keeps track of a list of `Slot`. This list is then turned into a list\n    of rows, all containing slots. This is done either when the current row has run out\n    of the terminal's width, or `ROW_BREAK` is encountered.\n    \"\"\"\n\n    name: str\n\n    def __init__(self, name: str = \"Layout\") -&gt; None:\n        self.name = name\n        self.slots: list[Slot] = []\n\n    @property\n    def terminal(self) -&gt; Terminal:\n\"\"\"Returns the current global terminal instance.\"\"\"\n\n        return get_terminal()\n\n    def __len__(self) -&gt; int:\n\"\"\"Gets the slot count of this layout.\"\"\"\n\n        return len(self.slots)\n\n    def _to_rows(self) -&gt; list[list[Slot]]:\n\"\"\"Breaks `self.slots` into a list of list of slots.\n\n        The terminal's remaining width is kept track of, and when a slot doesn't have enough\n        space left it is pushed to a new row. Additionally, `ROW_BREAK` will force a new\n        row to be created, starting with the next slot.\n        \"\"\"\n\n        rows: list[list[Slot]] = []\n        available = self.terminal.width\n\n        row: list[Slot] = []\n        for slot in self.slots:\n            if available &lt;= 0 or slot is ROW_BREAK:\n                rows.append(row)\n\n                row = []\n                available = self.terminal.width - slot.width.value\n\n            if slot is ROW_BREAK:\n                continue\n\n            available -= slot.width.value\n            row.append(slot)\n\n        if len(row) &gt; 0:\n            rows.append(row)\n\n        return rows\n\n    def build_rows(self) -&gt; list[list[Slot]]:\n\"\"\"Builds a list of slot rows, breaking them &amp; applying automatic dimensions.\n\n        Returns:\n            A list[list[Slot]], aka. a list of slot-rows.\n        \"\"\"\n\n        def _get_height(row: list[Slot]) -&gt; int:\n            defined = list(filter(lambda slot: not isinstance(slot.height, Auto), row))\n\n            if len(defined) &gt; 0:\n                return max(slot.height.value for slot in defined)\n\n            return 0\n\n        def _calculate_widths(row: list[Slot]) -&gt; tuple[int, int]:\n            defined: list[Slot] = list(\n                filter(lambda slt: not isinstance(slt.width, Auto), row)\n            )\n            undefined = list(filter(lambda slt: slt not in defined, row))\n\n            available = self.terminal.width - sum(slot.width.value for slot in defined)\n\n            return divmod(available, len(undefined) or 1)\n\n        rows = self._to_rows()\n        heights = [_get_height(row) for row in rows]\n\n        occupied = sum(heights)\n        auto_height, extra_height = divmod(\n            self.terminal.height - occupied, heights.count(0) or 1\n        )\n\n        for row, height in zip(rows, heights):\n            height = height or auto_height\n\n            auto_width, extra_width = _calculate_widths(row)\n            for slot in row:\n                width = auto_width if isinstance(slot.width, Auto) else slot.width.value\n\n                if isinstance(slot.height, Auto):\n                    slot.height.value = height + extra_height\n                    extra_height = 0\n\n                if isinstance(slot.width, Auto):\n                    slot.width.value = width + extra_width\n                    extra_width = 0\n\n        return rows\n\n    def add_slot(\n        self,\n        name: str = \"Slot\",\n        *,\n        slot: Slot | None = None,\n        width: Dimension | int | float | None = None,\n        height: Dimension | int | float | None = None,\n        index: int = -1,\n    ) -&gt; Slot:\n\"\"\"Adds a new slot to the layout.\n\n        Args:\n            name: The name of the slot. Used for display purposes.\n            slot: An already instantiated `Slot` instance. If this is given,\n                the additional width &amp; height arguments will be ignored.\n            width: The width for the new slot. See below for special types.\n            height: The height for the new slot. See below for special types.\n            index: The index to add the new slot to.\n\n        Returns:\n            The just-added slot.\n\n        When defining dimensions, either width or height, some special value\n        types can be given:\n        - `Dimension`: Passed directly to the new slot.\n        - `None`: An `Auto` dimension is created with no value.\n        - `int`: A `Static` dimension is created with the given value.\n        - `float`: A `Relative` dimension is created with the given value as its\n            scale. Its `bound` attribute will default to the relevant part of the\n            terminal's size.\n        \"\"\"\n\n        if slot is None:\n            if width is None:\n                width = Auto()\n\n            elif isinstance(width, int):\n                width = Static(width)\n\n            elif isinstance(width, float):\n                width = Relative(width, bound=lambda: self.terminal.width)\n\n            if height is None:\n                height = Auto()\n\n            elif isinstance(height, int):\n                height = Static(height)\n\n            elif isinstance(height, float):\n                height = Relative(height, bound=lambda: self.terminal.height)\n\n            slot = Slot(name, width=width, height=height)\n\n        if index == -1:\n            self.slots.append(slot)\n            return slot\n\n        self.slots.insert(index, slot)\n\n        return slot\n\n    def add_break(self, *, index: int = -1) -&gt; None:\n\"\"\"Adds `ROW_BREAK` to the given index.\n\n        This special slot is ignored for all intents and purposes, other than when\n        breaking the slots into rows. In that context, when encountered, the current\n        row is deemed completed, and the next slot will go into a new row list.\n        \"\"\"\n\n        self.add_slot(slot=ROW_BREAK, index=index)\n\n    def assign(self, widget: Widget, *, index: int = -1, apply: bool = True) -&gt; None:\n\"\"\"Assigns a widget to the slot at the specified index.\n\n        Args:\n            widget: The widget to assign.\n            index: The target slot's index.\n            apply: If set, `apply` will be called once the widget has been assigned.\n        \"\"\"\n\n        slots = [slot for slot in self.slots if slot is not ROW_BREAK]\n        if index &gt; len(slots) - 1:\n            return\n\n        slot = slots[index]\n\n        slot.content = widget\n\n        if apply:\n            self.apply()\n\n    def apply(self) -&gt; None:\n\"\"\"Applies the layout to each slot.\"\"\"\n\n        position = list(self.terminal.origin)\n        for row in self.build_rows():\n            position[0] = 1\n\n            for slot in row:\n                slot.apply((position[0], position[1]))\n\n                position[0] += slot.width.value\n\n            position[1] += max(slot.height.value for slot in row)\n\n    def __getattr__(self, attr: str) -&gt; Slot:\n\"\"\"Gets a slot by its (slugified) name.\"\"\"\n\n        def _snakeify(name: str) -&gt; str:\n            return name.lower().replace(\" \", \"_\")\n\n        for slot in self.slots:\n            if _snakeify(slot.name) == attr:\n                return slot\n\n        raise AttributeError(f\"Slot with name {attr!r} could not be found.\")\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.terminal","title":"<code>terminal: Terminal</code>  <code>property</code>","text":"<p>Returns the current global terminal instance.</p>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.__getattr__","title":"<code>__getattr__(attr)</code>","text":"<p>Gets a slot by its (slugified) name.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def __getattr__(self, attr: str) -&gt; Slot:\n\"\"\"Gets a slot by its (slugified) name.\"\"\"\n\n    def _snakeify(name: str) -&gt; str:\n        return name.lower().replace(\" \", \"_\")\n\n    for slot in self.slots:\n        if _snakeify(slot.name) == attr:\n            return slot\n\n    raise AttributeError(f\"Slot with name {attr!r} could not be found.\")\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.__len__","title":"<code>__len__()</code>","text":"<p>Gets the slot count of this layout.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Gets the slot count of this layout.\"\"\"\n\n    return len(self.slots)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.add_break","title":"<code>add_break(*, index=-1)</code>","text":"<p>Adds <code>ROW_BREAK</code> to the given index.</p> <p>This special slot is ignored for all intents and purposes, other than when breaking the slots into rows. In that context, when encountered, the current row is deemed completed, and the next slot will go into a new row list.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def add_break(self, *, index: int = -1) -&gt; None:\n\"\"\"Adds `ROW_BREAK` to the given index.\n\n    This special slot is ignored for all intents and purposes, other than when\n    breaking the slots into rows. In that context, when encountered, the current\n    row is deemed completed, and the next slot will go into a new row list.\n    \"\"\"\n\n    self.add_slot(slot=ROW_BREAK, index=index)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.add_slot","title":"<code>add_slot(name='Slot', *, slot=None, width=None, height=None, index=-1)</code>","text":"<p>Adds a new slot to the layout.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the slot. Used for display purposes.</p> <code>'Slot'</code> <code>slot</code> <code>Slot | None</code> <p>An already instantiated <code>Slot</code> instance. If this is given, the additional width &amp; height arguments will be ignored.</p> <code>None</code> <code>width</code> <code>Dimension | int | float | None</code> <p>The width for the new slot. See below for special types.</p> <code>None</code> <code>height</code> <code>Dimension | int | float | None</code> <p>The height for the new slot. See below for special types.</p> <code>None</code> <code>index</code> <code>int</code> <p>The index to add the new slot to.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Slot</code> <p>The just-added slot.</p> <p>When defining dimensions, either width or height, some special value types can be given: - <code>Dimension</code>: Passed directly to the new slot. - <code>None</code>: An <code>Auto</code> dimension is created with no value. - <code>int</code>: A <code>Static</code> dimension is created with the given value. - <code>float</code>: A <code>Relative</code> dimension is created with the given value as its     scale. Its <code>bound</code> attribute will default to the relevant part of the     terminal's size.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def add_slot(\n    self,\n    name: str = \"Slot\",\n    *,\n    slot: Slot | None = None,\n    width: Dimension | int | float | None = None,\n    height: Dimension | int | float | None = None,\n    index: int = -1,\n) -&gt; Slot:\n\"\"\"Adds a new slot to the layout.\n\n    Args:\n        name: The name of the slot. Used for display purposes.\n        slot: An already instantiated `Slot` instance. If this is given,\n            the additional width &amp; height arguments will be ignored.\n        width: The width for the new slot. See below for special types.\n        height: The height for the new slot. See below for special types.\n        index: The index to add the new slot to.\n\n    Returns:\n        The just-added slot.\n\n    When defining dimensions, either width or height, some special value\n    types can be given:\n    - `Dimension`: Passed directly to the new slot.\n    - `None`: An `Auto` dimension is created with no value.\n    - `int`: A `Static` dimension is created with the given value.\n    - `float`: A `Relative` dimension is created with the given value as its\n        scale. Its `bound` attribute will default to the relevant part of the\n        terminal's size.\n    \"\"\"\n\n    if slot is None:\n        if width is None:\n            width = Auto()\n\n        elif isinstance(width, int):\n            width = Static(width)\n\n        elif isinstance(width, float):\n            width = Relative(width, bound=lambda: self.terminal.width)\n\n        if height is None:\n            height = Auto()\n\n        elif isinstance(height, int):\n            height = Static(height)\n\n        elif isinstance(height, float):\n            height = Relative(height, bound=lambda: self.terminal.height)\n\n        slot = Slot(name, width=width, height=height)\n\n    if index == -1:\n        self.slots.append(slot)\n        return slot\n\n    self.slots.insert(index, slot)\n\n    return slot\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.apply","title":"<code>apply()</code>","text":"<p>Applies the layout to each slot.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def apply(self) -&gt; None:\n\"\"\"Applies the layout to each slot.\"\"\"\n\n    position = list(self.terminal.origin)\n    for row in self.build_rows():\n        position[0] = 1\n\n        for slot in row:\n            slot.apply((position[0], position[1]))\n\n            position[0] += slot.width.value\n\n        position[1] += max(slot.height.value for slot in row)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.assign","title":"<code>assign(widget, *, index=-1, apply=True)</code>","text":"<p>Assigns a widget to the slot at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Widget</code> <p>The widget to assign.</p> required <code>index</code> <code>int</code> <p>The target slot's index.</p> <code>-1</code> <code>apply</code> <code>bool</code> <p>If set, <code>apply</code> will be called once the widget has been assigned.</p> <code>True</code> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def assign(self, widget: Widget, *, index: int = -1, apply: bool = True) -&gt; None:\n\"\"\"Assigns a widget to the slot at the specified index.\n\n    Args:\n        widget: The widget to assign.\n        index: The target slot's index.\n        apply: If set, `apply` will be called once the widget has been assigned.\n    \"\"\"\n\n    slots = [slot for slot in self.slots if slot is not ROW_BREAK]\n    if index &gt; len(slots) - 1:\n        return\n\n    slot = slots[index]\n\n    slot.content = widget\n\n    if apply:\n        self.apply()\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Layout.build_rows","title":"<code>build_rows()</code>","text":"<p>Builds a list of slot rows, breaking them &amp; applying automatic dimensions.</p> <p>Returns:</p> Type Description <code>list[list[Slot]]</code> <p>A list[list[Slot]], aka. a list of slot-rows.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def build_rows(self) -&gt; list[list[Slot]]:\n\"\"\"Builds a list of slot rows, breaking them &amp; applying automatic dimensions.\n\n    Returns:\n        A list[list[Slot]], aka. a list of slot-rows.\n    \"\"\"\n\n    def _get_height(row: list[Slot]) -&gt; int:\n        defined = list(filter(lambda slot: not isinstance(slot.height, Auto), row))\n\n        if len(defined) &gt; 0:\n            return max(slot.height.value for slot in defined)\n\n        return 0\n\n    def _calculate_widths(row: list[Slot]) -&gt; tuple[int, int]:\n        defined: list[Slot] = list(\n            filter(lambda slt: not isinstance(slt.width, Auto), row)\n        )\n        undefined = list(filter(lambda slt: slt not in defined, row))\n\n        available = self.terminal.width - sum(slot.width.value for slot in defined)\n\n        return divmod(available, len(undefined) or 1)\n\n    rows = self._to_rows()\n    heights = [_get_height(row) for row in rows]\n\n    occupied = sum(heights)\n    auto_height, extra_height = divmod(\n        self.terminal.height - occupied, heights.count(0) or 1\n    )\n\n    for row, height in zip(rows, heights):\n        height = height or auto_height\n\n        auto_width, extra_width = _calculate_widths(row)\n        for slot in row:\n            width = auto_width if isinstance(slot.width, Auto) else slot.width.value\n\n            if isinstance(slot.height, Auto):\n                slot.height.value = height + extra_height\n                extra_height = 0\n\n            if isinstance(slot.width, Auto):\n                slot.width.value = width + extra_width\n                extra_width = 0\n\n    return rows\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Relative","title":"<code>Relative</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dimension</code></p> <p>A relative dimension.</p> <p>This dimension has a scale attribute and bound method. Every time  the <code>value</code> is queried, <code>int(self.bound() * self.scale)</code> is returned.</p> <p>When instantiated through <code>Layout.add_slot</code>, <code>bound</code> will default to either the terminal's width or height, depending on which attribute it is applied to.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>@dataclass(repr=False)\nclass Relative(Dimension):\n\"\"\"A relative dimension.\n\n    This dimension has a scale attribute and bound method. Every time  the `value`\n    is queried, `int(self.bound() * self.scale)` is returned.\n\n    When instantiated through `Layout.add_slot`, `bound` will default to either\n    the terminal's width or height, depending on which attribute it is applied to.\n    \"\"\"\n\n    _value = 0\n    scale: float\n    bound: Callable[[], int]\n\n    @property\n    def value(self) -&gt; int:\n\"\"\"Calculates the new value for the dimension.\"\"\"\n\n        return int(self.bound() * self.scale)\n\n    @value.setter\n    def value(self, new: int) -&gt; None:\n\"\"\"Disallows setting the value.\n\n        We can't inherit and then override a set-get property with a get one, so this\n        kind of patches that issue up.\n        \"\"\"\n\n        raise TypeError\n\n    def __repr__(self) -&gt; str:\n        scale = self.scale\n        bound = self.bound\n\n        original = super().__repr__()\n        return original[:-1] + f\", {scale=}, {bound=}\" + original[-1]\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Relative.value","title":"<code>value: int</code>  <code>property</code> <code>writable</code>","text":"<p>Calculates the new value for the dimension.</p>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Slot","title":"<code>Slot</code>  <code>dataclass</code>","text":"<p>A slot within a layout.</p> <p>A slot has a name, width &amp; height, as well as some content. It's <code>apply</code> method can be called to apply the slot's position &amp; dimensions to its content.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>@dataclass\nclass Slot:\n\"\"\"A slot within a layout.\n\n    A slot has a name, width &amp; height, as well as some content. It's `apply` method\n    can be called to apply the slot's position &amp; dimensions to its content.\n    \"\"\"\n\n    name: str\n    width: Dimension\n    height: Dimension\n\n    content: Widget | None = None\n\n    _restore_data: tuple[int, int, tuple[int, int]] | None = None\n\n    def apply(self, position: tuple[int, int]) -&gt; None:\n\"\"\"Applies the given position &amp; dimension to the content.\n\n        Args:\n            position: The position that this object resides in. Set as its content's `pos`.\n        \"\"\"\n\n        if self.content is None or self.width is None or self.height is None:\n            return\n\n        if self._restore_data is None:\n            self._restore_data = (\n                self.content.width,\n                self.content.height,\n                self.content.pos,\n            )\n\n        self.content.height = self.height.value\n        self.content.width = self.width.value\n        self.content.pos = position\n\n    def detach_content(self) -&gt; None:\n\"\"\"Detaches content &amp; restores its original state.\"\"\"\n\n        content = self.content\n        if content is None:\n            raise AttributeError(f\"No content to detach in {self!r}.\")\n\n        assert self._restore_data is not None\n\n        content.width, content.height, content.pos = self._restore_data\n\n        self.content = None\n        self._restore_data = None\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Slot.apply","title":"<code>apply(position)</code>","text":"<p>Applies the given position &amp; dimension to the content.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>tuple[int, int]</code> <p>The position that this object resides in. Set as its content's <code>pos</code>.</p> required Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def apply(self, position: tuple[int, int]) -&gt; None:\n\"\"\"Applies the given position &amp; dimension to the content.\n\n    Args:\n        position: The position that this object resides in. Set as its content's `pos`.\n    \"\"\"\n\n    if self.content is None or self.width is None or self.height is None:\n        return\n\n    if self._restore_data is None:\n        self._restore_data = (\n            self.content.width,\n            self.content.height,\n            self.content.pos,\n        )\n\n    self.content.height = self.height.value\n    self.content.width = self.width.value\n    self.content.pos = position\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Slot.detach_content","title":"<code>detach_content()</code>","text":"<p>Detaches content &amp; restores its original state.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>def detach_content(self) -&gt; None:\n\"\"\"Detaches content &amp; restores its original state.\"\"\"\n\n    content = self.content\n    if content is None:\n        raise AttributeError(f\"No content to detach in {self!r}.\")\n\n    assert self._restore_data is not None\n\n    content.width, content.height, content.pos = self._restore_data\n\n    self.content = None\n    self._restore_data = None\n</code></pre>"},{"location":"reference/pytermgui/window_manager/layouts/#pytermgui.window_manager.layouts.Static","title":"<code>Static</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dimension</code></p> <p>A static dimension.</p> <p>This dimension is immutable, and the Layout will always leave it unchanged.</p> Source code in <code>pytermgui/window_manager/layouts.py</code> <pre><code>@dataclass(repr=False, frozen=True)\nclass Static(Dimension):\n\"\"\"A static dimension.\n\n    This dimension is immutable, and the Layout will always leave it unchanged.\n    \"\"\"\n\n    _value: int = 0\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/","title":"manager","text":"<p>The WindowManager class, whos job it is to move, control and update windows, while letting <code>Compositor</code> draw them.</p>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.Edge","title":"<code>Edge</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum for window edges.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>class Edge(Enum):\n\"\"\"Enum for window edges.\"\"\"\n\n    LEFT = _auto()\n    TOP = _auto()\n    RIGHT = _auto()\n    BOTTOM = _auto()\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager","title":"<code>WindowManager</code>","text":"<p>             Bases: <code>Widget</code></p> <p>The manager of windows.</p> <p>This class can be used, or even subclassed in order to create full-screen applications, using the <code>pytermgui.window_manager.window.Window</code> class and the general Widget API.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>class WindowManager(Widget):  # pylint: disable=too-many-instance-attributes\n\"\"\"The manager of windows.\n\n    This class can be used, or even subclassed in order to create full-screen applications,\n    using the `pytermgui.window_manager.window.Window` class and the general Widget API.\n    \"\"\"\n\n    focusing_actions = (MouseAction.LEFT_CLICK, MouseAction.RIGHT_CLICK)\n\"\"\"These mouse actions will focus the window they are acted upon.\"\"\"\n\n    autorun = True\n\n    def __init__(\n        self,\n        *,\n        layout_type: Type[Layout] = Layout,\n        framerate: int = 60,\n        autorun: bool | None = None,\n    ) -&gt; None:\n\"\"\"Initialize the manager.\"\"\"\n\n        super().__init__()\n\n        self._is_running = False\n        self._windows: list[Window] = []\n        self._bindings: dict[str | Type[MouseEvent], tuple[BoundCallback, str]] = {}\n\n        self.focused: Window | None = None\n\n        if autorun is not None:\n            self.autorun = autorun\n\n        self.layout = layout_type()\n        self.compositor = Compositor(self._windows, framerate=framerate)\n        self.mouse_translator: MouseTranslator | None = None\n\n        self._mouse_target: Window | None = None\n        self._focus_index = 0\n        self._drag_offsets: tuple[int, int] = (0, 0)\n        self._drag_target: tuple[Window, Edge] | None = None\n\n        # This isn't quite implemented at the moment.\n        self.restrict_within_bounds = True\n\n        terminal.subscribe(terminal.RESIZE, self.on_resize)\n\n    def __iadd__(self, other: object) -&gt; WindowManager:\n\"\"\"Adds a window to the manager.\"\"\"\n\n        if not isinstance(other, Window):\n            raise ValueError(\"You may only add windows to a WindowManager.\")\n\n        return self.add(other)\n\n    def __isub__(self, other: object) -&gt; WindowManager:\n\"\"\"Removes a window from the manager.\"\"\"\n\n        if not isinstance(other, Window):\n            raise ValueError(\"You may only add windows to a WindowManager.\")\n\n        return self.remove(other)\n\n    def __enter__(self) -&gt; WindowManager:\n\"\"\"Starts context manager.\"\"\"\n\n        return self\n\n    def __exit__(self, _: Any, exception: Exception, __: Any) -&gt; bool:\n\"\"\"Ends context manager.\"\"\"\n\n        # Run the manager if it hasnt been run before.\n        if self.autorun and exception is None and self.mouse_translator is None:\n            self.run()\n\n        if exception is not None:\n            self.stop()\n            raise exception\n\n        return True\n\n    def __iter__(self) -&gt; Iterator[Window]:\n\"\"\"Iterates this manager's windows.\"\"\"\n\n        return iter(self._windows)\n\n    def _run_input_loop(self) -&gt; None:\n\"\"\"The main input loop of the WindowManager.\"\"\"\n\n        with enable_virtual_processing():\n            while self._is_running:\n                # This stops us from blocking during input:\n                #   On POSIX it only reads from 0.01s before returning the empty string\n                #   On Windows it doesn't do a timeout, but since the Windows' getch\n                #     setup immediately returns when no input is available something\n                #     similar ends up happening as well.\n                key = getch_timeout(1 / 100, interrupts=False)\n\n                if key == chr(3):\n                    self.stop()\n                    break\n\n                if self.handle_key(key):\n                    continue\n\n                self.process_mouse(key)\n\n    def get_lines(self) -&gt; list[str]:\n\"\"\"Gets the empty list.\"\"\"\n\n        # TODO: Allow using WindowManager as a widget.\n\n        return []\n\n    def clear_cache(self, window: Window) -&gt; None:\n\"\"\"Clears the compositor's cache related to the given window.\"\"\"\n\n        self.compositor.clear_cache(window)\n\n    def on_resize(self, size: tuple[int, int]) -&gt; None:\n\"\"\"Correctly updates window positions &amp; prints when terminal gets resized.\n\n        Args:\n            size: The new terminal size.\n        \"\"\"\n\n        width, height = size\n\n        for window in self._windows:\n            newx = max(0, min(window.pos[0], width - window.width))\n            newy = max(0, min(window.pos[1], height - window.height + 1))\n\n            window.pos = (newx, newy)\n\n        self.layout.apply()\n        self.compositor.redraw()\n\n    def run(self, mouse_events: list[str] | None = None) -&gt; None:\n\"\"\"Starts the WindowManager.\n\n        Args:\n            mouse_events: A list of mouse event types to listen to. See\n                `pytermgui.ansi_interface.report_mouse` for more information.\n                Defaults to `[\"press_hold\", \"hover\"]`.\n\n        Returns:\n            The WindowManager's compositor instance.\n        \"\"\"\n\n        self._is_running = True\n\n        if mouse_events is None:\n            mouse_events = [\"all\"]\n\n        with alt_buffer(cursor=False, echo=False):\n            with mouse_handler(mouse_events, \"decimal_xterm\") as translate:\n                self.mouse_translator = translate\n                self.compositor.run()\n\n                self._run_input_loop()\n\n    def stop(self) -&gt; None:\n\"\"\"Stops the WindowManager and its compositor.\"\"\"\n\n        self.compositor.stop()\n        self._is_running = False\n\n    def add(\n        self, window: Window, assign: str | bool = True, animate: bool = True\n    ) -&gt; WindowManager:\n\"\"\"Adds a window to the manager.\n\n        Args:\n            window: The window to add.\n            assign: The name of the slot the new window should be assigned to, or a\n                boolean. If it is given a str, it is treated as the name of a slot. When\n                given True, the next non-filled slot will be assigned, and when given\n                False no assignment will be done.\n            animate: If set, an animation will be played on the window once it's added.\n        \"\"\"\n\n        self._windows.insert(0, window)\n        window.manager = self\n\n        if assign:\n            if isinstance(assign, str):\n                getattr(self.layout, assign).content = window\n\n            elif len(self._windows) &lt;= len(self.layout.slots):\n                self.layout.assign(window, index=len(self._windows) - 1)\n\n            self.layout.apply()\n\n        # New windows take focus-precedence over already\n        # existing ones, even if they are modal.\n        self.focus(window)\n\n        if not animate:\n            return self\n\n        if window.height &gt; 1:\n            animator.animate_attr(\n                target=window,\n                attr=\"height\",\n                start=0,\n                end=window.height,\n                duration=300,\n                on_step=_center_during_animation,\n            )\n\n        return self\n\n    def remove(\n        self,\n        window: Window,\n        autostop: bool = True,\n        animate: bool = True,\n    ) -&gt; WindowManager:\n\"\"\"Removes a window from the manager.\n\n        Args:\n            window: The window to remove.\n            autostop: If set, the manager will be stopped if the length of its windows\n                hits 0.\n        \"\"\"\n\n        def _on_finish(_: AttrAnimation | None) -&gt; bool:\n            self._windows.remove(window)\n\n            if autostop and len(self._windows) == 0:\n                self.stop()\n            else:\n                self.focus(self._windows[0])\n\n            return True\n\n        if not animate:\n            _on_finish(None)\n            return self\n\n        animator.animate_attr(\n            target=window,\n            attr=\"height\",\n            end=0,\n            duration=300,\n            on_step=_center_during_animation,\n            on_finish=_on_finish,\n        )\n\n        return self\n\n    def focus(self, window: Window | None) -&gt; None:\n\"\"\"Focuses a window by moving it to the first index in _windows.\"\"\"\n\n        if self.focused is not None:\n            self.focused.blur()\n\n        self.focused = window\n\n        if window is not None:\n            self._focus_index = self._windows.index(window)\n\n            window.focus()\n\n    def focus_next(self, step: int = 1) -&gt; Window | None:\n\"\"\"Focuses the next window in focus order, looping to first at the end.\n\n        Args:\n            step: The direction to step through windows. +1 for next, -1 for previous.\n        \"\"\"\n\n        self._focus_index += step\n\n        if self._focus_index &gt;= len(self._windows):\n            self._focus_index = 0\n\n        if self.focused is not None:\n            self.focused.blur()\n\n        window = self._windows[-self._focus_index]\n\n        window.focus()\n        self.focused = window\n\n        return window\n\n    def handle_key(self, key: str) -&gt; bool:\n\"\"\"Processes a keypress.\n\n        Args:\n            key: The key to handle.\n\n        Returns:\n            True if the given key could be processed, False otherwise.\n        \"\"\"\n\n        # Apply WindowManager bindings\n        if self.execute_binding(key):\n            return True\n\n        # Apply focused window binding, or send to InputField\n        if self.focused is not None:\n            if self.focused.execute_binding(key):\n                return True\n\n            if self.focused.handle_key(key):\n                return True\n\n        return False\n\n    # I prefer having the _click, _drag and _release helpers within this function, for\n    # easier readability.\n    def process_mouse(self, key: str) -&gt; None:  # pylint: disable=too-many-statements\n\"\"\"Processes (potential) mouse input.\n\n        Args:\n            key: Input to handle.\n        \"\"\"\n\n        window: Window\n\n        def _clamp_pos(pos: tuple[int, int], index: int) -&gt; int:\n\"\"\"Clamp a value using index to address x/y &amp; width/height\"\"\"\n\n            offset = self._drag_offsets[index]\n\n            # TODO: This -2 is a very magical number. Not good.\n            maximum = terminal.size[index] - ((window.width, window.height)[index] - 2)\n\n            start_margin_index = abs(index - 1)\n\n            if self.restrict_within_bounds:\n                return max(\n                    index + terminal.margins[start_margin_index],\n                    min(\n                        pos[index] - offset,\n                        maximum\n                        - terminal.margins[start_margin_index + 2]\n                        - terminal.origin[index],\n                    ),\n                )\n\n            return pos[index] - offset\n\n        def _click(pos: tuple[int, int], window: Window) -&gt; bool:\n\"\"\"Process clicking a window.\"\"\"\n\n            left, top, right, bottom = window.rect\n            borders = window.chars.get(\"border\", [\" \"] * 4)\n\n            if real_length(borders[1]) &gt; 0 and pos[1] == top and left &lt;= pos[0] &lt; right:\n                self._drag_target = (window, Edge.TOP)\n\n            elif (\n                real_length(borders[3]) &gt; 0\n                and pos[1] == bottom - 1\n                and left &lt;= pos[0] &lt; right\n            ):\n                self._drag_target = (window, Edge.BOTTOM)\n\n            elif (\n                real_length(borders[0]) &gt; 0\n                and pos[0] == left\n                and top &lt;= pos[1] &lt; bottom\n            ):\n                self._drag_target = (window, Edge.LEFT)\n\n            elif (\n                real_length(borders[2]) &gt; 0\n                and pos[0] == right - 1\n                and top &lt;= pos[1] &lt; bottom\n            ):\n                self._drag_target = (window, Edge.RIGHT)\n\n            else:\n                return False\n\n            self._drag_offsets = (\n                pos[0] - window.pos[0],\n                pos[1] - window.pos[1],\n            )\n\n            return True\n\n        def _drag(pos: tuple[int, int], window: Window) -&gt; bool:\n\"\"\"Process dragging a window\"\"\"\n\n            if self._drag_target is None:\n                return False\n\n            target_window, edge = self._drag_target\n            handled = False\n\n            if window is not target_window:\n                return False\n\n            left, top, right, bottom = window.rect\n\n            if not window.is_static and edge is Edge.TOP:\n                window.pos = (\n                    _clamp_pos(pos, 0),\n                    _clamp_pos(pos, 1),\n                )\n\n                handled = True\n\n            # TODO: Why are all these arbitrary offsets needed?\n            elif not window.is_noresize:\n                if edge is Edge.RIGHT:\n                    window.rect = (left, top, pos[0] + 1, bottom)\n                    handled = True\n\n                elif edge is Edge.LEFT:\n                    window.rect = (pos[0], top, right, bottom)\n                    handled = True\n\n                elif edge is Edge.BOTTOM:\n                    window.rect = (left, top, right, pos[1] + 1)\n                    handled = True\n\n            if handled:\n                window.is_dirty = True\n                self.compositor.set_redraw()\n\n            return handled\n\n        def _release(_: tuple[int, int], __: Window) -&gt; bool:\n\"\"\"Process release of key\"\"\"\n\n            self._drag_target = None\n\n            # This return False so Window can handle the mouse action as well,\n            # as not much is done in this callback.\n            return False\n\n        handlers = {\n            MouseAction.LEFT_CLICK: _click,\n            MouseAction.LEFT_DRAG: _drag,\n            MouseAction.RELEASE: _release,\n        }\n\n        translate = self.mouse_translator\n        event_list = None if translate is None else translate(key)\n\n        if event_list is None:\n            return\n\n        for event in event_list:\n            # Ignore null-events\n            if event is None:\n                continue\n\n            for window in self._windows:\n                contains = window.contains(event.position)\n\n                if event.action in self.focusing_actions:\n                    self.focus(window)\n\n                if event.action in handlers and handlers[event.action](\n                    event.position, window\n                ):\n                    break\n\n                if contains:\n                    if self._mouse_target is not None:\n                        self._mouse_target.handle_mouse(\n                            MouseEvent(MouseAction.RELEASE, event.position)\n                        )\n\n                    self._mouse_target = window\n                    window.handle_mouse(event)\n                    break\n\n                if window.is_modal:\n                    break\n\n            # Unset drag_target if no windows received the input\n            else:\n                self._drag_target = None\n                if self._mouse_target is not None:\n                    self._mouse_target.handle_mouse(\n                        MouseEvent(MouseAction.RELEASE, event.position)\n                    )\n\n                self._mouse_target = None\n\n    def screenshot(self, title: str, filename: str = \"screenshot.svg\") -&gt; None:\n\"\"\"Takes a screenshot of the current state.\n\n        See `pytermgui.exporters.to_svg` for more information.\n\n        Args:\n            filename: The name of the file.\n        \"\"\"\n\n        self.compositor.capture(title=title, filename=filename)\n\n    def show_positions(self) -&gt; None:\n\"\"\"Shows the positions of each Window's widgets.\"\"\"\n\n        def _show_positions(widget, color_base: int = 60) -&gt; None:\n\"\"\"Show positions of widget.\"\"\"\n\n            if isinstance(widget, Container):\n                for i, subwidget in enumerate(widget):\n                    _show_positions(subwidget, color_base + i)\n\n                return\n\n            if not widget.is_selectable:\n                return\n\n            debug = widget.debug()\n            color = str_to_color(f\"@{color_base}\")\n            buff = color(\" \", reset=False)\n\n            for i in range(min(widget.width, real_length(debug)) - 1):\n                buff += debug[i]\n\n            self.terminal.write(buff, pos=widget.pos)\n\n        for widget in self._windows:\n            _show_positions(widget)\n        self.terminal.flush()\n\n        getch()\n\n    def alert(self, *items: Any, center: bool = True, **attributes: Any) -&gt; Window:\n\"\"\"Creates a modal popup of the given elements and attributes.\n\n        Args:\n            *items: All widget-convertable objects passed as children of the new window.\n            center: If set, `pytermgui.window_manager.window.center` is called on the window.\n            **attributes: kwargs passed as the new window's attributes.\n        \"\"\"\n\n        window = Window(*items, is_modal=True, **attributes)\n\n        if center:\n            window.center()\n\n        self.add(window, assign=False)\n\n        return window\n\n    def toast(\n        self,\n        *items: Any,\n        offset: int = 0,\n        duration: int = 300,\n        delay: int = 1000,\n        **attributes: Any,\n    ) -&gt; Window:\n\"\"\"Creates a Material UI-inspired toast window of the given elements and attributes.\n\n        Args:\n            *items: All widget-convertable objects passed as children of the new window.\n            delay: The amount of time before the window will start animating out.\n            **attributes: kwargs passed as the new window's attributes.\n        \"\"\"\n\n        # pylint: disable=no-value-for-parameter\n\n        toast = Window(*items, is_noblur=True, **attributes)\n\n        target_height = toast.height\n        toast.overflow = Overflow.HIDE\n\n        def _finish(_: Animation) -&gt; None:\n            self.remove(toast, animate=False)\n\n        def _progressively_show(anim: Animation, invert: bool = False) -&gt; bool:\n            height = int(anim.state * target_height)\n\n            toast.center()\n\n            if invert:\n                toast.height = target_height - 1 - height\n                toast.pos = (\n                    toast.pos[0],\n                    self.terminal.height - toast.height + 1 - offset,\n                )\n                return False\n\n            toast.height = height\n            toast.pos = (toast.pos[0], self.terminal.height - toast.height + 1 - offset)\n\n            return False\n\n        def _animate_toast_out(_: Animation) -&gt; None:\n            animator.schedule(\n                FloatAnimation(\n                    delay,\n                    on_finish=lambda *_: animator.schedule(\n                        FloatAnimation(\n                            duration,\n                            on_step=lambda anim: _progressively_show(anim, invert=True),\n                            on_finish=_finish,\n                        )\n                    ),\n                )\n            )\n\n        leadup = FloatAnimation(\n            duration, on_step=_progressively_show, on_finish=_animate_toast_out\n        )\n\n        # pylint: enable=no-value-for-parameter\n\n        self.add(toast.center(), animate=False, assign=False)\n        self.focus(toast)\n        animator.schedule(leadup)\n\n        return toast\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.focusing_actions","title":"<code>focusing_actions = (MouseAction.LEFT_CLICK, MouseAction.RIGHT_CLICK)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>These mouse actions will focus the window they are acted upon.</p>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Starts context manager.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def __enter__(self) -&gt; WindowManager:\n\"\"\"Starts context manager.\"\"\"\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__exit__","title":"<code>__exit__(_, exception, __)</code>","text":"<p>Ends context manager.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def __exit__(self, _: Any, exception: Exception, __: Any) -&gt; bool:\n\"\"\"Ends context manager.\"\"\"\n\n    # Run the manager if it hasnt been run before.\n    if self.autorun and exception is None and self.mouse_translator is None:\n        self.run()\n\n    if exception is not None:\n        self.stop()\n        raise exception\n\n    return True\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Adds a window to the manager.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def __iadd__(self, other: object) -&gt; WindowManager:\n\"\"\"Adds a window to the manager.\"\"\"\n\n    if not isinstance(other, Window):\n        raise ValueError(\"You may only add windows to a WindowManager.\")\n\n    return self.add(other)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__init__","title":"<code>__init__(*, layout_type=Layout, framerate=60, autorun=None)</code>","text":"<p>Initialize the manager.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def __init__(\n    self,\n    *,\n    layout_type: Type[Layout] = Layout,\n    framerate: int = 60,\n    autorun: bool | None = None,\n) -&gt; None:\n\"\"\"Initialize the manager.\"\"\"\n\n    super().__init__()\n\n    self._is_running = False\n    self._windows: list[Window] = []\n    self._bindings: dict[str | Type[MouseEvent], tuple[BoundCallback, str]] = {}\n\n    self.focused: Window | None = None\n\n    if autorun is not None:\n        self.autorun = autorun\n\n    self.layout = layout_type()\n    self.compositor = Compositor(self._windows, framerate=framerate)\n    self.mouse_translator: MouseTranslator | None = None\n\n    self._mouse_target: Window | None = None\n    self._focus_index = 0\n    self._drag_offsets: tuple[int, int] = (0, 0)\n    self._drag_target: tuple[Window, Edge] | None = None\n\n    # This isn't quite implemented at the moment.\n    self.restrict_within_bounds = True\n\n    terminal.subscribe(terminal.RESIZE, self.on_resize)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__isub__","title":"<code>__isub__(other)</code>","text":"<p>Removes a window from the manager.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def __isub__(self, other: object) -&gt; WindowManager:\n\"\"\"Removes a window from the manager.\"\"\"\n\n    if not isinstance(other, Window):\n        raise ValueError(\"You may only add windows to a WindowManager.\")\n\n    return self.remove(other)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterates this manager's windows.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Window]:\n\"\"\"Iterates this manager's windows.\"\"\"\n\n    return iter(self._windows)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.add","title":"<code>add(window, assign=True, animate=True)</code>","text":"<p>Adds a window to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>Window</code> <p>The window to add.</p> required <code>assign</code> <code>str | bool</code> <p>The name of the slot the new window should be assigned to, or a boolean. If it is given a str, it is treated as the name of a slot. When given True, the next non-filled slot will be assigned, and when given False no assignment will be done.</p> <code>True</code> <code>animate</code> <code>bool</code> <p>If set, an animation will be played on the window once it's added.</p> <code>True</code> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def add(\n    self, window: Window, assign: str | bool = True, animate: bool = True\n) -&gt; WindowManager:\n\"\"\"Adds a window to the manager.\n\n    Args:\n        window: The window to add.\n        assign: The name of the slot the new window should be assigned to, or a\n            boolean. If it is given a str, it is treated as the name of a slot. When\n            given True, the next non-filled slot will be assigned, and when given\n            False no assignment will be done.\n        animate: If set, an animation will be played on the window once it's added.\n    \"\"\"\n\n    self._windows.insert(0, window)\n    window.manager = self\n\n    if assign:\n        if isinstance(assign, str):\n            getattr(self.layout, assign).content = window\n\n        elif len(self._windows) &lt;= len(self.layout.slots):\n            self.layout.assign(window, index=len(self._windows) - 1)\n\n        self.layout.apply()\n\n    # New windows take focus-precedence over already\n    # existing ones, even if they are modal.\n    self.focus(window)\n\n    if not animate:\n        return self\n\n    if window.height &gt; 1:\n        animator.animate_attr(\n            target=window,\n            attr=\"height\",\n            start=0,\n            end=window.height,\n            duration=300,\n            on_step=_center_during_animation,\n        )\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.alert","title":"<code>alert(*items, center=True, **attributes)</code>","text":"<p>Creates a modal popup of the given elements and attributes.</p> <p>Parameters:</p> Name Type Description Default <code>*items</code> <code>Any</code> <p>All widget-convertable objects passed as children of the new window.</p> <code>()</code> <code>center</code> <code>bool</code> <p>If set, <code>pytermgui.window_manager.window.center</code> is called on the window.</p> <code>True</code> <code>**attributes</code> <code>Any</code> <p>kwargs passed as the new window's attributes.</p> <code>{}</code> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def alert(self, *items: Any, center: bool = True, **attributes: Any) -&gt; Window:\n\"\"\"Creates a modal popup of the given elements and attributes.\n\n    Args:\n        *items: All widget-convertable objects passed as children of the new window.\n        center: If set, `pytermgui.window_manager.window.center` is called on the window.\n        **attributes: kwargs passed as the new window's attributes.\n    \"\"\"\n\n    window = Window(*items, is_modal=True, **attributes)\n\n    if center:\n        window.center()\n\n    self.add(window, assign=False)\n\n    return window\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.clear_cache","title":"<code>clear_cache(window)</code>","text":"<p>Clears the compositor's cache related to the given window.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def clear_cache(self, window: Window) -&gt; None:\n\"\"\"Clears the compositor's cache related to the given window.\"\"\"\n\n    self.compositor.clear_cache(window)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.focus","title":"<code>focus(window)</code>","text":"<p>Focuses a window by moving it to the first index in _windows.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def focus(self, window: Window | None) -&gt; None:\n\"\"\"Focuses a window by moving it to the first index in _windows.\"\"\"\n\n    if self.focused is not None:\n        self.focused.blur()\n\n    self.focused = window\n\n    if window is not None:\n        self._focus_index = self._windows.index(window)\n\n        window.focus()\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.focus_next","title":"<code>focus_next(step=1)</code>","text":"<p>Focuses the next window in focus order, looping to first at the end.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>The direction to step through windows. +1 for next, -1 for previous.</p> <code>1</code> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def focus_next(self, step: int = 1) -&gt; Window | None:\n\"\"\"Focuses the next window in focus order, looping to first at the end.\n\n    Args:\n        step: The direction to step through windows. +1 for next, -1 for previous.\n    \"\"\"\n\n    self._focus_index += step\n\n    if self._focus_index &gt;= len(self._windows):\n        self._focus_index = 0\n\n    if self.focused is not None:\n        self.focused.blur()\n\n    window = self._windows[-self._focus_index]\n\n    window.focus()\n    self.focused = window\n\n    return window\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.get_lines","title":"<code>get_lines()</code>","text":"<p>Gets the empty list.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def get_lines(self) -&gt; list[str]:\n\"\"\"Gets the empty list.\"\"\"\n\n    # TODO: Allow using WindowManager as a widget.\n\n    return []\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.handle_key","title":"<code>handle_key(key)</code>","text":"<p>Processes a keypress.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to handle.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given key could be processed, False otherwise.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def handle_key(self, key: str) -&gt; bool:\n\"\"\"Processes a keypress.\n\n    Args:\n        key: The key to handle.\n\n    Returns:\n        True if the given key could be processed, False otherwise.\n    \"\"\"\n\n    # Apply WindowManager bindings\n    if self.execute_binding(key):\n        return True\n\n    # Apply focused window binding, or send to InputField\n    if self.focused is not None:\n        if self.focused.execute_binding(key):\n            return True\n\n        if self.focused.handle_key(key):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.on_resize","title":"<code>on_resize(size)</code>","text":"<p>Correctly updates window positions &amp; prints when terminal gets resized.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>tuple[int, int]</code> <p>The new terminal size.</p> required Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def on_resize(self, size: tuple[int, int]) -&gt; None:\n\"\"\"Correctly updates window positions &amp; prints when terminal gets resized.\n\n    Args:\n        size: The new terminal size.\n    \"\"\"\n\n    width, height = size\n\n    for window in self._windows:\n        newx = max(0, min(window.pos[0], width - window.width))\n        newy = max(0, min(window.pos[1], height - window.height + 1))\n\n        window.pos = (newx, newy)\n\n    self.layout.apply()\n    self.compositor.redraw()\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.process_mouse","title":"<code>process_mouse(key)</code>","text":"<p>Processes (potential) mouse input.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Input to handle.</p> required Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def process_mouse(self, key: str) -&gt; None:  # pylint: disable=too-many-statements\n\"\"\"Processes (potential) mouse input.\n\n    Args:\n        key: Input to handle.\n    \"\"\"\n\n    window: Window\n\n    def _clamp_pos(pos: tuple[int, int], index: int) -&gt; int:\n\"\"\"Clamp a value using index to address x/y &amp; width/height\"\"\"\n\n        offset = self._drag_offsets[index]\n\n        # TODO: This -2 is a very magical number. Not good.\n        maximum = terminal.size[index] - ((window.width, window.height)[index] - 2)\n\n        start_margin_index = abs(index - 1)\n\n        if self.restrict_within_bounds:\n            return max(\n                index + terminal.margins[start_margin_index],\n                min(\n                    pos[index] - offset,\n                    maximum\n                    - terminal.margins[start_margin_index + 2]\n                    - terminal.origin[index],\n                ),\n            )\n\n        return pos[index] - offset\n\n    def _click(pos: tuple[int, int], window: Window) -&gt; bool:\n\"\"\"Process clicking a window.\"\"\"\n\n        left, top, right, bottom = window.rect\n        borders = window.chars.get(\"border\", [\" \"] * 4)\n\n        if real_length(borders[1]) &gt; 0 and pos[1] == top and left &lt;= pos[0] &lt; right:\n            self._drag_target = (window, Edge.TOP)\n\n        elif (\n            real_length(borders[3]) &gt; 0\n            and pos[1] == bottom - 1\n            and left &lt;= pos[0] &lt; right\n        ):\n            self._drag_target = (window, Edge.BOTTOM)\n\n        elif (\n            real_length(borders[0]) &gt; 0\n            and pos[0] == left\n            and top &lt;= pos[1] &lt; bottom\n        ):\n            self._drag_target = (window, Edge.LEFT)\n\n        elif (\n            real_length(borders[2]) &gt; 0\n            and pos[0] == right - 1\n            and top &lt;= pos[1] &lt; bottom\n        ):\n            self._drag_target = (window, Edge.RIGHT)\n\n        else:\n            return False\n\n        self._drag_offsets = (\n            pos[0] - window.pos[0],\n            pos[1] - window.pos[1],\n        )\n\n        return True\n\n    def _drag(pos: tuple[int, int], window: Window) -&gt; bool:\n\"\"\"Process dragging a window\"\"\"\n\n        if self._drag_target is None:\n            return False\n\n        target_window, edge = self._drag_target\n        handled = False\n\n        if window is not target_window:\n            return False\n\n        left, top, right, bottom = window.rect\n\n        if not window.is_static and edge is Edge.TOP:\n            window.pos = (\n                _clamp_pos(pos, 0),\n                _clamp_pos(pos, 1),\n            )\n\n            handled = True\n\n        # TODO: Why are all these arbitrary offsets needed?\n        elif not window.is_noresize:\n            if edge is Edge.RIGHT:\n                window.rect = (left, top, pos[0] + 1, bottom)\n                handled = True\n\n            elif edge is Edge.LEFT:\n                window.rect = (pos[0], top, right, bottom)\n                handled = True\n\n            elif edge is Edge.BOTTOM:\n                window.rect = (left, top, right, pos[1] + 1)\n                handled = True\n\n        if handled:\n            window.is_dirty = True\n            self.compositor.set_redraw()\n\n        return handled\n\n    def _release(_: tuple[int, int], __: Window) -&gt; bool:\n\"\"\"Process release of key\"\"\"\n\n        self._drag_target = None\n\n        # This return False so Window can handle the mouse action as well,\n        # as not much is done in this callback.\n        return False\n\n    handlers = {\n        MouseAction.LEFT_CLICK: _click,\n        MouseAction.LEFT_DRAG: _drag,\n        MouseAction.RELEASE: _release,\n    }\n\n    translate = self.mouse_translator\n    event_list = None if translate is None else translate(key)\n\n    if event_list is None:\n        return\n\n    for event in event_list:\n        # Ignore null-events\n        if event is None:\n            continue\n\n        for window in self._windows:\n            contains = window.contains(event.position)\n\n            if event.action in self.focusing_actions:\n                self.focus(window)\n\n            if event.action in handlers and handlers[event.action](\n                event.position, window\n            ):\n                break\n\n            if contains:\n                if self._mouse_target is not None:\n                    self._mouse_target.handle_mouse(\n                        MouseEvent(MouseAction.RELEASE, event.position)\n                    )\n\n                self._mouse_target = window\n                window.handle_mouse(event)\n                break\n\n            if window.is_modal:\n                break\n\n        # Unset drag_target if no windows received the input\n        else:\n            self._drag_target = None\n            if self._mouse_target is not None:\n                self._mouse_target.handle_mouse(\n                    MouseEvent(MouseAction.RELEASE, event.position)\n                )\n\n            self._mouse_target = None\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.remove","title":"<code>remove(window, autostop=True, animate=True)</code>","text":"<p>Removes a window from the manager.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>Window</code> <p>The window to remove.</p> required <code>autostop</code> <code>bool</code> <p>If set, the manager will be stopped if the length of its windows hits 0.</p> <code>True</code> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def remove(\n    self,\n    window: Window,\n    autostop: bool = True,\n    animate: bool = True,\n) -&gt; WindowManager:\n\"\"\"Removes a window from the manager.\n\n    Args:\n        window: The window to remove.\n        autostop: If set, the manager will be stopped if the length of its windows\n            hits 0.\n    \"\"\"\n\n    def _on_finish(_: AttrAnimation | None) -&gt; bool:\n        self._windows.remove(window)\n\n        if autostop and len(self._windows) == 0:\n            self.stop()\n        else:\n            self.focus(self._windows[0])\n\n        return True\n\n    if not animate:\n        _on_finish(None)\n        return self\n\n    animator.animate_attr(\n        target=window,\n        attr=\"height\",\n        end=0,\n        duration=300,\n        on_step=_center_during_animation,\n        on_finish=_on_finish,\n    )\n\n    return self\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.run","title":"<code>run(mouse_events=None)</code>","text":"<p>Starts the WindowManager.</p> <p>Parameters:</p> Name Type Description Default <code>mouse_events</code> <code>list[str] | None</code> <p>A list of mouse event types to listen to. See <code>pytermgui.ansi_interface.report_mouse</code> for more information. Defaults to <code>[\"press_hold\", \"hover\"]</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>The WindowManager's compositor instance.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def run(self, mouse_events: list[str] | None = None) -&gt; None:\n\"\"\"Starts the WindowManager.\n\n    Args:\n        mouse_events: A list of mouse event types to listen to. See\n            `pytermgui.ansi_interface.report_mouse` for more information.\n            Defaults to `[\"press_hold\", \"hover\"]`.\n\n    Returns:\n        The WindowManager's compositor instance.\n    \"\"\"\n\n    self._is_running = True\n\n    if mouse_events is None:\n        mouse_events = [\"all\"]\n\n    with alt_buffer(cursor=False, echo=False):\n        with mouse_handler(mouse_events, \"decimal_xterm\") as translate:\n            self.mouse_translator = translate\n            self.compositor.run()\n\n            self._run_input_loop()\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.screenshot","title":"<code>screenshot(title, filename='screenshot.svg')</code>","text":"<p>Takes a screenshot of the current state.</p> <p>See <code>pytermgui.exporters.to_svg</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file.</p> <code>'screenshot.svg'</code> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def screenshot(self, title: str, filename: str = \"screenshot.svg\") -&gt; None:\n\"\"\"Takes a screenshot of the current state.\n\n    See `pytermgui.exporters.to_svg` for more information.\n\n    Args:\n        filename: The name of the file.\n    \"\"\"\n\n    self.compositor.capture(title=title, filename=filename)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.show_positions","title":"<code>show_positions()</code>","text":"<p>Shows the positions of each Window's widgets.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def show_positions(self) -&gt; None:\n\"\"\"Shows the positions of each Window's widgets.\"\"\"\n\n    def _show_positions(widget, color_base: int = 60) -&gt; None:\n\"\"\"Show positions of widget.\"\"\"\n\n        if isinstance(widget, Container):\n            for i, subwidget in enumerate(widget):\n                _show_positions(subwidget, color_base + i)\n\n            return\n\n        if not widget.is_selectable:\n            return\n\n        debug = widget.debug()\n        color = str_to_color(f\"@{color_base}\")\n        buff = color(\" \", reset=False)\n\n        for i in range(min(widget.width, real_length(debug)) - 1):\n            buff += debug[i]\n\n        self.terminal.write(buff, pos=widget.pos)\n\n    for widget in self._windows:\n        _show_positions(widget)\n    self.terminal.flush()\n\n    getch()\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.stop","title":"<code>stop()</code>","text":"<p>Stops the WindowManager and its compositor.</p> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stops the WindowManager and its compositor.\"\"\"\n\n    self.compositor.stop()\n    self._is_running = False\n</code></pre>"},{"location":"reference/pytermgui/window_manager/manager/#pytermgui.window_manager.manager.WindowManager.toast","title":"<code>toast(*items, offset=0, duration=300, delay=1000, **attributes)</code>","text":"<p>Creates a Material UI-inspired toast window of the given elements and attributes.</p> <p>Parameters:</p> Name Type Description Default <code>*items</code> <code>Any</code> <p>All widget-convertable objects passed as children of the new window.</p> <code>()</code> <code>delay</code> <code>int</code> <p>The amount of time before the window will start animating out.</p> <code>1000</code> <code>**attributes</code> <code>Any</code> <p>kwargs passed as the new window's attributes.</p> <code>{}</code> Source code in <code>pytermgui/window_manager/manager.py</code> <pre><code>def toast(\n    self,\n    *items: Any,\n    offset: int = 0,\n    duration: int = 300,\n    delay: int = 1000,\n    **attributes: Any,\n) -&gt; Window:\n\"\"\"Creates a Material UI-inspired toast window of the given elements and attributes.\n\n    Args:\n        *items: All widget-convertable objects passed as children of the new window.\n        delay: The amount of time before the window will start animating out.\n        **attributes: kwargs passed as the new window's attributes.\n    \"\"\"\n\n    # pylint: disable=no-value-for-parameter\n\n    toast = Window(*items, is_noblur=True, **attributes)\n\n    target_height = toast.height\n    toast.overflow = Overflow.HIDE\n\n    def _finish(_: Animation) -&gt; None:\n        self.remove(toast, animate=False)\n\n    def _progressively_show(anim: Animation, invert: bool = False) -&gt; bool:\n        height = int(anim.state * target_height)\n\n        toast.center()\n\n        if invert:\n            toast.height = target_height - 1 - height\n            toast.pos = (\n                toast.pos[0],\n                self.terminal.height - toast.height + 1 - offset,\n            )\n            return False\n\n        toast.height = height\n        toast.pos = (toast.pos[0], self.terminal.height - toast.height + 1 - offset)\n\n        return False\n\n    def _animate_toast_out(_: Animation) -&gt; None:\n        animator.schedule(\n            FloatAnimation(\n                delay,\n                on_finish=lambda *_: animator.schedule(\n                    FloatAnimation(\n                        duration,\n                        on_step=lambda anim: _progressively_show(anim, invert=True),\n                        on_finish=_finish,\n                    )\n                ),\n            )\n        )\n\n    leadup = FloatAnimation(\n        duration, on_step=_progressively_show, on_finish=_animate_toast_out\n    )\n\n    # pylint: enable=no-value-for-parameter\n\n    self.add(toast.center(), animate=False, assign=False)\n    self.focus(toast)\n    animator.schedule(leadup)\n\n    return toast\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/","title":"window","text":"<p>The Window class, which is an implementation of <code>pytermgui.widgets.Container</code> that allows for mouse-based moving and resizing.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window","title":"<code>Window</code>","text":"<p>             Bases: <code>Container</code></p> <p>A class representing a window.</p> <p>Windows are essentially fancy <code>pytermgui.widgets.Container</code>-s. They build on top of them to store and display various widgets, while allowing some custom functionality.</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>class Window(Container):  # pylint: disable=too-many-instance-attributes\n\"\"\"A class representing a window.\n\n    Windows are essentially fancy `pytermgui.widgets.Container`-s. They build on top of them\n    to store and display various widgets, while allowing some custom functionality.\n    \"\"\"\n\n    overflow = Overflow.HIDE\n\n    title = \"\"\n\"\"\"Title shown in left-top corner.\"\"\"\n\n    is_static = False\n\"\"\"Static windows cannot be moved using the mouse.\"\"\"\n\n    is_modal = False\n\"\"\"Modal windows stay on top of every other window and block interactions with other windows.\"\"\"\n\n    is_noblur = False\n\"\"\"No-blur windows will always appear to stay in focus, even if they functionally don't.\"\"\"\n\n    is_noresize = False\n\"\"\"No-resize windows cannot be resized using the mouse.\"\"\"\n\n    is_dirty = False\n\"\"\"Controls whether the window should be redrawn in the next frame.\"\"\"\n\n    is_persistent = False\n\"\"\"Persistent windows will be set noblur automatically, and remain clickable even through\n    modals.\n\n    While the library core doesn't do this for various reasons, it also might be useful to disable\n    some behaviour (e.g. closing) for persistent windows on an implementation level.\n    \"\"\"\n\n    chars = Container.chars.copy()\n\n    styles = w_styles.StyleManager(\n        border=\"surface\",\n        corner=\"surface\",\n        fill=\"background\",\n        border_focused=\"surface\",\n        corner_focused=\"surface\",\n        border_blurred=\"surface-2\",\n        corner_blurred=\"surface-2\",\n    )\n\n    def __init__(self, *widgets: Any, **attrs: Any) -&gt; None:\n\"\"\"Initializes object.\n\n        Args:\n            *widgets: Widgets to add to this window after initilization.\n            **attrs: Attributes that are passed to the constructor.\n        \"\"\"\n\n        self._min_width: int | None = None\n        self._auto_min_width: int | None = None\n\n        self.styles.border_focused = type(self).styles.border\n        self.styles.corner_focused = type(self).styles.corner\n\n        if \"box\" not in attrs:\n            attrs[\"box\"] = \"DOUBLE\"\n\n        super().__init__(*widgets, **attrs)\n\n        self.has_focus: bool = False\n\n        self.manager: \"WindowManager\" | None = None\n\n        # -------------------------  position ----- width x height\n        self._restore_data: tuple[tuple[int, int], tuple[int, int]] | None = None\n\n        if self.title != \"\":\n            self.set_title(self.title)\n\n        if self.is_persistent:\n            self.is_noblur = True\n\n    @property\n    def min_width(self) -&gt; int | None:\n\"\"\"Minimum width of the window.\n\n        If set to none, _auto_min_width will be calculated based on the maximum width of\n        inner widgets.\n\n        This is accurate enough for general use, but tends to lean to the safer side,\n        i.e. it often overshoots the 'real' minimum width possible.\n\n        If you find this to be the case, **AND** you can ensure that your window will\n        not break, you may set this value manually.\n\n        Returns:\n            The calculated, or given minimum width of this object.\n        \"\"\"\n\n        return self._min_width or self._auto_min_width\n\n    @min_width.setter\n    def min_width(self, new: int | None) -&gt; None:\n\"\"\"Sets a new minimum width.\"\"\"\n\n        self._min_width = new\n\n    @property\n    def rect(self) -&gt; tuple[int, int, int, int]:\n\"\"\"Returns the tuple of positions that define this window.\n\n        Returns:\n            A tuple of integers, in the order (left, top, right, bottom).\n        \"\"\"\n\n        left, top = self.pos\n        return (left, top, left + self.width, top + self.height)\n\n    @rect.setter\n    def rect(self, new: tuple[int, int, int, int]) -&gt; None:\n\"\"\"Sets new position, width and height of this window.\n\n        This method also checks for the minimum width this window can be, and\n        if the new width doesn't comply with that setting the changes are thrown\n        away.\n\n        Args:\n            new: A tuple of integers in the order (left, top, right, bottom).\n        \"\"\"\n\n        left, top, right, bottom = new\n        minimum = self.min_width or 0\n\n        if right - left &lt; minimum:\n            return\n\n        # Update size policy to fill to resize inner objects properly\n        self.size_policy = SizePolicy.FILL\n        self.pos = (left, top)\n        self.width = right - left\n        self.height = bottom - top\n\n        # Restore original size policy\n        self.size_policy = SizePolicy.STATIC\n\n    def __iadd__(self, other: object) -&gt; Window:\n\"\"\"Calls self._add_widget(other) and returns self.\"\"\"\n\n        self._add_widget(other)\n        return self\n\n    def __add__(self, other: object) -&gt; Window:\n\"\"\"Calls self._add_widget(other) and returns self.\"\"\"\n\n        self._add_widget(other)\n        return self\n\n    def _add_widget(self, other: object, run_get_lines: bool = True) -&gt; Widget:\n\"\"\"Adds a widget to the window.\n\n        Args:\n            other: The widget-like to add.\n            run_get_lines: Whether self.get_lines should be ran after adding.\n        \"\"\"\n\n        added = super()._add_widget(other, run_get_lines)\n\n        if len(self._widgets) &gt; 0:\n            self._auto_min_width = max(widget.width for widget in self._widgets)\n            self._auto_min_width += self.sidelength\n\n        self.height += added.height\n\n        return added\n\n    @classmethod\n    def set_focus_styles(\n        cls,\n        *,\n        focused: tuple[w_styles.StyleValue, w_styles.StyleValue],\n        blurred: tuple[w_styles.StyleValue, w_styles.StyleValue],\n    ) -&gt; None:\n\"\"\"Sets focused &amp; blurred border &amp; corner styles.\n\n        Args:\n            focused: A tuple of border_focused, corner_focused styles.\n            blurred: A tuple of border_blurred, corner_blurred styles.\n        \"\"\"\n\n        cls.styles.border_focused, cls.styles.corner_focused = focused\n        cls.styles.border_blurred, cls.styles.corner_blurred = blurred\n\n    def focus(self) -&gt; None:\n\"\"\"Focuses this window.\"\"\"\n\n        self.has_focus = True\n\n        if not self.is_noblur:\n            self.styles.border = self.styles.border_focused\n            self.styles.corner = self.styles.corner_focused\n\n    def blur(self) -&gt; None:\n\"\"\"Blurs (unfocuses) this window.\"\"\"\n\n        self.has_focus = False\n        self.select(None)\n        self.handle_mouse(MouseEvent(MouseAction.RELEASE, (0, 0)))\n\n        if not self.is_noblur:\n            self.styles.border = self.styles.border_blurred\n            self.styles.corner = self.styles.corner_blurred\n\n    def clear_cache(self) -&gt; None:\n\"\"\"Clears manager compositor's cached blur state.\"\"\"\n\n        if self.manager is not None:\n            self.manager.clear_cache(self)\n\n    def contains(self, pos: tuple[int, int]) -&gt; bool:\n\"\"\"Determines whether widget contains `pos`.\n\n        This method uses window.rect to get the positions.\n\n        Args:\n            pos: Position to compare.\n\n        Returns:\n            Boolean describing whether the position is inside\n                this widget.\n        \"\"\"\n\n        left, top, right, bottom = self.rect\n\n        return left &lt;= pos[0] &lt; right and top &lt;= pos[1] &lt; bottom\n\n    def set_title(self, title: str, position: int = 0, pad: bool = True) -&gt; Window:\n\"\"\"Sets the window's title.\n\n        Args:\n            title: The string to set as the window title.\n            position: An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"],\n                determining where the title is applied.\n            pad: Whether there should be an extra space before and after the given title.\n                defaults to True.\n        \"\"\"\n\n        corners = self._get_char(\"corner\")\n        assert isinstance(corners, list)\n\n        # Delete (both cases) of current title from the corner\n        corners[position] = (\n            corners[position].replace(f\" {self.title} \", \"\").replace(self.title, \"\")\n        )\n\n        self.title = title\n\n        if pad:\n            title = \" \" + title + \" \"\n\n        if position % 2 == 0:\n            corners[position] += title\n\n        else:\n            current = corners[position]\n            corners[position] = title + current\n\n        self.set_char(\"corner\", corners)\n\n        return self\n\n    def center(\n        self, where: CenteringPolicy | None = None, store: bool = True\n    ) -&gt; Window:\n\"\"\"Center window\"\"\"\n\n        super().center(where, store)\n        return self\n\n    def close(self, animate: bool = True) -&gt; None:\n\"\"\"Instruct window manager to close object\"\"\"\n\n        assert self.manager is not None\n\n        self.manager.remove(self, animate=animate)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_dirty","title":"<code>is_dirty = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Controls whether the window should be redrawn in the next frame.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_modal","title":"<code>is_modal = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Modal windows stay on top of every other window and block interactions with other windows.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_noblur","title":"<code>is_noblur = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No-blur windows will always appear to stay in focus, even if they functionally don't.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_noresize","title":"<code>is_noresize = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No-resize windows cannot be resized using the mouse.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_persistent","title":"<code>is_persistent = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Persistent windows will be set noblur automatically, and remain clickable even through modals.</p> <p>While the library core doesn't do this for various reasons, it also might be useful to disable some behaviour (e.g. closing) for persistent windows on an implementation level.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.is_static","title":"<code>is_static = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Static windows cannot be moved using the mouse.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.min_width","title":"<code>min_width: int | None</code>  <code>property</code> <code>writable</code>","text":"<p>Minimum width of the window.</p> <p>If set to none, _auto_min_width will be calculated based on the maximum width of inner widgets.</p> <p>This is accurate enough for general use, but tends to lean to the safer side, i.e. it often overshoots the 'real' minimum width possible.</p> <p>If you find this to be the case, AND you can ensure that your window will not break, you may set this value manually.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>The calculated, or given minimum width of this object.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.rect","title":"<code>rect: tuple[int, int, int, int]</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the tuple of positions that define this window.</p> <p>Returns:</p> Type Description <code>tuple[int, int, int, int]</code> <p>A tuple of integers, in the order (left, top, right, bottom).</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.title","title":"<code>title = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Title shown in left-top corner.</p>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.__add__","title":"<code>__add__(other)</code>","text":"<p>Calls self._add_widget(other) and returns self.</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def __add__(self, other: object) -&gt; Window:\n\"\"\"Calls self._add_widget(other) and returns self.\"\"\"\n\n    self._add_widget(other)\n    return self\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Calls self._add_widget(other) and returns self.</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def __iadd__(self, other: object) -&gt; Window:\n\"\"\"Calls self._add_widget(other) and returns self.\"\"\"\n\n    self._add_widget(other)\n    return self\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.__init__","title":"<code>__init__(*widgets, **attrs)</code>","text":"<p>Initializes object.</p> <p>Parameters:</p> Name Type Description Default <code>*widgets</code> <code>Any</code> <p>Widgets to add to this window after initilization.</p> <code>()</code> <code>**attrs</code> <code>Any</code> <p>Attributes that are passed to the constructor.</p> <code>{}</code> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def __init__(self, *widgets: Any, **attrs: Any) -&gt; None:\n\"\"\"Initializes object.\n\n    Args:\n        *widgets: Widgets to add to this window after initilization.\n        **attrs: Attributes that are passed to the constructor.\n    \"\"\"\n\n    self._min_width: int | None = None\n    self._auto_min_width: int | None = None\n\n    self.styles.border_focused = type(self).styles.border\n    self.styles.corner_focused = type(self).styles.corner\n\n    if \"box\" not in attrs:\n        attrs[\"box\"] = \"DOUBLE\"\n\n    super().__init__(*widgets, **attrs)\n\n    self.has_focus: bool = False\n\n    self.manager: \"WindowManager\" | None = None\n\n    # -------------------------  position ----- width x height\n    self._restore_data: tuple[tuple[int, int], tuple[int, int]] | None = None\n\n    if self.title != \"\":\n        self.set_title(self.title)\n\n    if self.is_persistent:\n        self.is_noblur = True\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.blur","title":"<code>blur()</code>","text":"<p>Blurs (unfocuses) this window.</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def blur(self) -&gt; None:\n\"\"\"Blurs (unfocuses) this window.\"\"\"\n\n    self.has_focus = False\n    self.select(None)\n    self.handle_mouse(MouseEvent(MouseAction.RELEASE, (0, 0)))\n\n    if not self.is_noblur:\n        self.styles.border = self.styles.border_blurred\n        self.styles.corner = self.styles.corner_blurred\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.center","title":"<code>center(where=None, store=True)</code>","text":"<p>Center window</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def center(\n    self, where: CenteringPolicy | None = None, store: bool = True\n) -&gt; Window:\n\"\"\"Center window\"\"\"\n\n    super().center(where, store)\n    return self\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clears manager compositor's cached blur state.</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def clear_cache(self) -&gt; None:\n\"\"\"Clears manager compositor's cached blur state.\"\"\"\n\n    if self.manager is not None:\n        self.manager.clear_cache(self)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.close","title":"<code>close(animate=True)</code>","text":"<p>Instruct window manager to close object</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def close(self, animate: bool = True) -&gt; None:\n\"\"\"Instruct window manager to close object\"\"\"\n\n    assert self.manager is not None\n\n    self.manager.remove(self, animate=animate)\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.contains","title":"<code>contains(pos)</code>","text":"<p>Determines whether widget contains <code>pos</code>.</p> <p>This method uses window.rect to get the positions.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>tuple[int, int]</code> <p>Position to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean describing whether the position is inside this widget.</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def contains(self, pos: tuple[int, int]) -&gt; bool:\n\"\"\"Determines whether widget contains `pos`.\n\n    This method uses window.rect to get the positions.\n\n    Args:\n        pos: Position to compare.\n\n    Returns:\n        Boolean describing whether the position is inside\n            this widget.\n    \"\"\"\n\n    left, top, right, bottom = self.rect\n\n    return left &lt;= pos[0] &lt; right and top &lt;= pos[1] &lt; bottom\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.focus","title":"<code>focus()</code>","text":"<p>Focuses this window.</p> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def focus(self) -&gt; None:\n\"\"\"Focuses this window.\"\"\"\n\n    self.has_focus = True\n\n    if not self.is_noblur:\n        self.styles.border = self.styles.border_focused\n        self.styles.corner = self.styles.corner_focused\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.set_focus_styles","title":"<code>set_focus_styles(*, focused, blurred)</code>  <code>classmethod</code>","text":"<p>Sets focused &amp; blurred border &amp; corner styles.</p> <p>Parameters:</p> Name Type Description Default <code>focused</code> <code>tuple[w_styles.StyleValue, w_styles.StyleValue]</code> <p>A tuple of border_focused, corner_focused styles.</p> required <code>blurred</code> <code>tuple[w_styles.StyleValue, w_styles.StyleValue]</code> <p>A tuple of border_blurred, corner_blurred styles.</p> required Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>@classmethod\ndef set_focus_styles(\n    cls,\n    *,\n    focused: tuple[w_styles.StyleValue, w_styles.StyleValue],\n    blurred: tuple[w_styles.StyleValue, w_styles.StyleValue],\n) -&gt; None:\n\"\"\"Sets focused &amp; blurred border &amp; corner styles.\n\n    Args:\n        focused: A tuple of border_focused, corner_focused styles.\n        blurred: A tuple of border_blurred, corner_blurred styles.\n    \"\"\"\n\n    cls.styles.border_focused, cls.styles.corner_focused = focused\n    cls.styles.border_blurred, cls.styles.corner_blurred = blurred\n</code></pre>"},{"location":"reference/pytermgui/window_manager/window/#pytermgui.window_manager.window.Window.set_title","title":"<code>set_title(title, position=0, pad=True)</code>","text":"<p>Sets the window's title.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The string to set as the window title.</p> required <code>position</code> <code>int</code> <p>An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"], determining where the title is applied.</p> <code>0</code> <code>pad</code> <code>bool</code> <p>Whether there should be an extra space before and after the given title. defaults to True.</p> <code>True</code> Source code in <code>pytermgui/window_manager/window.py</code> <pre><code>def set_title(self, title: str, position: int = 0, pad: bool = True) -&gt; Window:\n\"\"\"Sets the window's title.\n\n    Args:\n        title: The string to set as the window title.\n        position: An integer indexing into [\"left\", \"top\", \"right\", \"bottom\"],\n            determining where the title is applied.\n        pad: Whether there should be an extra space before and after the given title.\n            defaults to True.\n    \"\"\"\n\n    corners = self._get_char(\"corner\")\n    assert isinstance(corners, list)\n\n    # Delete (both cases) of current title from the corner\n    corners[position] = (\n        corners[position].replace(f\" {self.title} \", \"\").replace(self.title, \"\")\n    )\n\n    self.title = title\n\n    if pad:\n        title = \" \" + title + \" \"\n\n    if position % 2 == 0:\n        corners[position] += title\n\n    else:\n        current = corners[position]\n        corners[position] = title + current\n\n    self.set_char(\"corner\", corners)\n\n    return self\n</code></pre>"},{"location":"tim/","title":"Introduction","text":"<p>PyTermGUI offers a markup language complimentary to the other features of the library, named Terminal Inline Markup, or TIM for short. This language is in use in various places within the library, and is supported by pretty much everything we offer that displays text.</p> <pre><code>from pytermgui import tim\n\ntim.print(\"[bold lightblue]Hello[/fg italic]!\")\n\ntim.print(\n    \"[bold]TIM[/] supports [italic]macros[/],\"\n    + \" like [!upper]upper[/!] and [bold !gradient(56)]gradient[/!].\"\n)\n\ntim.print(\n    \"We also support [skyblue underline ~https://ptg.bczsalba.com]\"\n    + \"terminal hyperlinks[/]!\"\n)\n</code></pre> <p> TIM Example Hello ! TIM \u00a0supports\u00a0 macros ,\u00a0like\u00a0UPPER\u00a0and\u00a0 g r a d i ent . We\u00a0also\u00a0support\u00a0 terminal\u00a0hyperlinks ! </p>"},{"location":"tim/#philosophy","title":"Philosophy","text":"<ul> <li> <p>Convenience</p> <p>Raw ANSI sequences are cumbersome to use and hard to read/write. TIM aims to improve this by assigning easy-to-read names to pretty much all ANSI syntax.</p> </li> <li> <p>Speed</p> <p>Since this language is meant to be used in performance-critical applications, it must be pretty fast. As of 16th of July 2022, TIM is magnitudes faster than Rich's own markup language, the only \"competition\" I know about.</p> <p>This is achieved mostly by smart caching routines, as well as a tightly written parsing algorithm.</p> </li> <li> <p>Extensibility</p> <p>I like tinkering. I hate using things that are made with the philosophy of \"this is what I made, and it's all that you will get.\". TIM implements customizability in its alias and macro systems.</p> </li> <li> <p>Convenience &amp; granularity</p> <p>Above all, TIM was made to be simple and ergonomic to use. Styles follow their most-commonly used names, and every tag is applied as its own distinct entity, and aren't joined into a set style. This allows you to specifically clear certain tags, while not touching the rest of the style.</p> </li> </ul>"},{"location":"tim/tags/","title":"Tags","text":""},{"location":"tim/tags/#basics","title":"Basics","text":"<p>TIM syntax tends to be simple. At the base, we have the following structure:</p> <pre><code>[tag1 tag2 ...]My content\n     ^              ^\n tag group     plain text\n</code></pre> <p>...where <code>tag1</code> &amp; <code>tag2</code> are some valid markup tags, and <code>My content</code> is the string you want them to modify.</p> <p>Tag groups are always denoted by square brackets (<code>[</code> and <code>]</code>). All text outside of a tag group is considered to be plain text.</p>"},{"location":"tim/tags/#nesting","title":"Nesting","text":"<p>When encountering nested tag groups, only the innermost one will be parsed:</p> TIMOutput <pre><code>\"[[bold]bold [/ lightblue]lightblue[/]][italic lightgreen]Hello\"\n</code></pre> <p> [ bold\u00a0 lightblue ] Hello <p></p>"},{"location":"tim/tags/#escaping","title":"Escaping","text":"<p>You can escape a tag group using backslashes (<code>\\</code>):</p> TIMOutput <pre><code>\"\\[bold lightblue][italic lightgreen]Hello\"\n</code></pre> <p> [bold\u00a0lightblue] Hello <p></p> <p>Re-parsing escaped markup</p> <p>Escaping tag groups will only be effective for the first parsing of said string. During parsing, the escaped tag group will lose the backslash to hide it from the output.</p>"},{"location":"tim/tags/#styles","title":"Styles","text":"<p>We support all generally supported terminal \"modes\":</p> <p>Resource</p> <p>For a great overview on these styles &amp; ANSI sequences in general, see this gist by Christian Petersen, or this website.</p> <ul> <li> <p>bold (mode <code>1</code>):</p> <p>Traditionally (and on some older emulators) makes text brighter, nowadays it increases the font's weight.</p> </li> <li> <p>dim (mode <code>2</code>):</p> <p>The opposite of the traditional function behind bold, makes text a bit darker.</p> </li> <li> <p>italic (mode <code>3</code>):</p> <p>Uses the italicized font variant, which tilts each character.</p> </li> <li> <p>underline (mode <code>4</code>):</p> <p>Draws a thin line under each character.</p> </li> <li> <p>blink &amp; blink2 (mode <code>5</code> &amp; <code>6</code>):</p> <p>Repeatedly shows and hides the characters at an internal frequency. Like HTML's <code>&lt;blink&gt;</code>, it seems to have fallen out of favor and is no longer supported on many terminals. Some terminal's support one, but not the other.</p> </li> <li> <p>inverse (mode <code>7</code>):</p> <p>Inverts the function of the foreground and background colors, i.e. the foreground color will now act on the background and vice-versa.</p> </li> <li> <p>invisible (mode <code>8</code>):</p> <p>Hides text. Not widely supported, for some reason.</p> </li> <li> <p>strikethrough (mode <code>9</code>):</p> <p>Draws a line through each character, somewhere near the vertical middle.</p> </li> <li> <p>overline (mode <code>53</code>):</p> <p>Draws a line above each character.</p> </li> </ul> <p> docs/src/tim/tags_modes.py \u250c\u00a0Available\u00a0modes\u00a0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 bold \u00a0\u2502 \u2502\u00a0 dim \u00a0\u2502 \u2502\u00a0 italic \u00a0\u2502 \u2502\u00a0 underline \u00a0\u2502 \u2502\u00a0 blink \u00a0\u2502 \u2502\u00a0 blink2 \u00a0\u2502 \u2502\u00a0 inverse \u00a0\u2502 \u2502\u00a0 invisible \u00a0\u2502 \u2502\u00a0 strikethrough \u00a0\u2502 \u2502\u00a0 overline \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 </p> Implementation <p>Under the hood, these styles are set by printing a special escape sequence to the terminal. These sequences are structured the following way:</p> <pre><code>\\x1b[{mode_id}m\n</code></pre> <p>In effect, this means <code>bold</code> stands for <code>\\x1b[1m</code>, and <code>inverse</code> for <code>\\x1b[7m</code>.</p>"},{"location":"tim/tags/#colors","title":"Colors","text":"<p>The terminal generally supports 3 color palettes</p> <ul> <li> <p>3 bit, or 16-color</p> <p>8 base colors (<code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, <code>white</code> and <code>black</code>), and high-brightness version of each, making a total of 16.</p> </li> <li> <p>8-bit, or 256-color:</p> <p>256 colors, each using 8 bits of information. The standard colors make up the first 16 indices.</p> </li> <li> <p>24-bit, or truecolor</p> <p>Something in the ballpark of 16.7 million colors, this set represents all colors definable by 3 8-bit (<code>0-255</code>) values, each standing for one of the <code>RED</code>, <code>GREEN</code> and <code>BLUE</code> channels.</p> </li> </ul> <p>Lucky for you, the reader, TIM exposes convenient syntax for all of these!</p> <ul> <li> <p>Indexed colors (3-bit and 8-bit):</p> <p><code>[{index}]</code>, where <code>index</code> is a number in the range <code>0-255</code>, including both ends.</p> </li> <li> <p>RGB colors (24-bit):</p> <p><code>[{rrr};{ggg};{bbb}]</code>, where <code>rrr</code>, <code>ggg</code> and <code>bbb</code> each represent a number alike the ones indexed colors use, standing for the red, green and blue channels respectively.</p> </li> <li> <p>HEX colors (alternate representation of 24-bit):</p> <p><code>[#{rr};{gg};{bb}]</code>, where each value represents a 3-bit number like above, as a hexadecimal value.</p> </li> <li> <p>Named colors (3-bit or 24-bit):</p> <p><code>[{name}]</code>, where <code>name</code> is a CSS color name known to TIM:</p> </li> </ul> <p> CSS Colors aliceblue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0gainsboro\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mistyrose antiquewhite\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0ghostwhite\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0moccasin aqua\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0gold\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0navajowhite aquamarine\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0goldenrod\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0navy azure\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0gray\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0oldlace beige\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0grey\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0olive bisque\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0green\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0olivedrab black\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0greenyellow\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0orange blanchedalmond\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0honeydew\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0orangered blue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0hotpink\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0orchid blueviolet\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0indianred\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0palegoldenrod brown\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0indigo\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0palegreen burlywood\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ivory\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0paleturquoise cadetblue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0khaki\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0palevioletred chartreuse\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lavender\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0papayawhip chocolate\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0lavenderblush\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0peachpuff coral\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0lawngreen\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0peru cornflowerblue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0lemonchiffon\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pink cornsilk\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0lightblue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0plum crimson\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0lightcoral\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0powderblue cyan\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0lightcyan\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0purple darkblue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 lightgoldenrodyellow \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0red darkcyan\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0lightgray\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rosybrown darkgoldenrod\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0lightgrey\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0royalblue darkgray\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0lightgreen\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0saddlebrown darkgrey\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0lightpink\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0salmon darkgreen\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0lightsalmon\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sandybrown darkkhaki\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0lightseagreen\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0seagreen darkmagenta\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0lightskyblue\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0seashell darkolivegreen\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0lightslategray\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sienna darkorange\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0lightslategrey\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0silver darkorchid\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0lightsteelblue\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0skyblue darkred\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0lightyellow\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0slateblue darksalmon\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lime\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0slategray darkseagreen\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0limegreen\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0slategrey darkslateblue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0linen\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0snow darkslategray\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0magenta\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0springgreen darkslategrey\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maroon\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0steelblue darkturquoise\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0mediumaquamarine\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tan darkviolet\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0mediumblue\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0teal deeppink\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0mediumorchid\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0thistle deepskyblue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0mediumpurple\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tomato dimgray\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0mediumseagreen\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0turquoise dimgrey\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0mediumslateblue\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0violet dodgerblue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0mediumspringgreen\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0wheat firebrick\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0mediumturquoise\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0white floralwhite\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0mediumvioletred\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0whitesmoke forestgreen\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0midnightblue\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0yellow fuchsia\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0mintcream\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0yellowgreen </p> <p>Colors, by default, will act on the foreground. This can be changed by prefixing the color markup by an at-symbol (<code>@</code>), like so:</p> TIMOutput <pre><code>\"[78 @34;52;111] My text [inverse] and now inversed! \"\n</code></pre> <p> \u00a0My\u00a0text\u00a0 \u00a0and\u00a0now\u00a0inversed!\u00a0 <p></p>"},{"location":"tim/tags/#clearers","title":"Clearers","text":"<p>After you set a style, you might want to stop it affecting text. To do so, you want to use a clearer token.</p> <p>Clearer tokens are denoted with the slash (<code>/</code>) prefix, and contain the identifier they are targeting.</p> <p>For example:</p> <ul> <li>To clear all attributes, including modes, colors, macros, use <code>/</code> with no identifier.</li> <li>To clear a simple terminal mode, use <code>/{mode}</code>, like <code>/italic</code>.</li> <li>To clear a color, use <code>/fg</code> for foreground colors, and <code>/bg</code> for background ones.</li> <li>To clear a macro, use either <code>/!{name}</code>, or <code>/!</code> to clear all active macros.</li> <li>To clear a hyperlink, use <code>/~</code>.</li> </ul> <p>Clearing specific links</p> <p>Since the terminal only supports having one active hyperlink at a time, there is no reason to have syntax for specifically clearing a single link.</p>"},{"location":"tim/tags/#hyperlinks","title":"Hyperlinks","text":"<p>Newer terminals allow HTML anchor-inspired hyperlinks that can be clicked and take the user to places.</p> <p>Resource</p> <p>For information on the implementation of terminal-hyperlinks, check out this gist.</p> <p>In PyTermGUI TIM, we use the syntax:</p> <pre><code>[~{protocol}://{uri}]\n</code></pre> <p>...where <code>protocol</code> is a data-transfer protocol supported by the client (usually <code>http</code>, <code>https</code> or <code>file</code>), and <code>uri</code> is a standard URI readable by the specified protocol.</p> <p>For example:</p> <pre><code>This documentation is hosted as a [~https://ptg.bczsalba.com]subdomain[/~] on my [~https://bczsalba.com]website!\n</code></pre> <p>...would create markup equivalent to the HTML:</p> <pre><code>This documentation is hosted as a &lt;a href=\"https://ptg.bczsalba.com\"&gt;subdomain&lt;/a&gt; on my &lt;a href=\"https://bczsalba.com\"&gt;website!&lt;/a&gt;\n</code></pre>"},{"location":"tim/tags/#macros","title":"Macros","text":"<p>Info</p> <p>This section details the syntax, but none of the semantics and usage tips, For a more in-depth explanation on macros, see the macro docs.</p> <p>Macros use the syntax:</p> <pre><code>[!{name}({arg1}:{arg2})]\n</code></pre> <p>...or the shorthand</p> <pre><code>[!{name}]\n</code></pre> <p>when there are no arguments passed.</p> <p>In both examples, <code>name</code> is the name the macro is defined as, and <code>arg1</code> and <code>arg2</code> are some arguments passed to it. Macro arguments are separated by colons (<code>:</code>), in order to clearly visually differentiate them from Python function calls.</p>"},{"location":"tim/tags/#positioners","title":"Positioners","text":"<p>You can position text in the terminal using the syntax:</p> <pre><code>[({x};{y})]\n</code></pre> <p>Where <code>x</code> and <code>y</code> are terminal coordinates, starting from terminal.origin.</p> TIMOutput <pre><code>\"[61]This is some normal text[(3;5)]But this part is located somewhere else!\"\n</code></pre> <p> This\u00a0is\u00a0some\u00a0normal\u00a0text But\u00a0this\u00a0part\u00a0is\u00a0located\u00a0somewhere\u00a0else! <p></p>"},{"location":"tim/tags/#pseudo-s","title":"Pseudo-s","text":"<p>All tags above have behaviour that is \"pre-defined\"; their meaning will be the same in all uses, regardless of context. Pseudo tags are a sort of context-aware group, where they have don't have a consistent meaning: They modify the existing meaning based on the context around them.</p>"},{"location":"tim/tags/#auto","title":"Auto","text":"<p>It's easier to explain by-example, so here is our first pseudo tag, <code>#auto</code>:</p> PythonOutput <pre><code>from pytermgui import tim\n\ntim.print(\"[@black #auto]White on black [@white #auto] Black on white\")\n</code></pre> <p> docs/src/tim/tags_pseudo1.py White\u00a0on\u00a0black\u00a0 \u00a0Black\u00a0on\u00a0white <p></p> <p>What this tag does is prompt the engine to look around in the current tag group, and inspect the colors set. From then it does the following (simplified):</p> <pre><code>foreground = ...\nbackground = ...\n\nif foreground is None and background is not None:\n    foreground = get_contrasting_color(background)\n</code></pre> <p>In essence, it looks for any foreground color. If there is None, but there is a background color, it finds a color that contrasts the background (either an off-white or off-black) and applies that to the foreground. You get color-contrast matches that follow the W3C guidelines with just one tag!</p>"},{"location":"tim/usage/","title":"Usage in PTG","text":"<p>So the things you read before are all great and all, but where do you apply them? Glad you (definitely) asked!</p> <p>The markup module exports the <code>tim</code> name; this is an instance of MarkupLanguage. <code>tim</code> is going to be your best pal for handling anything related to TIM parsing.</p> Why do we use classes to represent a static language? <p>There are a couple of aspects of TIM that require keeping track of some 'state', e.g. aliases and macros. This state, referred to as <code>context</code> internally, is passed in to all parsing functions to provide the data needed to apply the non-built-in tags.</p> <p><code>MarkupLanguage</code> keeps track of some context that can be modified with the <code>alias</code> and <code>define</code> methods, and passes this state into every <code>parse*</code> call for you!</p> <p>Fun fact: You can use TIM in most widgets! See the styling docs for more info.</p>"},{"location":"tim/usage/#methods","title":"Methods","text":""},{"location":"tim/usage/#parse","title":"Parse","text":"<p>The most important method to know about is parse. It takes some TIM string, and returns formatted text to display in the terminal.</p> PythonOutput <pre><code>from pytermgui import tim\n\nprint(tim.parse(\"[lightgreen]This is some [italic]styled[/italic] text!\"))\n</code></pre> <p> docs/src/tim/usage_parse.py This\u00a0is\u00a0some\u00a0 styled \u00a0text! <p></p>"},{"location":"tim/usage/#print","title":"Print","text":"<p>Since calling <code>print</code> on parsed text every time can get a bit repetitive, we have a helper function to do it for you! Just call print with the same positional and keyword arguments as you would use for the builtin print, and see the magic!</p> <p>You can print non-TIM text with this method as well, but you might wanna use the escape function if you want to make sure to keep things from being parsed. Though at that point, you might as well use the builtin print!</p> PythonOutput <pre><code>from pytermgui import tim\n\ntim.print(\n    \"[slategrey italic]So much formatting, [!shuffle !upper]where[/!] does it all fit?\"\n)\n</code></pre> <p> docs/src/tim/usage_print.py So\u00a0much\u00a0formatting,\u00a0EHEWR\u00a0DOES\u00a0IT\u00a0ALL\u00a0FIT? <p></p>"},{"location":"tim/usage/#alias","title":"Alias","text":"<p>As mentioned above, you can modify the TIM parser's state to enable custom behaviour. The first of these is aliasing tags, which essentially makes one tag expand to any other groups of tags while parsing.</p> <p>Warning</p> <p>Alias tags are detected as tags that had no previous meaning, e.g. aren't included in the builtin tags and are not macros. At the moment it is not possible to re-define tags.</p> PythonOutput <pre><code>from pytermgui import tim\n\ntim.alias(\"my-tag1\", \"@surface primary+1\")\n\n# Recursive tags also work!\ntim.alias(\"my-tag2\", \"my-tag1 italic\")\n\ntim.print(\n    \"[my-tag1]My first tag\\n\\n\"\n    + \"[/my-tag1]By default, aliases generate an unsetter\\n\\n\"\n    + \"[my-tag2]My second tag\"\n)\n</code></pre> <p> docs/src/tim/usage_alias.py My\u00a0first\u00a0tag By\u00a0default,\u00a0aliases\u00a0generate\u00a0an\u00a0unsetter My\u00a0second\u00a0tag <p></p>"},{"location":"tim/usage/#define","title":"Define","text":"<p>You can also define macros using the define method. Macros are Python functions you can call from TIM to transform your text. They can only be referenced from TIM, definition must come from the outer Python context.</p> <p>There are a couple of simple macros defined by default, such as <code>!upper</code>, <code>!capitalize</code> and <code>!lower</code>. These are all tied to the respective Python <code>str</code> methods.</p> PythonOutput <pre><code>from pytermgui import tim\n\ntim.print(\"[!upper]some text\")\ntim.print(\"[!lower]SOME OTHER TEXT\")\ntim.print(\"[!gradient(210) italic]Fancy lookin' text\")\n</code></pre> <p> docs/src/tim/usage_define1.py SOME\u00a0TEXT some\u00a0other\u00a0text Fan cy\u00a0 loo kin '\u00a0t ext <p></p> <p>A favored example of mine is creating a simple localization layer for your application. You can define a macro, <code>!lang</code>, that is given a localization-id and returns some localized text. This can then be used in any place that TIM is accepted, since it is defined on the global instance.</p> PythonOutput <pre><code>from pytermgui import tim\n\nLANGUAGE = \"en\"\n\nTRANSLATIONS = {\n    \"welcome\": {\n        \"en\": \"Welcome to the documentation\",\n        \"hu\": \"\u00dcdv a dokument\u00e1ci\u00f3ban\",\n    }\n}\n\n\ndef macro_lang(key: str) -&gt; str:\n    translation = TRANSLATIONS.get(key)\n\n    if translation is None:\n        return key\n\n    return translation[LANGUAGE]\n\n\ntim.define(\"!lang\", macro_lang)\n\nfor LANGUAGE in [\"en\", \"hu\"]:\n    tim.clear_cache()\n\n    tim.print(f\"[bold]LANGUAGE: [/ 157]{LANGUAGE!r}\")\n    tim.print(\"--&gt; [!lang]welcome[/!lang]\")\n    tim.print()\n</code></pre> <p> docs/src/tim/usage_define2.py LANGUAGE:\u00a0 'en' --&gt;\u00a0Welcome\u00a0to\u00a0the\u00a0documentation LANGUAGE:\u00a0 'hu' --&gt;\u00a0\u00dcdv\u00a0a\u00a0dokument\u00e1ci\u00f3ban <p></p>"},{"location":"walkthroughs/","title":"Index","text":"<p>This page will host an ever-evolving set of step by step walkthroughs for the library. If you have any suggestions for topics, feel free to raise an issue describing your idea!</p>"},{"location":"walkthroughs/inline/","title":"Building an inline-widget context","text":"<p>Our objective today will be to implement a function that lets us use PyTermGUI widgets in an inline-context, e.g. from the terminal prompt while retaining the shell's state.</p> <p>This type of usage is common for simple prompts that are part of a greater, CLI-based application; they give you the cool-factor of the TUI, and in our case its mouse &amp; keyboard input options, while staying in a CLI environment.</p> <p> docs/src/inline_login.py lapis:\u00a0 docs\u00a0 * \u00a0python3\u00a0inline_login.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502\u00a0 User\u00a0information \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 Name:\u00a0 Balazs\u00a0Cene \u00a0\u2502 \u2502\u00a0 Password:\u00a0 *********** \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 \u00a0Stay\u00a0logged\u00a0in\u00a0 \u00a0\u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 </p>"},{"location":"walkthroughs/inline/#defining-our-goals","title":"Defining our goals","text":"<p>Our target syntax will be this:</p> <pre><code>prompt_widget = ptg.inline(built_prompt())\n</code></pre> <p>...which gives us the general signature:</p> <pre><code>def inline(widget):\n    ...\n\n    return widget\n</code></pre>"},{"location":"walkthroughs/inline/#basic-implementation","title":"Basic implementation","text":"<p>Let's start with getting the widget to read keyboard inputs and render after each one of them. To do this, we will sit in a <code>while</code> loop, use the getch function and send its output to our widget's handle_key method.</p> inline.py<pre><code>from pytermgui import getch, Widget\n\ndef inline(widget):\n    while True:\n        key = getch()\n\n        widget.handle_key(key)\n\n        for line in widget.get_lines():\n            print(line)\n\n    return widget\n</code></pre> <p>If you run the above, you will notice 2 things:</p> <ul> <li>Pressing Ctrl+C leaves us with an ugly <code>KeyboardInterrupt</code></li> <li>The widget lines aren't overwritten, but written to the terminal sequentially</li> </ul> <p>There is also no mouse interaction, but we'll leave that for later.</p>"},{"location":"walkthroughs/inline/#implementing-clean-exits","title":"Implementing clean exits","text":"<p>Let's focus on our first problem, relating to the <code>KeyboardInterrupt</code> error. This is trivial to fix; we can tell <code>getch</code> to convert <code>KeyboardInterrupt</code> into the character Ctrl+C sends, and break the loop when we see said character.</p> <p>The reason we need to do this lies deep in the trenches of the terminal, but here is the gist: When Ctrl+C is detected, the \"interrupt\" signal is sent to the current foreground task. This signal (in simple terms) tells the program:</p> <p>Hey there! I think you should stop running.</p> <p>It's important to note that this is not a full hard drop everything you're doing and flee signal. This one is meant to allow programs to clean up after themselves before quitting, which is exactly what we will need to do.</p> <p>Note</p> <p>To see the above in effect, you can try the following code:</p> <pre><code>from time import time\n\nwhile True:\n    try:\n        print(time())\n    except KeyboardInterrupt:\n        pass\n\nreturn widget\n</code></pre> <p>You will now be unable to leave the program, haha! Just kidding. Press Ctrl+\\ to send the \"kill\" signal to the program, which will stop the loop in its tracks. You can also press Ctrl+L, or type <code>reset</code> into the shell if your terminal got too messed up.</p> <p>I feel like this goes without saying, but:</p> <p>Please do not put inescapable loops into your code</p> ChangesUpdated file <pre><code>  from typing import TypeVar\n- from pytermgui import getch, Widget\n+ from pytermgui import getch, keys, Widget\n\n T = TypeVar(\"T\", bound=Widget)\n\n  def inline(widget):\n      while True:\n-         key = getch()\n+         key = getch(interrupts=False)\n+ \n+         if key == keys.CTRL_C:\n+            break\n\n         widget.handle_key(key)\n\n          for line in widget.get_lines():\n             print(line)\n\n      return widget\n</code></pre> inline.py<pre><code>from typing import TypeVar\nfrom pytermgui import getch, keys, Widget\n\nT = TypeVar(\"T\", bound=Widget)\n\ndef inline(widget):\n    while True:\n        key = getch(interrupts=False)\n\n        if key == keys.CTRL_C:\n           break\n\n        widget.handle_key(key)\n\n        for line in widget.get_lines():\n           print(line)\n\n    return widget\n</code></pre> <p>If you now run this and press Ctrl+C, you should see the program quit cleanly.</p>"},{"location":"walkthroughs/inline/#improving-printing","title":"Improving printing","text":"<p>The print routine above was pretty rudimentary. We can do better!</p> <p>To achieve the 'prompt' look we are aiming for, we need to always start printing at the same location. The simplest way to do this is to use the save_cursor and restore_cursor methods. These tell the terminal to store the current cursor location somewhere, and to move the cursor to the stored location, respectively.</p> <p>Let's start by making the following changes:</p> ChangesUpdated file <pre><code>  from typing import TypeVar\n- from pytermgui import getch, keys, Widget\n+ from pytermgui import getch, keys, save_cursor, restore_cursor, Widget\n\n def inline(widget):\n      while True:\n          key = getch(interrupts=False)\n\n          if key == keys.CTRL_C:\n             break\n\n          widget.handle_key(key) \n\n+         save_cursor()\n+\n         for line in widget.get_lines():\n             print(line)\n+\n+         restore_cursor()\n\n     return widget\n</code></pre> inline.py<pre><code>from typing import TypeVar\nfrom pytermgui import getch, keys, save_cursor, restore_cursor, Widget\n\ndef inline(widget):\n    while True:\n        key = getch(interrupts=False)\n\n        if key == keys.CTRL_C:\n           break\n\n        widget.handle_key(key) \n\n        save_cursor()\n\n        for line in widget.get_lines():\n           print(line)\n\n        restore_cursor()\n\n    return widget\n</code></pre> <p>This fixes the issue, but you may notice our widget only gets printed after the first input. That happens because we call <code>getch</code> before the first prints. Let's fix it, and also move the printing logic into an inner function to make things cleaner:</p> ChangesUpdated file <pre><code>  from typing import TypeVar\n  from pytermgui import getch, keys, save_cursor, restore_cursor, Widget\n\n  def inline(widget):\n+     def _print_widget():\n+         save_cursor()\n+\n+         for line in widget.get_lines():\n+            print(line)\n+\n+         restore_cursor()\n+\n+     _print_widget()\n+\n     while True:\n          key = getch(interrupts=False)\n\n          if key == keys.CTRL_C:\n             break\n\n          widget.handle_key(key) \n\n+         _print_widget()\n-         save_cursor()\n-\n-         for line in widget.get_lines():\n-            print(line)\n-\n-         restore_cursor()\n\n     return widget\n</code></pre> inline.py<pre><code>from typing import TypeVar\nfrom pytermgui import getch, keys, save_cursor, restore_cursor, Widget\n\ndef inline(widget):\n    def _print_widget():\n        save_cursor()\n\n        for line in widget.get_lines():\n           print(line)\n\n        restore_cursor()\n\n    _print_widget()\n\n    while True:\n        key = getch(interrupts=False)\n\n        if key == keys.CTRL_C:\n           break\n\n        widget.handle_key(key) \n\n        _print_widget()\n\n    return widget\n</code></pre> <p>You may have noticed that when exiting, part of the widget remains on the screen. This is the last print-related issue we need to fix!</p> <p>We can use the clear function with the \"line\" parameter to clear all the affected lines of the terminal.</p> <p>Let's introduce a new inner function, <code>_clear_widget</code>:</p> <pre><code>def _clear_widget():\n    save_cursor()\n\n    for _ in range(widget.height):\n        clear(\"line\")\n        terminal.write(\"\\n\") # (1)\n\n    restore_cursor()\n    terminal.flush()\n</code></pre> <ol> <li>We need to increment the cursor using newlines to make sure we aren't just clearing the same line over and over.</li> </ol> <p>To include this, we need to import both <code>clear</code> and <code>terminal</code>. We also probably want to call our new function, specifically before the call to print and at the end of our <code>inline</code> routine.</p> <p>Here is a snapshot of our work so far:</p> ChangesUpdated file <pre><code>  from typing import TypeVar\n- from pytermgui import getch, keys, save_cursor, restore_cursor, Widget\n+ from pytermgui import (\n+     getch,\n+     keys,\n+     save_cursor,\n+     restore_cursor,\n+     Widget,\n+     clear,\n+     get_terminal,\n+ )\n\n def inline(widget):\n+     # Make sure we use the global terminal\n+     terminal = get_terminal()\n+\n     def _print_widget():\n          save_cursor()\n\n          for line in widget.get_lines():\n              print(line)\n\n          restore_cursor()\n\n+     def _clear_widget():\n+         save_cursor()\n+\n+         for _ in range(widget.height):\n+             clear(\"line\")\n+             terminal.write(\"\\n\")\n+\n+          restore_cursor()\n+          terminal.flush()\n\n     _print_widget()\n\n      while True:\n          key = getch(interrupts=False)\n\n          if key == keys.CTRL_C:\n              break\n\n          widget.handle_key(key) \n\n+         _clear_widget()\n         _print_widget()\n+\n+     _clear_widget()\n     return widget\n</code></pre> inline.py<pre><code>from typing import TypeVar\nfrom pytermgui import (\n    getch,\n    keys,\n    save_cursor,\n    restore_cursor,\n    Widget,\n    clear,\n    get_terminal,\n)\n\ndef inline(widget):\n    # Make sure we use the global terminal\n    terminal = get_terminal()\n\n    def _print_widget():\n        save_cursor()\n\n        for line in widget.get_lines():\n            print(line)\n\n        restore_cursor()\n\n    def _clear_widget():\n        save_cursor()\n\n        for _ in range(widget.height):\n            clear(\"line\")\n            terminal.write(\"\\n\")\n\n        restore_cursor()\n        terminal.flush()\n\n    _print_widget()\n\n    while True:\n        key = getch(interrupts=False)\n\n        if key == keys.CTRL_C:\n            break\n\n        widget.handle_key(key)\n\n        _clear_widget()\n        _print_widget()\n\n    _clear_widget()\n    return widget\n</code></pre> <p>And with that, our printing routine is exactly how we want it to be! Now onto the fancy things.</p>"},{"location":"walkthroughs/inline/#mouse-support","title":"Mouse support","text":"<p>Traditionally, mouse support is the \"big bad\" enemy of writing terminal programs. However, PyTermGUI makes it a lot easier than you would've thought!</p> <p>The only new thing we will need to import is the mouse_handler context manager. This function does 2 things:</p> <ul> <li>Tells the terminal to send mouse events</li> <li>Returns a function that can translate mouse codes into MouseEvent instances</li> </ul> <p>To use it, we will wrap our <code>while True</code> loop into the context, and try to handle keys as mouse events when our widget didn't handle them successfully. Each widget denotes \"successful\" event handling by returning <code>True</code> from the given method, so the check will be simple:</p> <pre><code>+ with mouse_handler([\"press_hold\", \"hover\"], \"decimal_xterm\") as translate:\n     while True:\n          key = getch(interrupts=False)\n\n          if key == keys.CTRL_C:\n              break\n\n-         widget.handle_key(key)\n+         if not widget.handle_key(key):\n+             for event in translate(key):\n+                 if event is None:\n+                     continue\n+                 widget.handle_mouse(event)\n\n         _clear_widget()\n          _print_widget()\n\n_clear_widget()\nreturn widget\n</code></pre> <p>There is a tiny bug with our mouse handling, however. We never tell the widget where it is located, so it will reject most events. We can easily fix this by using the report_mouse and inserting the following line at the top of our function:</p> <pre><code>widget.pos = report_cursor()\n</code></pre> <p>With the above changes, our file looks like the following:</p> inline.py<pre><code>from typing import TypeVar\nfrom pytermgui import (\n    getch,\n    keys,\n    save_cursor,\n    restore_cursor,\n    report_cursor,\n    Widget,\n    clear,\n    get_terminal,\n    mouse_handler,\n)\n\ndef inline(widget):\n    # Make sure we use the global terminal\n    terminal = get_terminal()\n\n    widget.pos = report_cursor()\n\n    def _print_widget():\n        save_cursor()\n\n        for line in widget.get_lines():\n            print(line)\n\n        restore_cursor()\n\n    def _clear_widget():\n        save_cursor()\n\n        for _ in range(widget.height):\n            clear(\"line\")\n            terminal.write(\"\\n\")\n\n        restore_cursor()\n        terminal.flush()\n\n    _print_widget()\n\n    with mouse_handler([\"press_hold\", \"hover\"], \"decimal_xterm\") as translate:\n        while True:\n            key = getch(interrupts=False)\n\n            if key == keys.CTRL_C:\n                break\n\n            if not widget.handle_key(key):\n                events = translate(key)\n                # Don't try iterating when there are no events\n                if events is None:\n                    continue\n\n                for event in events:\n                    if event is None:\n                        continue\n                    widget.handle_mouse(event)\n\n            _clear_widget()\n            _print_widget()\n\n    _clear_widget()\n    return widget\n</code></pre>"},{"location":"walkthroughs/inline/#congratulations","title":"Congratulations!","text":"<p>You just implemented PyTermGUI's inline function!</p> <p>Make sure to look at its source code for the final version of the code we've been working with, along with a few extra improvements, such as handling each the widget's <code>positioned_line_buffer</code>.</p>"},{"location":"widgets/attrs/","title":"Attributes to know about","text":"<p>All widgets share a set of attributes that can be used to make things look the way you want. Here is a quick overview on them.</p> <p>Note</p> <p>This API will likely be reformed in the future to be properly controllable through YAML config files. The underlying attributes will remain the same, but the way to access/modify them will be improved.</p>"},{"location":"widgets/attrs/#applicable-to-all","title":"Applicable to all","text":""},{"location":"widgets/attrs/#parent-align","title":"Parent align","text":"<p>This attribute can be used to tell a widget's parent to align it left, right or center.</p> <p>Possible values:</p> <ul> <li><code>HorizontalAlignment.LEFT</code> or <code>0</code>: Aligns to the left side.</li> <li><code>HorizontalAlignment.CENTER</code> or <code>1</code>: Aligns to the center.</li> <li><code>HorizontalAlignment.RIGHT</code> or <code>2</code>: Aligns to the right.</li> </ul> <p>Default: <code>HorizontalAlignment.CENTER</code></p> PythonOutput <pre><code>from pytermgui import Container, Label, pretty\n\ncontainer = Container(\n    Label(\"This is the left\", parent_align=0),\n    Label(\"This is the center\", parent_align=1),\n    Label(\"This is the right\", parent_align=2),\n)\n\nfor line in container.get_lines():\n    print(line)\n</code></pre> <p> docs/src/widgets/attrs/parent_align.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502\u00a0 This\u00a0is\u00a0the\u00a0left \u00a0\u2502 \u2502\u00a0 This\u00a0is\u00a0the\u00a0center \u00a0\u2502 \u2502\u00a0 This\u00a0is\u00a0the\u00a0right \u00a0\u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 <p></p>"},{"location":"widgets/attrs/#size-policy","title":"Size policy","text":"<p>Widget width adjustments are handled through a system of policies. The basics are:</p> <ul> <li><code>SizePolicy.FILL</code>: The widget will take up the entire width provided by its parent.</li> <li><code>SizePolicy.STATIC</code>: The widget will remain at a certain width, and its parent will never try to resize it.</li> <li><code>SizePolicy.RELATIVE</code>: The widget will take up a certain percentage of its parent's width, denoted by a floating point value between 0 and 1. </li> </ul> <p>While you can set these manually, it's easier for the both of us if you use the helper properties instead:</p> <p></p> <p> def Widget . static_width (self)\u00a0-&gt;\u00a0 int : Allows\u00a0for\u00a0a\u00a0shorter\u00a0way\u00a0of\u00a0setting\u00a0a\u00a0width,\u00a0and\u00a0SizePolicy.STATIC. Args: \u00a0\u00a0\u00a0\u00a0value:\u00a0The\u00a0new\u00a0width\u00a0integer. Returns: \u00a0\u00a0\u00a0\u00a0None,\u00a0as\u00a0this\u00a0is\u00a0setter\u00a0only. def Widget . relative_width (self)\u00a0-&gt;\u00a0 float \u00a0|\u00a0 None : Sets\u00a0this\u00a0widget's\u00a0relative\u00a0width,\u00a0and\u00a0changes\u00a0size_policy\u00a0to\u00a0RELATIVE. The\u00a0value\u00a0is\u00a0clamped\u00a0to\u00a01.0. If\u00a0a\u00a0Container\u00a0holds\u00a0a\u00a0width\u00a0of\u00a030,\u00a0and\u00a0it\u00a0has\u00a0a\u00a0subwidget\u00a0with\u00a0a\u00a0relative width\u00a0of\u00a00.5,\u00a0it\u00a0will\u00a0be\u00a0resized\u00a0to\u00a015. Args: \u00a0\u00a0\u00a0\u00a0value:\u00a0The\u00a0multiplier\u00a0to\u00a0apply\u00a0to\u00a0the\u00a0parent's\u00a0width. Returns: \u00a0\u00a0\u00a0\u00a0The\u00a0current\u00a0relative_width. </p> <p>Default: <code>SizePolicy.FILL</code></p> <p>Warning</p> <p><code>SizePolicy.STATIC</code> can cause various issues if the parent widget doesn't have enough width available. If using it, make sure to make sure that the parent will never be smaller than the given widget!</p> PythonOutput <pre><code>from pytermgui import Container, SizePolicy, pretty\n\ncontainer = Container(\n    Container(\"I fill the space\"),\n    Container(\"I take up 70%\", relative_width=0.7),\n    Container(\"I take up exactly\\n31 characters\", static_width=31),\n)\n\n\nfor line in container.get_lines():\n    print(line)\n</code></pre> <p> docs/src/widgets/attrs/size_policy.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502\u00a0 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u00a0\u2502 \u2502\u00a0 \u2502\u00a0 I\u00a0fill\u00a0the\u00a0space \u00a0\u2502 \u00a0\u2502 \u2502\u00a0 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u00a0\u2502 \u2502\u00a0 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u00a0\u2502 \u2502\u00a0 \u2502\u00a0 I\u00a0take\u00a0up\u00a070% \u00a0\u2502 \u00a0\u2502 \u2502\u00a0 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u00a0\u2502 \u2502\u00a0 \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u00a0\u2502 \u2502\u00a0 \u2502\u00a0 I\u00a0take\u00a0up\u00a0exactly\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u2502 \u00a0\u2502 \u2502\u00a0 \u2502\u00a0 31\u00a0characters \u00a0\u2502 \u00a0\u2502 \u2502\u00a0 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u00a0\u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 <p></p>"},{"location":"widgets/attrs/#applicable-to-container","title":"Applicable to Container","text":""},{"location":"widgets/attrs/#box","title":"Box","text":"<p>The container <code>border</code> and <code>corner</code> characters can be set to a few presets, which are defined in the boxes module. </p> <p>Setting the <code>box</code> attribute to either a <code>Box</code> instance or an upper-cased box name will set both the <code>border</code> and <code>corner</code> characters to those defined by the box.</p> <p>Default: <code>SINGLE</code> for <code>Container</code>, <code>DOUBLE</code> for <code>Window</code>.</p> PythonOutput <pre><code>from pytermgui import Container, boxes, pretty\n\ncontainer = Container(box=\"EMPTY\")\n\nfor name in [name for name in dir(boxes) if name.isupper()]:\n    box = getattr(boxes, name)\n\n    container += Container(\n        f\"[primary]{name}\",\n        box=box,\n    )\n\nfor line in container.get_lines():\n    print(line)\n</code></pre> <p> docs/src/widgets/attrs/box.py ---------------------------------------------------------------------- |\u00a0 BASIC \u00a0| ---------------------------------------------------------------------- \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551\u00a0 DOUBLE \u00a0\u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2502\u00a0 DOUBLE_BOTTOM \u00a0\u2502 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2502\u00a0 DOUBLE_HORIZONTAL \u00a0\u2502 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2551\u00a0 DOUBLE_SIDES \u00a0\u2551 \u2570 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256f \u256d \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u256e \u2502\u00a0 DOUBLE_TOP \u00a0\u2502 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2551\u00a0 DOUBLE_VERTICAL \u00a0\u2551 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f EMPTY \u2502 \u2502 \u2502\u00a0 EMPTY_HORIZONTAL \u00a0\u2502 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 EMPTY_VERTICAL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u250f \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 \u2513 \u2503\u00a0 HEAVY \u00a0\u2503 \u2517 \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 \u251b \u256d \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256e \u2502\u00a0 ROUNDED \u00a0\u2502 \u2570 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u256f \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502\u00a0 SINGLE \u00a0\u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 \u2554 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2502\u00a0 SINGLE_HORIZONTAL \u00a0\u2502 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d \u2554 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2557 \u2551\u00a0 SINGLE_VERTICAL \u00a0\u2551 \u255a \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u255d <p></p>"},{"location":"widgets/attrs/#applicable-to-window","title":"Applicable to Window","text":"<p>Note</p> <p>Container's attributes also apply to Window.</p>"},{"location":"widgets/attrs/#title","title":"Title","text":"<p>Windows can display text on the top-left corner of their borders.</p> <p>Warning</p> <p>You can only use markup in titles if the given window's <code>corner_style</code> parses TIM. This will always be the case with string-based shorthand styles, but may not be for custom callables. See the styling section for more info!</p> <p>Default: <code>\"\"</code></p> PythonOutput <pre><code>from pytermgui import Window\n\n\nwindow = Window(\"This is my test window\")\nwindow.set_title(\"[surface+2]Welcome to the docs!\")\n</code></pre> <p> docs/src/widgets/attrs/title.py \u2554\u00a0 Welcome\u00a0to\u00a0the\u00a0docs!\u00a0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u2557 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 This\u00a0is\u00a0my\u00a0test\u00a0window \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u2551\u00a0 \u00a0\u2551 \u255a \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \u255d <p></p>"},{"location":"widgets/builtins/","title":"The batteries included","text":"<p>We provide a growing selection of widgets you can drop straight into your projects. Looking at the <code>widgets</code> submodule's contents can help illuminate you on the exact selection, but this page describes the most commonly used ones.</p>"},{"location":"widgets/builtins/#a-note-about-auto","title":"A note about <code>auto</code>","text":"<p>Some widgets below will have an <code>Auto syntax</code> field shown. The format shown can be used by the auto function to generate widgets from Python datatypes. This function is conveniently called within <code>Container</code> and all its subclasses (<code>Splitter</code>, <code>Window</code>, <code>Collapsible</code> &amp; more) to let you easily create widgets with minimal imports.</p> <p>For example:</p> <pre><code>from pytermgui import Container\n\ncontainer = Container(\n    \"[bold accent]This is my example\",\n    \"\",\n    \"[surface+1 dim italic]It is very cool, you see\",\n    \"\",\n    {\"My first label\": [\"Some button\"]},\n    {\"My second label\": [False]},\n    \"\",\n    (\"Left side\", \"Middle\", \"Right side\"),\n    \"\",\n    [\"Submit button\"]\n)\n</code></pre> <p>...is functionally identical to:</p> <pre><code>from pytermgui import Container, Label, Splitter, Button, Checkbox\n\ncontainer = Container(\n    Label(\"[bold accent]This is my example\"),\n    Label(\"\"),\n    Label(\"[surface+1 dim italic]It is very cool, you see\"),\n    Label(\"\"),\n    Splitter(\n        Label(\"My first label\", parent_align=0),\n        Button(\"Some button\", parent_align=2),\n    ),\n    Splitter(\n        Label(\"My second label\"),\n        Checkbox(),\n    ),\n    Label(\"\"),\n    Splitter(Label(\"Left side\"), Label(\"Middle\"), Label(\"Right side\")),\n    Label(\"\"),\n    Button(\"Submit button\"),\n)\n</code></pre> <p>You can use whichever you find more convenient and readable.</p>"},{"location":"widgets/builtins/#label","title":"Label","text":"<p>A simple widget meant to display text. Supports line breaking and styling using both markup and simple callables.</p> <p>Auto syntax: <code>\"label_value\"</code></p> <p>Chars: N/A</p> <p>Styles:</p> <ul> <li> <p><code>value</code>: Applies to the text within the label.</p> <p>Default: No styling.</p> </li> </ul>"},{"location":"widgets/builtins/#container","title":"Container","text":"<p>A widget to display other widgets, stacked vertically. It may display a box around said widgets as well, using the <code>border</code> and <code>corner</code> characters.</p> <p>Auto syntax: N/A</p> <p>Chars:</p> <ul> <li><code>border</code>: A <code>list[str]</code> in the order <code>left, top, right, bottom</code> that makes up the borders of the outer box.</li> <li><code>corner</code>: A <code>list[str]</code> in the order <code>top_left, top_right, bottom_right, bottom_left</code> that makes up the corners of the outer box.</li> </ul> <p>Styles:</p> <ul> <li> <p><code>border</code>: Applies to all border characters of the outer box.</p> <p>Default: <code>surface</code>.</p> </li> <li> <p><code>corner</code>: Applies to all corner characters of the outer box.</p> <p>Default: <code>surface</code>.</p> </li> <li> <p><code>fill</code>: Applies to the filler characters used for padding.</p> <p>Default: <code>background</code>.</p> </li> </ul>"},{"location":"widgets/builtins/#splitter","title":"Splitter","text":"<p>Similar to Container, but displays widgets stacked horizontally instead. Each widget is separated by the <code>separator</code> character set.</p> <p>Auto syntax:</p> <ul> <li><code>(widget1, widget2, ...)</code></li> <li><code>{widget_aligned_left: widget_aligned_right)</code></li> </ul> <p>Chars:</p> <ul> <li><code>separator</code>: The <code>str</code> used to join the contained widgets.</li> </ul> <p>Styles:</p> <ul> <li> <p><code>separator</code>: Applies to the <code>separator</code> character.</p> <p>Default: <code>surface</code>.</p> </li> </ul>"},{"location":"widgets/builtins/#collapsible","title":"Collapsible","text":"<p>A widget that hides or shows whatever other widgets it is given. It will always display its \"trigger\", the <code>Button</code> used to collapse or expand its content.</p> <p>Auto syntax: N/A</p> <p>Chars: </p> <ul> <li>See <code>Container</code>.</li> </ul> <p>Styles:</p> <ul> <li>See <code>Container</code>.</li> </ul>"},{"location":"widgets/builtins/#window","title":"Window","text":"<p>An extended version of <code>Container</code>, used in the <code>window_manager</code> context.</p> <p>Auto syntax: N/A</p> <p>Chars:</p> <p>See <code>Container</code>.</p> <p>Styles:</p> <p>Same as <code>Container</code>, but expanded with:</p> <ul> <li> <p><code>border_focused</code>: Analogous to <code>border</code>, but only applied when the window is focused.</p> <p>Default: <code>surface</code>.</p> </li> <li> <p><code>corner_focused</code>: Analogous to <code>corner</code>, but only applied when the window is focused.</p> <p>Default: <code>surface</code>.</p> </li> <li> <p><code>border_focused</code>: Analogous to <code>border</code>, but only applied when the window is NOT focused.</p> <p>Default: <code>surface-2</code>.</p> </li> <li> <p><code>corner_focused</code>: Analogous to <code>corner</code>, but only applied when the window is NOT focused.</p> <p>Default: <code>surface-2</code>.</p> </li> </ul>"},{"location":"widgets/builtins/#button","title":"Button","text":"<p>Something clickable. All widgets can be made clickable by defining an <code>on_click</code> method, but this widget looks the part as well.</p> <p>Auto syntax:</p> <ul> <li><code>[\"button_label\", button_callback]</code></li> </ul> <p>Chars:</p> <ul> <li><code>delimiter</code>: a <code>list[str]</code> in the order <code>left, right</code>. Each character will be placed at the respective sides of the label.</li> </ul> <p>Styles:</p> <p>All styles here apply to the full label, including the left and right hand side delimiters.</p> <ul> <li> <p><code>label</code>: Applies in the normal state (e.g. no hover, click applied).</p> <p>Default: <code>@surface dim</code>.</p> </li> <li> <p><code>highlight</code>: Applies when the button is interacted with.</p> <p>Default: <code>@surface+1 dim</code>.</p> </li> </ul>"},{"location":"widgets/builtins/#keyboardbutton","title":"KeyboardButton","text":"<p>Much like button, but has a default binding applied to it. This binding is also reflected in its label.</p> <p>Auto syntax: N/A</p> <p>Chars:</p> <ul> <li>All <code>Button</code> chars</li> <li><code>bracket</code>: Used to wrap the button's bound key.</li> </ul> <p>Styles:</p> <ul> <li>See <code>Button</code>.</li> </ul>"},{"location":"widgets/builtins/#checkbox","title":"Checkbox","text":"<p>A simple check box, you know the drill.</p> <p>Auto syntax: </p> <ul> <li><code>[bool_default, callback_method]</code></li> </ul> <p>Chars:</p> <ul> <li><code>delimiter</code>: Wraps the checkbox's value</li> <li><code>checked</code>: The character inserted between delimiters when the widget is checked.</li> <li><code>unchecked</code>: The character inserted between delimiters when the widget is unchecked.</li> </ul> <p>Styles:</p> <ul> <li>See <code>Button</code>.</li> </ul>"},{"location":"widgets/builtins/#toggle","title":"Toggle","text":"<p>A button that toggles its label between the two given values.</p> <p>Auto syntax:</p> <ul> <li><code>[(\"label_1\", \"label_2\"), callback_method]</code></li> </ul> <p>Chars:</p> <ul> <li>See <code>Button</code>.</li> </ul> <p>Styles:</p> <ul> <li>See <code>Button</code>.</li> </ul>"},{"location":"widgets/builtins/#slider","title":"Slider","text":"<p>A widget to display and/or control a floating point value.</p> <p>Auto syntax: N/A</p> <p>Chars:</p> <ul> <li><code>cursor</code>: The character placed at the end of the filled section. If nothing is given, <code>rail</code> is used.</li> <li><code>rail</code>: Used to fill up the width of the slider, colored as applicable.</li> <li><code>delimiter</code>: Wraps the <code>rail</code> characters on both sides.</li> </ul> <p>Styles:</p> <ul> <li> <p><code>cursor</code>: Applied to the <code>cursor</code> character, or the last character of the rail.</p> <p>Default: <code>primary</code>.</p> </li> <li> <p><code>filled</code>: Applied to the filled section of the rail if the slider is not selected.</p> <p>Default: <code>surface+1</code>.</p> </li> <li> <p><code>filled_selected</code>: Applied to the filled section of the rail if the slider is selected.</p> <p>Default: <code>primary</code>.</p> </li> <li> <p><code>unfilled</code>: Applied to the unfilled section of the rail if the slider is not selected.</p> <p>Default: <code>surface-1</code>.</p> </li> <li> <p><code>unfilled_selected</code>: Applied to the unfilled section of the rail if the slider is selected.</p> <p>Default: <code>surface</code>.</p> </li> </ul>"},{"location":"widgets/builtins/#inputfield","title":"InputField","text":"<p>A field to display input. Should be used in a context that sends it keyboard inputs, such as <code>WindowManager</code>.</p> <p>Auto syntax: N/A</p> <p>Chars: N/A</p> <p>Styles:</p> <ul> <li> <p><code>value</code>: Applies to the text of the input field.</p> <p>Default: No styling.</p> </li> <li> <p><code>prompt</code>: Applies to the string displayed before the field's value, controlled by the <code>prompt</code> parameter.</p> <p>Default: <code>surface+2</code></p> </li> <li> <p><code>cursor</code>: Applies to the field's cursor.</p> <p>Default: <code>@primary dim #auto</code></p> </li> </ul>"},{"location":"widgets/builtins/#pixelmatrix","title":"PixelMatrix","text":"<p>A customizable matrix of unicode pixels. With some image decoding, it can be used to display low-resolution pictures.</p> <p>Auto syntax: N/A</p> <p>Chars: N/A</p> <p>Styles: N/A</p>"},{"location":"widgets/builtins/#densepixelmatrix","title":"DensePixelMatrix","text":"<p>Similar to <code>PixelMatrix</code>, but instead of using two unicode block characters per pixel, it uses either the upper or lower half of one. Allows for higher resolution pictures!</p> <p>Auto syntax: N/A</p> <p>Chars: See <code>PixelMatrix</code></p> <p>Styles: See <code>PixelMatrix</code></p>"},{"location":"widgets/custom/","title":"Create your own","text":"<p>While the default widgets are pretty nifty themselves, sometimes you might wanna do your own thing. Luckily for you, PyTermGUI's <code>Widget</code> API is ridiculously easy to build upon!</p>"},{"location":"widgets/custom/#what-to-know","title":"What to know","text":"<p>Firstly, you should know some things about the shape and function of various parts of the API.</p>"},{"location":"widgets/custom/#output-rendering","title":"Output &amp; rendering","text":"<p>The most important method to a widget is its <code>get_lines</code>. This returns a list of strings, which is what is used to eventually display it in the terminal. This method is called a healthy amount, so you probably wanna make all state changes in some other place, so <code>get_lines</code> can request mostly static data.</p>"},{"location":"widgets/custom/#selectables","title":"Selectables","text":"<p>Each widget can be made selectable by either setting <code>widget._selectables_length</code> to a non-zero value, or overwriting the <code>selectables_length</code> property of said widget.</p> <p>If you want to make parent widgets know that your widget can be selected, you can just define <code>_selectables_length</code> as 1. If you have multiple inner-widgets you need to handle selecting, you should inherit from <code>Container</code> and let it handle all the plumbing for you. If you're interested in how it does all that magic, see it's selectables property, and its select method.</p>"},{"location":"widgets/custom/#input-handling","title":"Input handling","text":"<p>Both keyboard and mouse inputs are cascaded down from the <code>WindowManager</code> to each widget. A widget can mark some input as \"handled\" and stop it from cascading further by having its handler method return <code>True</code>.</p> <p>Note</p> <p>The base <code>Widget</code> class may go through some routines for each input, such as calling any widget bindings, or, in the case of mouse inputs, call semantic handlers.</p> <p>Because of this, and to ensure future backwards-compatibility (weird phrase, I know), you should start all your input handlers by calling the parent class' handler:</p> <pre><code>class MyWidget(Widget):\n    def handle_key(self, key: str) -&gt; bool:\n        if super().handle_key(key):\n            return\n\n        # Do our own handling\n</code></pre>"},{"location":"widgets/custom/#keyboard-input","title":"Keyboard input","text":"<p>The signature of the keyboard handler is pretty simple:</p> <pre><code>def handle_key(self, key: str) -&gt; bool\n</code></pre> <p>To compare key codes to canonical names (e.g. <code>CTRL_B</code> to <code>\\x02</code>), you can use the <code>keys</code> singleton:</p> <pre><code>from pytermgui import Widget, keys\n\n\nclass MyWidget(Widget):\n    def handle_key(self, key: str) -&gt; bool:\n        if super().handle_key(key):\n            return True\n\n        if key == keys.CTRL_F:\n            self.do_something()\n            return True\n\n        return False\n</code></pre>"},{"location":"widgets/custom/#mouse-input","title":"Mouse input","text":"<p>While terminal mouse inputs are historically pretty hard to handle, PTG offers a simple interface to hide all that paperwork. </p> <p>An interface symmetrical to the keyboard handlers exists, and is the base of all that comes below:</p> <pre><code>def handle_mouse(self, event: MouseEvent) -&gt; bool:\n</code></pre> <p>The only argument is the <code>event</code>, which is an instance of MouseEvent. This is what it looks like:</p> <p> inspect(MouseEvent) \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502\u00a0 pytermgui.ansi_interface.MouseEvent \u00a0\u2502 \u2502\u00a0 Located\u00a0in\u00a0 /Users/lapis/Code/Projects/pytermgui/pytermgui/ansi_interface.py \u00a0\u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 class MouseEvent (action:\u00a0 MouseAction ,\u00a0position:\u00a0 tuple [ int ,\u00a0 int ])\u00a0-&gt;\u00a0 None : A\u00a0class\u00a0to\u00a0represent\u00a0events\u00a0created\u00a0by\u00a0mouse\u00a0actions. Its\u00a0first\u00a0argument\u00a0is\u00a0a\u00a0`MouseAction`\u00a0describing\u00a0what\u00a0happened, and\u00a0its\u00a0second\u00a0argument\u00a0is\u00a0a\u00a0`tuple[int,\u00a0int]`\u00a0describing\u00a0where it\u00a0happened. This\u00a0class\u00a0mostly\u00a0exists\u00a0for\u00a0readability\u00a0&amp;\u00a0typing\u00a0reasons.\u00a0It\u00a0also implements\u00a0the\u00a0iterable\u00a0protocol,\u00a0so\u00a0you\u00a0can\u00a0use\u00a0the\u00a0unpacking\u00a0syntax, such\u00a0as: ```python3 action,\u00a0position\u00a0=\u00a0MouseEvent(...) ``` def is_primary (self)\u00a0-&gt;\u00a0 bool : Returns\u00a0True\u00a0if\u00a0event.action\u00a0is\u00a0one\u00a0of\u00a0the\u00a0primary\u00a0(left-button)\u00a0actions. def is_scroll (self)\u00a0-&gt;\u00a0 bool : Returns\u00a0True\u00a0if\u00a0event.action\u00a0is\u00a0one\u00a0of\u00a0the\u00a0scrolling\u00a0actions. def is_secondary (self)\u00a0-&gt;\u00a0 bool : Returns\u00a0True\u00a0if\u00a0event.action\u00a0is\u00a0one\u00a0of\u00a0the\u00a0secondary\u00a0(secondary-button)\u00a0a ctions. </p> <p>Depending on your circumstances, you can test the event's <code>position</code> or <code>action</code> attributes:</p> <pre><code>from pytermgui import Widget, MouseEvent, MouseAction\n\nclass MyWidget(Widget):\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n        if super().handle_mouse(event):\n            return True\n\n        if event.action == MouseAction.LEFT_CLICK:\n            self.do_something()\n</code></pre> <p>Since comparing against actions gets a li'l tedious over time, we have a system called semantic mouse handlers to help you. These are optional methods that are looked for when <code>Widget</code> is handling some mouse event, and only called when present.</p> <p>They all follow the syntax <code>on_{event_name}</code>. events can be one of:</p> <pre><code>[\n    \"left_click\",\n    \"right_click\",\n    \"click\",\n    \"left_drag\",\n    \"right_drag\",\n    \"drag\",\n    \"scroll_up\",\n    \"scroll_down\",\n    \"scroll\",\n    \"shift_scroll_up\",\n    \"shift_scroll_down\",\n    \"shift_scroll\",\n    \"hover\",\n]\n</code></pre> <p>Handler methods are looked for in the order of highest specifity. For example, the following widget:</p> <pre><code>from pytermgui import MouseEvent, Widget\n\n\nclass MyWidget(Widget):\n    label: str = \"No action\"\n\n    def get_lines(self) -&gt; list[str]:\n        return [self.label]\n\n    def on_left_click(self, event: MouseEvent) -&gt; bool:\n        self.label = \"Left click\"\n\n        return True\n\n    def on_click(self, event: MouseEvent) -&gt; bool:\n        self.label = \"Generic click\"\n\n        return True \n\n    def handle_mouse(self, event: MouseEvent) -&gt; bool:\n        # Make sure we call the super handler\n        if super().handle_mouse(event):\n            return True\n\n        self.label = \"No action\"\n        return True\n</code></pre> <p>...will display <code>Left click</code> only on left clicks, <code>Generic click</code> only on right clicks (as <code>on_right_click</code> isn't defined) and <code>No action</code> on any other mouse input.</p>"},{"location":"widgets/custom/#faq","title":"FAQ","text":""},{"location":"widgets/custom/#how-do-i-dynamically-update-a-widgets-content","title":"How do I dynamically update a widget's content?","text":"<p>The pattern I've come to adopt for this purpose is based on a regularly updated inner state that gets displayed within <code>get_lines</code>. For example, let's say we have a <code>Weather</code> widget that regularly requests weather information and displays it. </p> <p>Here is how I would do it. Take extra notice of the highlighted lines:</p> PythonOutput <pre><code>from dataclasses import dataclass\nfrom threading import Thread\nfrom time import sleep\n\nfrom pytermgui import Container, StyleManager, real_length, tim\n\n\n@dataclass\nclass WeatherData:\n    state: str\n    wind: str\n    clouds: str\n\n\nclass Weather(Container):\n    # We want to retain the Container styles, so we merge in some new ones\n    styles = StyleManager.merge(\n        Container.styles,\n        sunny=\"yellow\",\n        cloudy=\"grey\",\n        rainy=\"darkblue\",\n        snowy=\"snow\",\n        detail=\"245\",\n    )\n\n    # Same story as above; unpacking into sets allows us to merge 2 dicts!\n    chars = {\n        **Container.chars,\n        **{\n            \"sunny\": \"\u2600\",\n            \"cloudy\": \"\u2601\",\n            \"rainy\": \"\u2602\",\n            \"snowy\": \"\u2603\",\n        },\n    }\n\n    def __init__(self, location: str, timeout: int, **attrs) -&gt; None:\n        super().__init__(**attrs)\n\n        self.location = location\n        self.timeout = timeout\n\n        Thread(target=self._monitor_loop, daemon=True).start()\n\n\n    def _request_data(self) -&gt; WeatherData:\n        ...\n\n    def _monitor_loop(self) -&gt; None:\n        while True:\nself.data = self._request_data()\nself.update_content()\nsleep(self.timeout)\n\n    def update_content(self) -&gt; None:\n        state = self.data.state\n\n        style = self.styles[state]\n        char = self._get_char(state)\n        icon = style(char)\n\nself.set_widgets(\n[\nf\"{icon} It is currently {state} in {self.location}. {icon}\",\n\"\",\nf\"{self.styles.detail('Wind')}: {self.data.wind}\",\nf\"{self.styles.detail('Clouds')}: {self.data.clouds}\",\n]\n)\n</code></pre> <p> docs/src/widgets/weather.py \u250c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2510 \u2502\u00a0 \u2600 \u00a0It\u00a0is\u00a0currently\u00a0sunny\u00a0in\u00a0Los\u00a0Angeles.\u00a0 \u2600 \u00a0\u2502 \u2502\u00a0 \u00a0\u2502 \u2502\u00a0 Wind :\u00a015kph\u00a0N/W \u00a0\u2502 \u2502\u00a0 Clouds :\u00a0scattered \u00a0\u2502 \u2514 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2518 <p></p> <p>As you can see, I made the widget inherit <code>Container</code>. This is usually what you want when dealing with a widget that:</p> <ul> <li>Contains inner content representable by sub-widgets (<code>Label</code> in our case)</li> <li>Has to periodically update said inner content</li> </ul> <p>We also use a thread to do all the monitoring &amp; updating, instead of doing it in <code>get_lines</code> or some other periodically called method. Since <code>get_lines</code> is called very regularly, and its time-to-return is critical for the rendering of an application, we need to make sure to avoid putting anything with noticable delays in there.</p> Don't overuse threads <p>If you have multiple widgets that run on a thread-based monitor, you are likely better of creating a single master thread that updates every widget periodically. A simple monitor implementation like the following should work alright:</p> <pre><code>from __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom threading import Thread\nfrom time import sleep, time\nfrom typing import Callable\n\n\n@dataclass\nclass Listener:\n    callback: Callable[[], None]\n    period: float\n    time_till_next: float\n\n\n@dataclass\nclass Monitor:\n    update_frequency: float = 0.5\n    listeners: list[Listener] = field(default_factory=list)\n\n    def attach(self, callback: Callable[[], None], *, period: float) -&gt; Listener:\n        listener = Listener(callback, period, period)\n        self.listeners.append(listener)\n\n        return listener\n\n    def start(self) -&gt; Monitor:\n        def _monitor() -&gt; None:\n            previous = time()\n\n            while True:\n                elapsed = time() - previous\n\n                for listener in self.listeners:\n                    listener.time_till_next -= elapsed\n\n                    if listener.time_till_next &lt;= 0.0:\n                        listener.callback()\n                        listener.time_till_next = listener.period\n\n                previous = time()\n                sleep(self.update_frequency)\n\n        Thread(target=_monitor).start()\n        return self\n</code></pre> <p>You can then use this in your widgets:</p> <pre><code>from .monitor import Monitor\nfrom pytermgui import Container\n\nmonitor = Monitor().start()\n\nclass Weather(Container):\n    def __init__(self, location: str, timeout: float, **attrs: Any) -&gt; None:\n        ...  # Standard init code (see above)\n\n        monitor.attach(self._request_and_update, timeout) \n\n    def _request_and_update(self) -&gt; None:\n        self.data = self._request()\n        self.update_content()\n</code></pre> <p>Let's talk about those highlighted lines, shall we?</p> <p>In the first set of lines we send out a request to the (imaginary) external API, and update ourselves accordingly. This update is done in the second set of lines, where the <code>set_widgets</code> method is used to overwrite the current widget selection.</p> <p>Why use this method instead of manually overwriting <code>_widgets</code>?</p> <p>The reason this method was created in the first place was to simplify the process of:</p> <ul> <li>Emptying the container's widgets</li> <li>Resetting its height</li> <li>Going through a list, running <code>auto</code> on each item and adding it to the container</li> </ul> <p>It makes things a lot simpler, and it also accounts for any future oddities that mess with the process!</p>"},{"location":"widgets/styling/","title":"Palettes & styling","text":"<p>All built in widgets use a central color palette, referencable within TIM code. Each widget will use appropriate shades of the palette by default.</p> <p>Since this palette is defined globally, you can also re-generate it with new colors. It only requires a primary color, but you may give it as many as you please.</p> <p>Here is the default palette:</p> <p> pytermgui/palettes.py \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0primary\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#313a53\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#4a587c\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#6375a6\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#7c93d0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#96a8d9\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#b0bee2\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#cad3ec\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0secondary\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#53313a\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#7c4957\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a66274\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d07b92\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d995a7\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#e2afbd\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#eccad3\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0tertiary\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#3a5331\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#587c49\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#75a662\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#93d07b\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a8d995\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#bee2af\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d3ecca\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0accent\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#534a31\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#7c6f49\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a69462\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d0b97b\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d9c795\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#e2d5af\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#ece3ca\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0surface\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#191a20\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#252830\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#323540\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#3f4350\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#656873\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#8b8e96\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#b2b3b9\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0surface2\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#20191a\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#302528\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#403235\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#503f43\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#736568\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#968b8e\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#b9b2b3\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0surface3\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#1a2019\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#283025\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#354032\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#43503f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#687365\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#8e968b\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#b3b9b2\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0surface4\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#201e19\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#302d25\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#403c32\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#504b3f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#736f65\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#96938b\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#b9b7b2\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0success\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#2b533c\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#417c5a\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#57a678\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#6dd097\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#8ad9ab\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a7e2c0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#c4ecd5\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0warning\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#505035\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#787950\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a0a16b\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#c9ca86\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d3d49e\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#dedfb6\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#e9e9ce\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0error\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#503035\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#784950\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a0616b\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#c97a86\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d3949e\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#deafb6\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#e9c9ce\u00a0\u00a0\u00a0 </p> <p>As you can see, each color name has a set of negatively and positively shaded variants. These can be accessed in the format: <code>{color_name}{shade_offset}</code>, such as <code>primary+2</code> or <code>surface2-1</code>. The \"main\" color can be referred to without an offset, like <code>accent</code> or <code>success</code>. </p> <p>Each color also has a background variant assigned to it, which may be used by prefixing the color-of-interest by an at symbol (<code>@</code>), like <code>@error</code> or <code>@secondary+3</code>.</p> <p>Warning</p> <p>Since the underlying colors may change between runs, it's best to make sure contrast ratios are met at all times. This is possible in PTG using the <code>#auto</code> markup pseudo-tag.</p> <p>As mentioned later, the library will try to append this tag to any widget style without a set foreground color. To use it outside of a widget (or to make absolute certain that it applies), add it to your markup:</p> PythonOutput <pre><code>from pytermgui import tim\n\ntim.alias_multiple(**{\"@my-surface1\": \"@white\", \"@my-surface2\": \"@black\"})\ntim.print(\"[@my-surface1 #auto] Black on white [@my-surface2 #auto] White on black \")\n</code></pre> <p> \u00a0Black\u00a0on\u00a0white\u00a0 \u00a0White\u00a0on\u00a0black\u00a0 <p></p>"},{"location":"widgets/styling/#styling-widgets","title":"Styling widgets","text":"<p>As mentioned above, all widgets come with a basic, aesthetically pleasing set of styles. Sometimes though, you might wanna get a fresher look.</p>"},{"location":"widgets/styling/#modifying-the-palette","title":"Modifying the palette","text":"<p>The easiest way to change up the look of your apps is by manipulating the global palette. This will change the colors of all built-in widgets, and all custom ones (so long as they use the palette colors).</p> <p>This can be done using the Palette.regenerate method:</p> <pre><code>from pytermgui import palette\n\npalette.regenerate(primary=\"skyblue\")\n</code></pre> <p>Under the hood, it will look at the given color, and generate some complementaries for it. </p> <p>The above code gives use the following palette, by the way:</p> <p> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0primary\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#36525e\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#517b8d\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#6ca4bc\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#87ceeb\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#9fd7ef\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#b7e1f3\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#cfebf7\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0secondary\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#5e3652\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#8d517b\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#bc6ca4\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#eb87cd\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#ef9fd7\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#f3b7e1\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#f7cfeb\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0tertiary\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#525e36\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#7b8d51\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a4bc6c\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#ceeb87\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d7ef9f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#e1f3b7\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#ebf7cf\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0accent\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#5e4136\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#8d6251\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#bc836c\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#eba487\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#efb69f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#f3c8b7\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#f7dacf\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0surface\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#1a1f22\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#272f33\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#343f44\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#414f55\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#677277\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#8d9599\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#b3b8bb\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0surface2\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#221a1f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#33272f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#44343f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#55414f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#776772\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#998d95\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#bbb3b8\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0surface3\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#1f221a\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#2f3327\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#3f4434\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#4f5541\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#727767\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#95998d\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#b8bbb3\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0surface4\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#221c1a\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#332a27\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#443834\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#554741\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#776b67\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#99908d\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#bbb5b3\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0success\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#2c5a3f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#43875f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#59b47f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#70e29f\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#8ce7b2\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a9edc5\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#c5f3d8\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0warning\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#525838\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#7b8455\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a4b071\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#cddc8e\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d7e3a4\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#e1eabb\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#ebf1d1\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0error\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+1\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+2\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+3\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#523838\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#7b5455\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#a47071\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#cd8c8e\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#d7a3a4\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#e1babb\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#ebd1d1\u00a0\u00a0\u00a0 </p> <p>Note</p> <p>Using highly saturated colors as for the primary color will likely result in harsh looking styles. Even if you are tied to a certain neon-looking HEX color, it is usually nicer to use some toned-down version of it as the primary, and possibly including it as the <code>secondary</code>, <code>tertiary</code> or <code>accent</code> arguments.</p>"},{"location":"widgets/styling/#modifying-styles","title":"Modifying styles","text":"<p>If just changing the base colors isn't enough, you can add more involved styles on a per-widget basis. </p> <p>Assigning styles is done through each widget's StyleManager, which can be accessed using <code>widget.styles</code>.</p> <p>Properties can be set in a couple of ways. The simplest one uses the dot syntax:</p> <pre><code>widget.styles.label = my_style\n</code></pre> <p>You may also assign styles in the same statement as a widget's creation if you are pressed on space, by calling the <code>styles</code> property with a set of keyword arguments:</p> <pre><code>widget = MyWidget().style(label=my_style)\n</code></pre> <p>Finally, it is possible to assign multiple styles to the same value in one statement. This can be done by separating each key with 2 underscore characters, and works for either of the above methods:</p> <pre><code>widget.styles.border__corner = my_border_style\nwidget2 = MyWidget().styles(border__corner=my_border_style)\n</code></pre> <p>All the above examples modify styles pre-defined by the widget at declaration time. To see all the built-in styles, see the section on built-in widgets.</p> <p>Values for these calls can be of 2 general types:</p>"},{"location":"widgets/styling/#tim-string-shorthands","title":"TIM string shorthands","text":"<p>The easier way to create custom styles is by defining some markup for them. A fully expanded markup string contains both the <code>{depth}</code> and <code>{item}</code> template keys, but it can be shortened and expanded automatically for convenience.</p> <p><code>item</code> must be in the final style string. It represents the string that was passed for styling. <code>depth</code> is not necessary to use; it represents the given widget's <code>depth</code> property.</p> <p>For example, <code>surface+2 italic dim</code> would be expanded into <code>[surface+2 italic dim]{item}</code>, while <code>[!gradient(210) bold]{item}</code> would remain untouched.</p> <p>Info</p> <p>Under the hood, these strings will create MarkupFormatter instances, which perform the formatting and parsing when called.</p> <p>TL;DR: This method is only syntactic sugar over the one below.</p>"},{"location":"widgets/styling/#custom-callables","title":"Custom callables","text":"<p>For more granular control of a style, one may use a callable. These follow the following signature:</p> <pre><code>def my_style(depth: int, item: str) -&gt; str:\n</code></pre> <p>...where <code>depth</code> is an integer related to the styled widget, and <code>item</code> is the text in need of styling. The return of this is always assumed to be parsed, ANSI-coded text.</p> <p>This method is far more powerful than just using template string, but it's also a lot more noisy to write. Here is a cool button style:</p> <pre><code>from pytermgui import Button, Container, pretty, tim\n\ntemplate = \"[@primary #auto] {first} [@surface-1 #auto] {second} \"\n\n\ndef split_style(_: int, item: str) -&gt; str:\n    if \"&lt;SPLIT&gt;\" not in item:\n        return item\n\n    first, second = item.split(\"&lt;SPLIT&gt;\")\n    return tim.parse(template.format(first=first, second=second))\n\n\nButton.styles.label = split_style\nButton.set_char(\"delimiter\", [\"\"] * 2)\nmy_button = Button(\"Hey&lt;SPLIT&gt;There\")\n\npretty.print(my_button)\n</code></pre> <p>This gives the following result. See the <code>#auto</code> tag setting valid foregrounds for both light and dark backgrounds:</p> <p> docs/src/widgets/style_callables.py Button (label= \"Hey&lt;SPLIT&gt;There\" ,\u00a0padding= 0 ,\u00a0centered= False ) \u00a0Hey\u00a0 \u00a0There\u00a0 </p>"}]}